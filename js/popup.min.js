var bigInt = function (t) {
  "use strict";
  var e = 1e7,
    r = 9007199254740992,
    o = l(r),
    n = "function" == typeof BigInt;

  function i(t, e, r, o) {
    return void 0 === t ? i[0] : void 0 !== e && (10 != +e || r) ? C(t, e, r, o) : $(t)
  }

  function u(t, e) {
    this.value = t, this.sign = e, this.isSmall = !1
  }

  function p(t) {
    this.value = t, this.sign = t < 0, this.isSmall = !0
  }

  function a(t) {
    this.value = t
  }

  function s(t) {
    return -r < t && t < r
  }

  function l(t) {
    return t < 1e7 ? [t] : t < 1e14 ? [t % 1e7, Math.floor(t / 1e7)] : [t % 1e7, Math.floor(t / 1e7) % 1e7, Math.floor(t / 1e14)]
  }

  function f(t) {
    v(t);
    var r = t.length;
    if (r < 4 && O(t, o) < 0) switch (r) {
    case 0:
      return 0;
    case 1:
      return t[0];
    case 2:
      return t[0] + t[1] * e;
    default:
      return t[0] + (t[1] + t[2] * e) * e
    }
    return t
  }

  function v(t) {
    for (var e = t.length; 0 === t[--e];);
    t.length = e + 1
  }

  function h(t) {
    for (var e = new Array(t), r = -1; ++r < t;) e[r] = 0;
    return e
  }

  function y(t) {
    return t > 0 ? Math.floor(t) : Math.ceil(t)
  }

  function g(t, r) {
    var o, n, i = t.length,
      u = r.length,
      p = new Array(i),
      a = 0,
      s = e;
    for (n = 0; n < u; n++) a = (o = t[n] + r[n] + a) >= s ? 1 : 0, p[n] = o - a * s;
    for (; n < i;) a = (o = t[n] + a) === s ? 1 : 0, p[n++] = o - a * s;
    return a > 0 && p.push(a), p
  }

  function c(t, e) {
    return t.length >= e.length ? g(t, e) : g(e, t)
  }

  function m(t, r) {
    var o, n, i = t.length,
      u = new Array(i),
      p = e;
    for (n = 0; n < i; n++) o = t[n] - p + r, r = Math.floor(o / p), u[n] = o - r * p, r += 1;
    for (; r > 0;) u[n++] = r % p, r = Math.floor(r / p);
    return u
  }

  function d(t, e) {
    var r, o, n = t.length,
      i = e.length,
      u = new Array(n),
      p = 0;
    for (r = 0; r < i; r++)(o = t[r] - p - e[r]) < 0 ? (o += 1e7, p = 1) : p = 0, u[r] = o;
    for (r = i; r < n; r++) {
      if (!((o = t[r] - p) < 0)) {
        u[r++] = o;
        break
      }
      o += 1e7, u[r] = o
    }
    for (; r < n; r++) u[r] = t[r];
    return v(u), u
  }

  function b(t, e, r) {
    var o, n, i = t.length,
      a = new Array(i),
      s = -e;
    for (o = 0; o < i; o++) n = t[o] + s, s = Math.floor(n / 1e7), n %= 1e7, a[o] = n < 0 ? n + 1e7 : n;
    return "number" == typeof (a = f(a)) ? (r && (a = -a), new p(a)) : new u(a, r)
  }

  function w(t, e) {
    var r, o, n, i, u = t.length,
      p = e.length,
      a = h(u + p);
    for (n = 0; n < u; ++n) {
      i = t[n];
      for (var s = 0; s < p; ++s) r = i * e[s] + a[n + s], o = Math.floor(r / 1e7), a[n + s] = r - 1e7 * o, a[n + s + 1] += o
    }
    return v(a), a
  }

  function S(t, r) {
    var o, n, i = t.length,
      u = new Array(i),
      p = e,
      a = 0;
    for (n = 0; n < i; n++) o = t[n] * r + a, a = Math.floor(o / p), u[n] = o - a * p;
    for (; a > 0;) u[n++] = a % p, a = Math.floor(a / p);
    return u
  }

  function I(t, e) {
    for (var r = []; e--> 0;) r.push(0);
    return r.concat(t)
  }

  function q(t, r, o) {
    return new u(t < e ? S(r, t) : w(r, l(t)), o)
  }

  function M(t) {
    var e, r, o, n, i = t.length,
      u = h(i + i);
    for (o = 0; o < i; o++) {
      r = 0 - (n = t[o]) * n;
      for (var p = o; p < i; p++) e = n * t[p] * 2 + u[o + p] + r, r = Math.floor(e / 1e7), u[o + p] = e - 1e7 * r;
      u[o + i] = r
    }
    return v(u), u
  }

  function N(t, e) {
    var r, o, n, i, u = t.length,
      p = h(u);
    for (n = 0, r = u - 1; r >= 0; --r) n = (i = 1e7 * n + t[r]) - (o = y(i / e)) * e, p[r] = 0 | o;
    return [p, 0 | n]
  }

  function E(t, r) {
    var o, s = $(r);
    if (n) return [new a(t.value / s.value), new a(t.value % s.value)];
    var g, c = t.value,
      m = s.value;
    if (0 === m) throw new Error("Cannot divide by zero");
    if (t.isSmall) return s.isSmall ? [new p(y(c / m)), new p(c % m)] : [i[0], t];
    if (s.isSmall) {
      if (1 === m) return [t, i[0]];
      if (-1 == m) return [t.negate(), i[0]];
      var b = Math.abs(m);
      if (b < e) {
        g = f((o = N(c, b))[0]);
        var w = o[1];
        return t.sign && (w = -w), "number" == typeof g ? (t.sign !== s.sign && (g = -g), [new p(g), new p(w)]) : [new u(g, t.sign !== s.sign), new p(w)]
      }
      m = l(b)
    }
    var I = O(c, m);
    if (-1 === I) return [i[0], t];
    if (0 === I) return [i[t.sign === s.sign ? 1 : -1], i[0]];
    g = (o = c.length + m.length <= 200 ? function (t, r) {
      var o, n, i, u, p, a, s, l = t.length,
        v = r.length,
        y = e,
        g = h(r.length),
        c = r[v - 1],
        m = Math.ceil(y / (2 * c)),
        d = S(t, m),
        b = S(r, m);
      for (d.length <= l && d.push(0), b.push(0), c = b[v - 1], n = l - v; n >= 0; n--) {
        for (o = y - 1, d[n + v] !== c && (o = Math.floor((d[n + v] * y + d[n + v - 1]) / c)), i = 0, u = 0, a = b.length, p = 0; p < a; p++) i += o * b[p], s = Math.floor(i / y), u += d[n + p] - (i - s * y), i = s, u < 0 ? (d[n + p] = u + y, u = -1) : (d[n + p] = u, u = 0);
        for (; 0 !== u;) {
          for (o -= 1, i = 0, p = 0; p < a; p++)(i += d[n + p] - y + b[p]) < 0 ? (d[n + p] = i + y, i = 0) : (d[n + p] = i, i = 1);
          u += i
        }
        g[n] = o
      }
      return d = N(d, m)[0], [f(g), f(d)]
    }(c, m) : function (t, e) {
      for (var r, o, n, i, u, p = t.length, a = e.length, s = [], l = []; p;)
        if (l.unshift(t[--p]), v(l), O(l, e) < 0) s.push(0);
        else {
          n = 1e7 * l[(o = l.length) - 1] + l[o - 2], i = 1e7 * e[a - 1] + e[a - 2], o > a && (n = 1e7 * (n + 1)), r = Math.ceil(n / i);
          do {
            if (O(u = S(e, r), l) <= 0) break;
            r--
          } while (r);
          s.push(r), l = d(l, u)
        } return s.reverse(), [f(s), f(l)]
    }(c, m))[0];
    var q = t.sign !== s.sign,
      M = o[1],
      E = t.sign;
    return "number" == typeof g ? (q && (g = -g), g = new p(g)) : g = new u(g, q), "number" == typeof M ? (E && (M = -M), M = new p(M)) : M = new u(M, E), [g, M]
  }

  function O(t, e) {
    if (t.length !== e.length) return t.length > e.length ? 1 : -1;
    for (var r = t.length - 1; r >= 0; r--)
      if (t[r] !== e[r]) return t[r] > e[r] ? 1 : -1;
    return 0
  }

  function B(t) {
    var e = t.abs();
    return !e.isUnit() && (!!(e.equals(2) || e.equals(3) || e.equals(5)) || !(e.isEven() || e.isDivisibleBy(3) || e.isDivisibleBy(5)) && (!!e.lesser(49) || void 0))
  }

  function A(t, e) {
    for (var r, o, n, i = t.prev(), u = i, p = 0; u.isEven();) u = u.divide(2), p++;
    t: for (o = 0; o < e.length; o++)
      if (!t.lesser(e[o]) && !(n = bigInt(e[o]).modPow(u, t)).isUnit() && !n.equals(i)) {
        for (r = p - 1; 0 != r; r--) {
          if ((n = n.square().mod(t)).isUnit()) return !1;
          if (n.equals(i)) continue t
        }
        return !1
      }
    return !0
  }
  u.prototype = Object.create(i.prototype), p.prototype = Object.create(i.prototype), a.prototype = Object.create(i.prototype), u.prototype.add = function (t) {
    var e = $(t);
    if (this.sign !== e.sign) return this.subtract(e.negate());
    var r = this.value,
      o = e.value;
    return e.isSmall ? new u(m(r, Math.abs(o)), this.sign) : new u(c(r, o), this.sign)
  }, u.prototype.plus = u.prototype.add, p.prototype.add = function (t) {
    var e = $(t),
      r = this.value;
    if (r < 0 !== e.sign) return this.subtract(e.negate());
    var o = e.value;
    if (e.isSmall) {
      if (s(r + o)) return new p(r + o);
      o = l(Math.abs(o))
    }
    return new u(m(o, Math.abs(r)), r < 0)
  }, p.prototype.plus = p.prototype.add, a.prototype.add = function (t) {
    return new a(this.value + $(t).value)
  }, a.prototype.plus = a.prototype.add, u.prototype.subtract = function (t) {
    var e = $(t);
    if (this.sign !== e.sign) return this.add(e.negate());
    var r = this.value,
      o = e.value;
    return e.isSmall ? b(r, Math.abs(o), this.sign) : function (t, e, r) {
      var o;
      return O(t, e) >= 0 ? o = d(t, e) : (o = d(e, t), r = !r), "number" == typeof (o = f(o)) ? (r && (o = -o), new p(o)) : new u(o, r)
    }(r, o, this.sign)
  }, u.prototype.minus = u.prototype.subtract, p.prototype.subtract = function (t) {
    var e = $(t),
      r = this.value;
    if (r < 0 !== e.sign) return this.add(e.negate());
    var o = e.value;
    return e.isSmall ? new p(r - o) : b(o, Math.abs(r), r >= 0)
  }, p.prototype.minus = p.prototype.subtract, a.prototype.subtract = function (t) {
    return new a(this.value - $(t).value)
  }, a.prototype.minus = a.prototype.subtract, u.prototype.negate = function () {
    return new u(this.value, !this.sign)
  }, p.prototype.negate = function () {
    var t = this.sign,
      e = new p(-this.value);
    return e.sign = !t, e
  }, a.prototype.negate = function () {
    return new a(-this.value)
  }, u.prototype.abs = function () {
    return new u(this.value, !1)
  }, p.prototype.abs = function () {
    return new p(Math.abs(this.value))
  }, a.prototype.abs = function () {
    return new a(this.value >= 0 ? this.value : -this.value)
  }, u.prototype.multiply = function (t) {
    var r, o, n, p = $(t),
      a = this.value,
      s = p.value,
      f = this.sign !== p.sign;
    if (p.isSmall) {
      if (0 === s) return i[0];
      if (1 === s) return this;
      if (-1 === s) return this.negate();
      if ((r = Math.abs(s)) < e) return new u(S(a, r), f);
      s = l(r)
    }
    return o = a.length, n = s.length, new u(-.012 * o - .012 * n + 15e-6 * o * n > 0 ? function t(e, r) {
      var o = Math.max(e.length, r.length);
      if (o <= 30) return w(e, r);
      o = Math.ceil(o / 2);
      var n = e.slice(o),
        i = e.slice(0, o),
        u = r.slice(o),
        p = r.slice(0, o),
        a = t(i, p),
        s = t(n, u),
        l = t(c(i, n), c(p, u)),
        f = c(c(a, I(d(d(l, a), s), o)), I(s, 2 * o));
      return v(f), f
    }(a, s) : w(a, s), f)
  }, u.prototype.times = u.prototype.multiply, p.prototype._multiplyBySmall = function (t) {
    return s(t.value * this.value) ? new p(t.value * this.value) : q(Math.abs(t.value), l(Math.abs(this.value)), this.sign !== t.sign)
  }, u.prototype._multiplyBySmall = function (t) {
    return 0 === t.value ? i[0] : 1 === t.value ? this : -1 === t.value ? this.negate() : q(Math.abs(t.value), this.value, this.sign !== t.sign)
  }, p.prototype.multiply = function (t) {
    return $(t)._multiplyBySmall(this)
  }, p.prototype.times = p.prototype.multiply, a.prototype.multiply = function (t) {
    return new a(this.value * $(t).value)
  }, a.prototype.times = a.prototype.multiply, u.prototype.square = function () {
    return new u(M(this.value), !1)
  }, p.prototype.square = function () {
    var t = this.value * this.value;
    return s(t) ? new p(t) : new u(M(l(Math.abs(this.value))), !1)
  }, a.prototype.square = function (t) {
    return new a(this.value * this.value)
  }, u.prototype.divmod = function (t) {
    var e = E(this, t);
    return {
      quotient: e[0],
      remainder: e[1]
    }
  }, a.prototype.divmod = p.prototype.divmod = u.prototype.divmod, u.prototype.divide = function (t) {
    return E(this, t)[0]
  }, a.prototype.over = a.prototype.divide = function (t) {
    return new a(this.value / $(t).value)
  }, p.prototype.over = p.prototype.divide = u.prototype.over = u.prototype.divide, u.prototype.mod = function (t) {
    return E(this, t)[1]
  }, a.prototype.mod = a.prototype.remainder = function (t) {
    return new a(this.value % $(t).value)
  }, p.prototype.remainder = p.prototype.mod = u.prototype.remainder = u.prototype.mod, u.prototype.pow = function (t) {
    var e, r, o, n = $(t),
      u = this.value,
      a = n.value;
    if (0 === a) return i[1];
    if (0 === u) return i[0];
    if (1 === u) return i[1];
    if (-1 === u) return n.isEven() ? i[1] : i[-1];
    if (n.sign) return i[0];
    if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
    if (this.isSmall && s(e = Math.pow(u, a))) return new p(y(e));
    for (r = this, o = i[1]; !0 & a && (o = o.times(r), --a), 0 !== a;) a /= 2, r = r.square();
    return o
  }, p.prototype.pow = u.prototype.pow, a.prototype.pow = function (t) {
    var e = $(t),
      r = this.value,
      o = e.value,
      n = BigInt(0),
      u = BigInt(1),
      p = BigInt(2);
    if (o === n) return i[1];
    if (r === n) return i[0];
    if (r === u) return i[1];
    if (r === BigInt(-1)) return e.isEven() ? i[1] : i[-1];
    if (e.isNegative()) return new a(n);
    for (var s = this, l = i[1];
      (o & u) === u && (l = l.times(s), --o), o !== n;) o /= p, s = s.square();
    return l
  }, u.prototype.modPow = function (t, e) {
    if (t = $(t), (e = $(e)).isZero()) throw new Error("Cannot take modPow with modulus 0");
    var r = i[1],
      o = this.mod(e);
    for (t.isNegative() && (t = t.multiply(i[-1]), o = o.modInv(e)); t.isPositive();) {
      if (o.isZero()) return i[0];
      t.isOdd() && (r = r.multiply(o).mod(e)), t = t.divide(2), o = o.square().mod(e)
    }
    return r
  }, a.prototype.modPow = p.prototype.modPow = u.prototype.modPow, u.prototype.compareAbs = function (t) {
    var e = $(t),
      r = this.value,
      o = e.value;
    return e.isSmall ? 1 : O(r, o)
  }, p.prototype.compareAbs = function (t) {
    var e = $(t),
      r = Math.abs(this.value),
      o = e.value;
    return e.isSmall ? r === (o = Math.abs(o)) ? 0 : r > o ? 1 : -1 : -1
  }, a.prototype.compareAbs = function (t) {
    var e = this.value,
      r = $(t).value;
    return (e = e >= 0 ? e : -e) === (r = r >= 0 ? r : -r) ? 0 : e > r ? 1 : -1
  }, u.prototype.compare = function (t) {
    if (t === 1 / 0) return -1;
    if (t === -1 / 0) return 1;
    var e = $(t),
      r = this.value,
      o = e.value;
    return this.sign !== e.sign ? e.sign ? 1 : -1 : e.isSmall ? this.sign ? -1 : 1 : O(r, o) * (this.sign ? -1 : 1)
  }, u.prototype.compareTo = u.prototype.compare, p.prototype.compare = function (t) {
    if (t === 1 / 0) return -1;
    if (t === -1 / 0) return 1;
    var e = $(t),
      r = this.value,
      o = e.value;
    return e.isSmall ? r == o ? 0 : r > o ? 1 : -1 : r < 0 !== e.sign ? r < 0 ? -1 : 1 : r < 0 ? 1 : -1
  }, p.prototype.compareTo = p.prototype.compare, a.prototype.compare = function (t) {
    if (t === 1 / 0) return -1;
    if (t === -1 / 0) return 1;
    var e = this.value,
      r = $(t).value;
    return e === r ? 0 : e > r ? 1 : -1
  }, a.prototype.compareTo = a.prototype.compare, u.prototype.equals = function (t) {
    return 0 === this.compare(t)
  }, a.prototype.eq = a.prototype.equals = p.prototype.eq = p.prototype.equals = u.prototype.eq = u.prototype.equals, u.prototype.notEquals = function (t) {
    return 0 !== this.compare(t)
  }, a.prototype.neq = a.prototype.notEquals = p.prototype.neq = p.prototype.notEquals = u.prototype.neq = u.prototype.notEquals, u.prototype.greater = function (t) {
    return this.compare(t) > 0
  }, a.prototype.gt = a.prototype.greater = p.prototype.gt = p.prototype.greater = u.prototype.gt = u.prototype.greater, u.prototype.lesser = function (t) {
    return this.compare(t) < 0
  }, a.prototype.lt = a.prototype.lesser = p.prototype.lt = p.prototype.lesser = u.prototype.lt = u.prototype.lesser, u.prototype.greaterOrEquals = function (t) {
    return this.compare(t) >= 0
  }, a.prototype.geq = a.prototype.greaterOrEquals = p.prototype.geq = p.prototype.greaterOrEquals = u.prototype.geq = u.prototype.greaterOrEquals, u.prototype.lesserOrEquals = function (t) {
    return this.compare(t) <= 0
  }, a.prototype.leq = a.prototype.lesserOrEquals = p.prototype.leq = p.prototype.lesserOrEquals = u.prototype.leq = u.prototype.lesserOrEquals, u.prototype.isEven = function () {
    return 0 == (1 & this.value[0])
  }, p.prototype.isEven = function () {
    return 0 == (1 & this.value)
  }, a.prototype.isEven = function () {
    return (this.value & BigInt(1)) === BigInt(0)
  }, u.prototype.isOdd = function () {
    return 1 == (1 & this.value[0])
  }, p.prototype.isOdd = function () {
    return 1 == (1 & this.value)
  }, a.prototype.isOdd = function () {
    return (this.value & BigInt(1)) === BigInt(1)
  }, u.prototype.isPositive = function () {
    return !this.sign
  }, p.prototype.isPositive = function () {
    return this.value > 0
  }, a.prototype.isPositive = p.prototype.isPositive, u.prototype.isNegative = function () {
    return this.sign
  }, p.prototype.isNegative = function () {
    return this.value < 0
  }, a.prototype.isNegative = p.prototype.isNegative, u.prototype.isUnit = function () {
    return !1
  }, p.prototype.isUnit = function () {
    return 1 === Math.abs(this.value)
  }, a.prototype.isUnit = function () {
    return this.abs().value === BigInt(1)
  }, u.prototype.isZero = function () {
    return !1
  }, p.prototype.isZero = function () {
    return 0 === this.value
  }, a.prototype.isZero = function () {
    return this.value === BigInt(0)
  }, u.prototype.isDivisibleBy = function (t) {
    var e = $(t);
    return !e.isZero() && (!!e.isUnit() || (0 === e.compareAbs(2) ? this.isEven() : this.mod(e).isZero()))
  }, a.prototype.isDivisibleBy = p.prototype.isDivisibleBy = u.prototype.isDivisibleBy, u.prototype.isPrime = function (t) {
    var e = B(this);
    if (void 0 !== e) return e;
    var r = this.abs(),
      o = r.bitLength();
    if (o <= 64) return A(r, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
    for (var n = Math.log(2) * o.toJSNumber(), i = Math.ceil(!0 === t ? 2 * Math.pow(n, 2) : n), u = [], p = 0; p < i; p++) u.push(bigInt(p + 2));
    return A(r, u)
  }, a.prototype.isPrime = p.prototype.isPrime = u.prototype.isPrime, u.prototype.isProbablePrime = function (t, e) {
    var r = B(this);
    if (void 0 !== r) return r;
    for (var o = this.abs(), n = void 0 === t ? 5 : t, i = [], u = 0; u < n; u++) i.push(bigInt.randBetween(2, o.minus(2), e));
    return A(o, i)
  }, a.prototype.isProbablePrime = p.prototype.isProbablePrime = u.prototype.isProbablePrime, u.prototype.modInv = function (t) {
    for (var e, r, o, n = bigInt.zero, i = bigInt.one, u = $(t), p = this.abs(); !p.isZero();) e = u.divide(p), r = n, o = u, n = i, u = p, i = r.subtract(e.multiply(i)), p = o.subtract(e.multiply(p));
    if (!u.isUnit()) throw new Error(this.toString() + " and " + t.toString() + " are not co-prime");
    return -1 === n.compare(0) && (n = n.add(t)), this.isNegative() ? n.negate() : n
  }, a.prototype.modInv = p.prototype.modInv = u.prototype.modInv, u.prototype.next = function () {
    var t = this.value;
    return this.sign ? b(t, 1, this.sign) : new u(m(t, 1), this.sign)
  }, p.prototype.next = function () {
    var t = this.value;
    return t + 1 < r ? new p(t + 1) : new u(o, !1)
  }, a.prototype.next = function () {
    return new a(this.value + BigInt(1))
  }, u.prototype.prev = function () {
    var t = this.value;
    return this.sign ? new u(m(t, 1), !0) : b(t, 1, this.sign)
  }, p.prototype.prev = function () {
    var t = this.value;
    return t - 1 > -r ? new p(t - 1) : new u(o, !0)
  }, a.prototype.prev = function () {
    return new a(this.value - BigInt(1))
  };
  for (var P = [1]; 2 * P[P.length - 1] <= e;) P.push(2 * P[P.length - 1]);
  var Z = P.length,
    x = P[Z - 1];

  function J(t) {
    return Math.abs(t) <= e
  }

  function L(t, e, r) {
    e = $(e);
    for (var o = t.isNegative(), n = e.isNegative(), i = o ? t.not() : t, u = n ? e.not() : e, p = 0, a = 0, s = null, l = null, f = []; !i.isZero() || !u.isZero();) p = (s = E(i, x))[1].toJSNumber(), o && (p = x - 1 - p), a = (l = E(u, x))[1].toJSNumber(), n && (a = x - 1 - a), i = s[0], u = l[0], f.push(r(p, a));
    for (var v = 0 !== r(o ? 1 : 0, n ? 1 : 0) ? bigInt(-1) : bigInt(0), h = f.length - 1; h >= 0; h -= 1) v = v.multiply(x).add(bigInt(f[h]));
    return v
  }
  u.prototype.shiftLeft = function (t) {
    var e = $(t).toJSNumber();
    if (!J(e)) throw new Error(String(e) + " is too large for shifting.");
    if (e < 0) return this.shiftRight(-e);
    var r = this;
    if (r.isZero()) return r;
    for (; e >= Z;) r = r.multiply(x), e -= Z - 1;
    return r.multiply(P[e])
  }, a.prototype.shiftLeft = p.prototype.shiftLeft = u.prototype.shiftLeft, u.prototype.shiftRight = function (t) {
    var e, r = $(t).toJSNumber();
    if (!J(r)) throw new Error(String(r) + " is too large for shifting.");
    if (r < 0) return this.shiftLeft(-r);
    for (var o = this; r >= Z;) {
      if (o.isZero() || o.isNegative() && o.isUnit()) return o;
      o = (e = E(o, x))[1].isNegative() ? e[0].prev() : e[0], r -= Z - 1
    }
    return (e = E(o, P[r]))[1].isNegative() ? e[0].prev() : e[0]
  }, a.prototype.shiftRight = p.prototype.shiftRight = u.prototype.shiftRight, u.prototype.not = function () {
    return this.negate().prev()
  }, a.prototype.not = p.prototype.not = u.prototype.not, u.prototype.and = function (t) {
    return L(this, t, (function (t, e) {
      return t & e
    }))
  }, a.prototype.and = p.prototype.and = u.prototype.and, u.prototype.or = function (t) {
    return L(this, t, (function (t, e) {
      return t | e
    }))
  }, a.prototype.or = p.prototype.or = u.prototype.or, u.prototype.xor = function (t) {
    return L(this, t, (function (t, e) {
      return t ^ e
    }))
  }, a.prototype.xor = p.prototype.xor = u.prototype.xor;

  function U(t) {
    var r = t.value,
      o = "number" == typeof r ? r | 1 << 30 : "bigint" == typeof r ? r | BigInt(1 << 30) : r[0] + r[1] * e | 1073758208;
    return o & -o
  }

  function j(t, e) {
    return t = $(t), e = $(e), t.greater(e) ? t : e
  }

  function T(t, e) {
    return t = $(t), e = $(e), t.lesser(e) ? t : e
  }

  function z(t, e) {
    if (t = $(t).abs(), e = $(e).abs(), t.equals(e)) return t;
    if (t.isZero()) return e;
    if (e.isZero()) return t;
    for (var r, o, n = i[1]; t.isEven() && e.isEven();) r = T(U(t), U(e)), t = t.divide(r), e = e.divide(r), n = n.multiply(r);
    for (; t.isEven();) t = t.divide(U(t));
    do {
      for (; e.isEven();) e = e.divide(U(e));
      t.greater(e) && (o = e, e = t, t = o), e = e.subtract(t)
    } while (!e.isZero());
    return n.isUnit() ? t : t.multiply(n)
  }
  u.prototype.bitLength = function () {
    var t = this;
    return t.compareTo(bigInt(0)) < 0 && (t = t.negate().subtract(bigInt(1))), 0 === t.compareTo(bigInt(0)) ? bigInt(0) : bigInt(function t(e, r) {
      if (r.compareTo(e) <= 0) {
        var o = t(e, r.square(r)),
          n = o.p,
          i = o.e,
          u = n.multiply(r);
        return u.compareTo(e) <= 0 ? {
          p: u,
          e: 2 * i + 1
        } : {
          p: n,
          e: 2 * i
        }
      }
      return {
        p: bigInt(1),
        e: 0
      }
    }(t, bigInt(2)).e).add(bigInt(1))
  }, a.prototype.bitLength = p.prototype.bitLength = u.prototype.bitLength;
  var C = function (t, e, r, o) {
    r = r || "0123456789abcdefghijklmnopqrstuvwxyz", t = String(t), o || (t = t.toLowerCase(), r = r.toLowerCase());
    var n, i = t.length,
      u = Math.abs(e),
      p = {};
    for (n = 0; n < r.length; n++) p[r[n]] = n;
    for (n = 0; n < i; n++) {
      if ("-" !== (l = t[n]) && (l in p && p[l] >= u)) {
        if ("1" === l && 1 === u) continue;
        throw new Error(l + " is not a valid digit in base " + e + ".")
      }
    }
    e = $(e);
    var a = [],
      s = "-" === t[0];
    for (n = s ? 1 : 0; n < t.length; n++) {
      var l;
      if ((l = t[n]) in p) a.push($(p[l]));
      else {
        if ("<" !== l) throw new Error(l + " is not a valid character");
        var f = n;
        do {
          n++
        } while (">" !== t[n] && n < t.length);
        a.push($(t.slice(f + 1, n)))
      }
    }
    return D(a, e, s)
  };

  function D(t, e, r) {
    var o, n = i[0],
      u = i[1];
    for (o = t.length - 1; o >= 0; o--) n = n.add(t[o].times(u)), u = u.times(e);
    return r ? n.negate() : n
  }

  function k(t, e) {
    if ((e = bigInt(e)).isZero()) {
      if (t.isZero()) return {
        value: [0],
        isNegative: !1
      };
      throw new Error("Cannot convert nonzero numbers to base 0.")
    }
    if (e.equals(-1)) {
      if (t.isZero()) return {
        value: [0],
        isNegative: !1
      };
      if (t.isNegative()) return {
        value: [].concat.apply([], Array.apply(null, Array(-t.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
        isNegative: !1
      };
      var r = Array.apply(null, Array(t.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
      return r.unshift([1]), {
        value: [].concat.apply([], r),
        isNegative: !1
      }
    }
    var o = !1;
    if (t.isNegative() && e.isPositive() && (o = !0, t = t.abs()), e.isUnit()) return t.isZero() ? {
      value: [0],
      isNegative: !1
    } : {
      value: Array.apply(null, Array(t.toJSNumber())).map(Number.prototype.valueOf, 1),
      isNegative: o
    };
    for (var n, i = [], u = t; u.isNegative() || u.compareAbs(e) >= 0;) {
      n = u.divmod(e), u = n.quotient;
      var p = n.remainder;
      p.isNegative() && (p = e.minus(p).abs(), u = u.next()), i.push(p.toJSNumber())
    }
    return i.push(u.toJSNumber()), {
      value: i.reverse(),
      isNegative: o
    }
  }

  function R(t, e, r) {
    var o = k(t, e);
    return (o.isNegative ? "-" : "") + o.value.map((function (t) {
      return function (t, e) {
        return t < (e = e || "0123456789abcdefghijklmnopqrstuvwxyz").length ? e[t] : "<" + t + ">"
      }(t, r)
    })).join("")
  }

  function _(t) {
    if (s(+t)) {
      var e = +t;
      if (e === y(e)) return n ? new a(BigInt(e)) : new p(e);
      throw new Error("Invalid integer: " + t)
    }
    var r = "-" === t[0];
    r && (t = t.slice(1));
    var o = t.split(/e/i);
    if (o.length > 2) throw new Error("Invalid integer: " + o.join("e"));
    if (2 === o.length) {
      var i = o[1];
      if ("+" === i[0] && (i = i.slice(1)), (i = +i) !== y(i) || !s(i)) throw new Error("Invalid integer: " + i + " is not a valid exponent.");
      var l = o[0],
        f = l.indexOf(".");
      if (f >= 0 && (i -= l.length - f - 1, l = l.slice(0, f) + l.slice(f + 1)), i < 0) throw new Error("Cannot include negative exponent part for integers");
      t = l += new Array(i + 1).join("0")
    }
    if (!/^([0-9][0-9]*)$/.test(t)) throw new Error("Invalid integer: " + t);
    if (n) return new a(BigInt(r ? "-" + t : t));
    for (var h = [], g = t.length, c = g - 7; g > 0;) h.push(+t.slice(c, g)), (c -= 7) < 0 && (c = 0), g -= 7;
    return v(h), new u(h, r)
  }

  function $(t) {
    return "number" == typeof t ? function (t) {
      if (n) return new a(BigInt(t));
      if (s(t)) {
        if (t !== y(t)) throw new Error(t + " is not an integer.");
        return new p(t)
      }
      return _(t.toString())
    }(t) : "string" == typeof t ? _(t) : "bigint" == typeof t ? new a(t) : t
  }
  u.prototype.toArray = function (t) {
    return k(this, t)
  }, p.prototype.toArray = function (t) {
    return k(this, t)
  }, a.prototype.toArray = function (t) {
    return k(this, t)
  }, u.prototype.toString = function (t, e) {
    if (void 0 === t && (t = 10), 10 !== t) return R(this, t, e);
    for (var r, o = this.value, n = o.length, i = String(o[--n]); --n >= 0;) r = String(o[n]), i += "0000000".slice(r.length) + r;
    return (this.sign ? "-" : "") + i
  }, p.prototype.toString = function (t, e) {
    return void 0 === t && (t = 10), 10 != t ? R(this, t, e) : String(this.value)
  }, a.prototype.toString = p.prototype.toString, a.prototype.toJSON = u.prototype.toJSON = p.prototype.toJSON = function () {
    return this.toString()
  }, u.prototype.valueOf = function () {
    return parseInt(this.toString(), 10)
  }, u.prototype.toJSNumber = u.prototype.valueOf, p.prototype.valueOf = function () {
    return this.value
  }, p.prototype.toJSNumber = p.prototype.valueOf, a.prototype.valueOf = a.prototype.toJSNumber = function () {
    return parseInt(this.toString(), 10)
  };
  for (var F = 0; F < 1e3; F++) i[F] = $(F), F > 0 && (i[-F] = $(-F));
  return i.one = i[1], i.zero = i[0], i.minusOne = i[-1], i.max = j, i.min = T, i.gcd = z, i.lcm = function (t, e) {
    return t = $(t).abs(), e = $(e).abs(), t.divide(z(t, e)).multiply(e)
  }, i.isInstance = function (t) {
    return t instanceof u || t instanceof p || t instanceof a
  }, i.randBetween = function (t, r, o) {
    t = $(t), r = $(r);
    var n = o || Math.random,
      u = T(t, r),
      p = j(t, r).subtract(u).add(1);
    if (p.isSmall) return u.add(Math.floor(n() * p));
    for (var a = k(p, e).value, s = [], l = !0, f = 0; f < a.length; f++) {
      var v = l ? a[f] : e,
        h = y(n() * v);
      s.push(h), h < v && (l = !1)
    }
    return u.add(i.fromArray(s, e, !1))
  }, i.fromArray = function (t, e, r) {
    return D(t.map($), $(e || 10), r)
  }, i
}();
"undefined" != typeof module && module.hasOwnProperty("exports") && (module.exports = bigInt), "function" == typeof define && define.amd && define((function () {
  return bigInt
}));
class Crunker {
  constructor({
    sampleRate: t = 44100
  } = {}) {
    this._sampleRate = t, this._context = this._createContext()
  }
  _createContext() {
    return window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext, new AudioContext
  }
  concatAudio(t) {
    let e = this._context.createBuffer(1, this._totalLength(t), this._sampleRate),
      n = 0;
    return t.map(t => {
      e.getChannelData(0).set(t.getChannelData(0), n), n += t.length
    }), e
  }
  play(t) {
    const e = this._context.createBufferSource();
    return e.buffer = t, e.connect(this._context.destination), e.start(), e
  }
  export (t, e) {
    const n = e || "audio/mp3",
      r = this._interleave(t),
      i = this._writeHeaders(r),
      o = new Blob([i], {
        type: n
      });
    return {
      blob: o,
      url: this._renderURL(o),
      element: this._renderAudioElement(o, n)
    }
  }
  close() {
    return this._context.close(), this
  }
  _totalLength(t) {
    return t.map(t => t.length).reduce((t, e) => t + e, 0)
  }
  _writeHeaders(t) {
    let e = new ArrayBuffer(44 + 2 * t.length),
      n = new DataView(e);
    return this._writeString(n, 0, "RIFF"), n.setUint32(4, 32 + 2 * t.length, !0), this._writeString(n, 8, "WAVE"), this._writeString(n, 12, "fmt "), n.setUint32(16, 16, !0), n.setUint16(20, 1, !0), n.setUint16(22, 2, !0), n.setUint32(24, this._sampleRate, !0), n.setUint32(28, 4 * this._sampleRate, !0), n.setUint16(32, 4, !0), n.setUint16(34, 16, !0), this._writeString(n, 36, "data"), n.setUint32(40, 2 * t.length, !0), this._floatTo16BitPCM(n, t, 44)
  }
  _floatTo16BitPCM(t, e, n) {
    for (var r = 0; r < e.length; r++, n += 2) {
      let i = Math.max(-1, Math.min(1, e[r]));
      t.setInt16(n, i < 0 ? 32768 * i : 32767 * i, !0)
    }
    return t
  }
  _writeString(t, e, n) {
    for (var r = 0; r < n.length; r++) t.setUint8(e + r, n.charCodeAt(r))
  }
  _interleave(t) {
    let e = t.getChannelData(0),
      n = 2 * e.length,
      r = new Float32Array(n),
      i = 0,
      o = 0;
    for (; i < n;) r[i++] = e[o], r[i++] = e[o], o++;
    return r
  }
  _renderAudioElement(t, e) {
    const n = document.createElement("audio");
    return n.controls = "controls", n.type = e, n.src = this._renderURL(t), n
  }
  _renderURL(t) {
    return (window.URL || window.webkitURL).createObjectURL(t)
  }
}
class DownloadManager {
  static initialize() {
    this.itemMap = new Map, this.tabIdWithItemId = new Map, this.contentTabIdWithItemId = new Map
  }
  static setItem(t) {
    return t.id = Helper.getUniqueId(), this.itemMap.set(t.id, t), this.tabIdWithItemId.set(t.tabId, t.id), this.contentTabIdWithItemId.set(t.content.tabId, t.id), t.id
  }
  static getItem(t) {
    let e = this.itemMap.get(t);
    return e || null
  }
  static getItemWithContentTabId(t) {
    let e = this.contentTabIdWithItemId.get(t);
    return e ? this.getItem(e) : null
  }
  static getItemWithTabId(t) {
    let e = this.tabIdWithItemId.get(t);
    return e ? this.getItem(e) : null
  }
}
DownloadManager.initialize();
class HeaderManager {
  static initialize() {
    this.headerMap = new Map, this.urlToRequestIdMap = new Map, this.requestIdToUrlMap = new Map, setInterval((function () {
      HeaderManager.headerMap.forEach((function (e) {
        let t = Variables.getNonVerifyHeaderItemMaxLifeSecond();
        e.isVerify && (t = Variables.getVerifyHeaderItemMaxLifeSecond()), e.createdAt + t < Helper.getNowDateSecond() && HeaderManager.deleteHeaderWithId(e.id)
      }))
    }), 6e4)
  }
  static setHeader(e) {
    this.headerMap.set(e.id, e), this.urlToRequestIdMap.set(e.url, e.id), this.requestIdToUrlMap.set(e.id, e.url)
  }
  static getHeaderWithId(e) {
    let t = this.headerMap.get(e);
    return t || null
  }
  static getHeaderWithUrl(e) {
    let t = this.urlToRequestIdMap.get(e);
    if (!t) return null;
    let a = this.headerMap.get(t);
    return a || null
  }
  static deleteHeaderWithId(e) {
    let t = this.requestIdToUrlMap.get(e);
    return t ? (this.headerMap.delete(e), this.urlToRequestIdMap.delete(t), this.requestIdToUrlMap.delete(e), !0) : null
  }
}
HeaderManager.initialize();
"undefined" != typeof window && function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.Hls = t() : e.Hls = t()
}(this, (function () {
  return function (e) {
    var t = {};

    function r(i) {
      if (t[i]) return t[i].exports;
      var a = t[i] = {
        i: i,
        l: !1,
        exports: {}
      };
      return e[i].call(a.exports, a, a.exports, r), a.l = !0, a.exports
    }
    return r.m = e, r.c = t, r.d = function (e, t, i) {
      r.o(e, t) || Object.defineProperty(e, t, {
        enumerable: !0,
        get: i
      })
    }, r.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(e, "__esModule", {
        value: !0
      })
    }, r.t = function (e, t) {
      if (1 & t && (e = r(e)), 8 & t) return e;
      if (4 & t && "object" == typeof e && e && e.__esModule) return e;
      var i = Object.create(null);
      if (r.r(i), Object.defineProperty(i, "default", {
          enumerable: !0,
          value: e
        }), 2 & t && "string" != typeof e)
        for (var a in e) r.d(i, a, function (t) {
          return e[t]
        }.bind(null, a));
      return i
    }, r.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default
      } : function () {
        return e
      };
      return r.d(t, "a", t), t
    }, r.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t)
    }, r.p = "/dist/", r(r.s = "./src/hls.ts")
  }({
    "./node_modules/eventemitter3/index.js": function (e, t, r) {
      "use strict";
      var i = Object.prototype.hasOwnProperty,
        a = "~";

      function n() {}

      function s(e, t, r) {
        this.fn = e, this.context = t, this.once = r || !1
      }

      function o(e, t, r, i, n) {
        if ("function" != typeof r) throw new TypeError("The listener must be a function");
        var o = new s(r, i || e, n),
          l = a ? a + t : t;
        return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], o] : e._events[l].push(o) : (e._events[l] = o, e._eventsCount++), e
      }

      function l(e, t) {
        0 == --e._eventsCount ? e._events = new n : delete e._events[t]
      }

      function d() {
        this._events = new n, this._eventsCount = 0
      }
      Object.create && (n.prototype = Object.create(null), (new n).__proto__ || (a = !1)), d.prototype.eventNames = function () {
        var e, t, r = [];
        if (0 === this._eventsCount) return r;
        for (t in e = this._events) i.call(e, t) && r.push(a ? t.slice(1) : t);
        return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r
      }, d.prototype.listeners = function (e) {
        var t = a ? a + e : e,
          r = this._events[t];
        if (!r) return [];
        if (r.fn) return [r.fn];
        for (var i = 0, n = r.length, s = new Array(n); i < n; i++) s[i] = r[i].fn;
        return s
      }, d.prototype.listenerCount = function (e) {
        var t = a ? a + e : e,
          r = this._events[t];
        return r ? r.fn ? 1 : r.length : 0
      }, d.prototype.emit = function (e, t, r, i, n, s) {
        var o = a ? a + e : e;
        if (!this._events[o]) return !1;
        var l, d, u = this._events[o],
          f = arguments.length;
        if (u.fn) {
          switch (u.once && this.removeListener(e, u.fn, void 0, !0), f) {
          case 1:
            return u.fn.call(u.context), !0;
          case 2:
            return u.fn.call(u.context, t), !0;
          case 3:
            return u.fn.call(u.context, t, r), !0;
          case 4:
            return u.fn.call(u.context, t, r, i), !0;
          case 5:
            return u.fn.call(u.context, t, r, i, n), !0;
          case 6:
            return u.fn.call(u.context, t, r, i, n, s), !0
          }
          for (d = 1, l = new Array(f - 1); d < f; d++) l[d - 1] = arguments[d];
          u.fn.apply(u.context, l)
        } else {
          var c, h = u.length;
          for (d = 0; d < h; d++) switch (u[d].once && this.removeListener(e, u[d].fn, void 0, !0), f) {
          case 1:
            u[d].fn.call(u[d].context);
            break;
          case 2:
            u[d].fn.call(u[d].context, t);
            break;
          case 3:
            u[d].fn.call(u[d].context, t, r);
            break;
          case 4:
            u[d].fn.call(u[d].context, t, r, i);
            break;
          default:
            if (!l)
              for (c = 1, l = new Array(f - 1); c < f; c++) l[c - 1] = arguments[c];
            u[d].fn.apply(u[d].context, l)
          }
        }
        return !0
      }, d.prototype.on = function (e, t, r) {
        return o(this, e, t, r, !1)
      }, d.prototype.once = function (e, t, r) {
        return o(this, e, t, r, !0)
      }, d.prototype.removeListener = function (e, t, r, i) {
        var n = a ? a + e : e;
        if (!this._events[n]) return this;
        if (!t) return l(this, n), this;
        var s = this._events[n];
        if (s.fn) s.fn !== t || i && !s.once || r && s.context !== r || l(this, n);
        else {
          for (var o = 0, d = [], u = s.length; o < u; o++)(s[o].fn !== t || i && !s[o].once || r && s[o].context !== r) && d.push(s[o]);
          d.length ? this._events[n] = 1 === d.length ? d[0] : d : l(this, n)
        }
        return this
      }, d.prototype.removeAllListeners = function (e) {
        var t;
        return e ? (t = a ? a + e : e, this._events[t] && l(this, t)) : (this._events = new n, this._eventsCount = 0), this
      }, d.prototype.off = d.prototype.removeListener, d.prototype.addListener = d.prototype.on, d.prefixed = a, d.EventEmitter = d, e.exports = d
    },
    "./node_modules/url-toolkit/src/url-toolkit.js": function (e, t, r) {
      var i, a, n, s, o;
      i = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#.*)?$/, a = /^([^\/?#]*)(.*)$/, n = /(?:\/|^)\.(?=\/)/g, s = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = {
        buildAbsoluteURL: function (e, t, r) {
          if (r = r || {}, e = e.trim(), !(t = t.trim())) {
            if (!r.alwaysNormalize) return e;
            var i = o.parseURL(e);
            if (!i) throw new Error("Error trying to parse base URL.");
            return i.path = o.normalizePath(i.path), o.buildURLFromParts(i)
          }
          var n = o.parseURL(t);
          if (!n) throw new Error("Error trying to parse relative URL.");
          if (n.scheme) return r.alwaysNormalize ? (n.path = o.normalizePath(n.path), o.buildURLFromParts(n)) : t;
          var s = o.parseURL(e);
          if (!s) throw new Error("Error trying to parse base URL.");
          if (!s.netLoc && s.path && "/" !== s.path[0]) {
            var l = a.exec(s.path);
            s.netLoc = l[1], s.path = l[2]
          }
          s.netLoc && !s.path && (s.path = "/");
          var d = {
            scheme: s.scheme,
            netLoc: n.netLoc,
            path: null,
            params: n.params,
            query: n.query,
            fragment: n.fragment
          };
          if (!n.netLoc && (d.netLoc = s.netLoc, "/" !== n.path[0]))
            if (n.path) {
              var u = s.path,
                f = u.substring(0, u.lastIndexOf("/") + 1) + n.path;
              d.path = o.normalizePath(f)
            } else d.path = s.path, n.params || (d.params = s.params, n.query || (d.query = s.query));
          return null === d.path && (d.path = r.alwaysNormalize ? o.normalizePath(n.path) : n.path), o.buildURLFromParts(d)
        },
        parseURL: function (e) {
          var t = i.exec(e);
          return t ? {
            scheme: t[1] || "",
            netLoc: t[2] || "",
            path: t[3] || "",
            params: t[4] || "",
            query: t[5] || "",
            fragment: t[6] || ""
          } : null
        },
        normalizePath: function (e) {
          for (e = e.split("").reverse().join("").replace(n, ""); e.length !== (e = e.replace(s, "")).length;);
          return e.split("").reverse().join("")
        },
        buildURLFromParts: function (e) {
          return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
        }
      }, e.exports = o
    },
    "./node_modules/webworkify-webpack/index.js": function (e, t, r) {
      function i(e) {
        var t = {};

        function r(i) {
          if (t[i]) return t[i].exports;
          var a = t[i] = {
            i: i,
            l: !1,
            exports: {}
          };
          return e[i].call(a.exports, a, a.exports, r), a.l = !0, a.exports
        }
        r.m = e, r.c = t, r.i = function (e) {
          return e
        }, r.d = function (e, t, i) {
          r.o(e, t) || Object.defineProperty(e, t, {
            configurable: !1,
            enumerable: !0,
            get: i
          })
        }, r.r = function (e) {
          Object.defineProperty(e, "__esModule", {
            value: !0
          })
        }, r.n = function (e) {
          var t = e && e.__esModule ? function () {
            return e.default
          } : function () {
            return e
          };
          return r.d(t, "a", t), t
        }, r.o = function (e, t) {
          return Object.prototype.hasOwnProperty.call(e, t)
        }, r.p = "/", r.oe = function (e) {
          throw console.error(e), e
        };
        var i = r(r.s = ENTRY_MODULE);
        return i.default || i
      }

      function a(e) {
        return (e + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
      }

      function n(e, t, i) {
        var n = {};
        n[i] = [];
        var s = t.toString(),
          o = s.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);
        if (!o) return n;
        for (var l, d = o[1], u = new RegExp("(\\\\n|\\W)" + a(d) + "\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)", "g"); l = u.exec(s);) "dll-reference" !== l[3] && n[i].push(l[3]);
        for (u = new RegExp("\\(" + a(d) + '\\("(dll-reference\\s([\\.|\\-|\\+|\\w|/|@]+))"\\)\\)\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)', "g"); l = u.exec(s);) e[l[2]] || (n[i].push(l[1]), e[l[2]] = r(l[1]).m), n[l[2]] = n[l[2]] || [], n[l[2]].push(l[4]);
        for (var f, c = Object.keys(n), h = 0; h < c.length; h++)
          for (var g = 0; g < n[c[h]].length; g++) f = n[c[h]][g], isNaN(1 * f) || (n[c[h]][g] = 1 * n[c[h]][g]);
        return n
      }

      function s(e) {
        return Object.keys(e).reduce((function (t, r) {
          return t || e[r].length > 0
        }), !1)
      }
      e.exports = function (e, t) {
        t = t || {};
        var a = {
            main: r.m
          },
          o = t.all ? {
            main: Object.keys(a.main)
          } : function (e, t) {
            for (var r = {
                main: [t]
              }, i = {
                main: []
              }, a = {
                main: {}
              }; s(r);)
              for (var o = Object.keys(r), l = 0; l < o.length; l++) {
                var d = o[l],
                  u = r[d].pop();
                if (a[d] = a[d] || {}, !a[d][u] && e[d][u]) {
                  a[d][u] = !0, i[d] = i[d] || [], i[d].push(u);
                  for (var f = n(e, e[d][u], d), c = Object.keys(f), h = 0; h < c.length; h++) r[c[h]] = r[c[h]] || [], r[c[h]] = r[c[h]].concat(f[c[h]])
                }
              }
            return i
          }(a, e),
          l = "";
        Object.keys(o).filter((function (e) {
          return "main" !== e
        })).forEach((function (e) {
          for (var t = 0; o[e][t];) t++;
          o[e].push(t), a[e][t] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })", l = l + "var " + e + " = (" + i.toString().replace("ENTRY_MODULE", JSON.stringify(t)) + ")({" + o[e].map((function (t) {
            return JSON.stringify(t) + ": " + a[e][t].toString()
          })).join(",") + "});\n"
        })), l = l + "new ((" + i.toString().replace("ENTRY_MODULE", JSON.stringify(e)) + ")({" + o.main.map((function (e) {
          return JSON.stringify(e) + ": " + a.main[e].toString()
        })).join(",") + "}))(self);";
        var d = new window.Blob([l], {
          type: "text/javascript"
        });
        if (t.bare) return d;
        var u = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(d),
          f = new window.Worker(u);
        return f.objectURL = u, f
      }
    },
    "./src/demux/demuxer-inline.js": function (e, t, r) {
      "use strict";
      r.r(t);
      var i = r("./src/events.js"),
        a = r("./src/errors.ts"),
        n = function () {
          function e(e, t) {
            this.subtle = e, this.aesIV = t
          }
          return e.prototype.decrypt = function (e, t) {
            return this.subtle.decrypt({
              name: "AES-CBC",
              iv: this.aesIV
            }, t, e)
          }, e
        }(),
        s = function () {
          function e(e, t) {
            this.subtle = e, this.key = t
          }
          return e.prototype.expandKey = function () {
            return this.subtle.importKey("raw", this.key, {
              name: "AES-CBC"
            }, !1, ["encrypt", "decrypt"])
          }, e
        }();
      var o = function () {
          function e() {
            this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable()
          }
          var t = e.prototype;
          return t.uint8ArrayToUint32Array_ = function (e) {
            for (var t = new DataView(e), r = new Uint32Array(4), i = 0; i < 4; i++) r[i] = t.getUint32(4 * i);
            return r
          }, t.initTable = function () {
            var e = this.sBox,
              t = this.invSBox,
              r = this.subMix,
              i = r[0],
              a = r[1],
              n = r[2],
              s = r[3],
              o = this.invSubMix,
              l = o[0],
              d = o[1],
              u = o[2],
              f = o[3],
              c = new Uint32Array(256),
              h = 0,
              g = 0,
              v = 0;
            for (v = 0; v < 256; v++) c[v] = v < 128 ? v << 1 : v << 1 ^ 283;
            for (v = 0; v < 256; v++) {
              var p = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
              p = p >>> 8 ^ 255 & p ^ 99, e[h] = p, t[p] = h;
              var m = c[h],
                y = c[m],
                E = c[y],
                b = 257 * c[p] ^ 16843008 * p;
              i[h] = b << 24 | b >>> 8, a[h] = b << 16 | b >>> 16, n[h] = b << 8 | b >>> 24, s[h] = b, b = 16843009 * E ^ 65537 * y ^ 257 * m ^ 16843008 * h, l[p] = b << 24 | b >>> 8, d[p] = b << 16 | b >>> 16, u[p] = b << 8 | b >>> 24, f[p] = b, h ? (h = m ^ c[c[c[E ^ m]]], g ^= c[c[g]]) : h = g = 1
            }
          }, t.expandKey = function (e) {
            for (var t = this.uint8ArrayToUint32Array_(e), r = !0, i = 0; i < t.length && r;) r = t[i] === this.key[i], i++;
            if (!r) {
              this.key = t;
              var a = this.keySize = t.length;
              if (4 !== a && 6 !== a && 8 !== a) throw new Error("Invalid aes key size=" + a);
              var n, s, o, l, d = this.ksRows = 4 * (a + 6 + 1),
                u = this.keySchedule = new Uint32Array(d),
                f = this.invKeySchedule = new Uint32Array(d),
                c = this.sBox,
                h = this.rcon,
                g = this.invSubMix,
                v = g[0],
                p = g[1],
                m = g[2],
                y = g[3];
              for (n = 0; n < d; n++) n < a ? o = u[n] = t[n] : (l = o, n % a == 0 ? (l = c[(l = l << 8 | l >>> 24) >>> 24] << 24 | c[l >>> 16 & 255] << 16 | c[l >>> 8 & 255] << 8 | c[255 & l], l ^= h[n / a | 0] << 24) : a > 6 && n % a == 4 && (l = c[l >>> 24] << 24 | c[l >>> 16 & 255] << 16 | c[l >>> 8 & 255] << 8 | c[255 & l]), u[n] = o = (u[n - a] ^ l) >>> 0);
              for (s = 0; s < d; s++) n = d - s, l = 3 & s ? u[n] : u[n - 4], f[s] = s < 4 || n <= 4 ? l : v[c[l >>> 24]] ^ p[c[l >>> 16 & 255]] ^ m[c[l >>> 8 & 255]] ^ y[c[255 & l]], f[s] = f[s] >>> 0
            }
          }, t.networkToHostOrderSwap = function (e) {
            return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
          }, t.decrypt = function (e, t, r, i) {
            for (var a, n, s, o, l, d, u, f, c, h, g, v, p, m, y, E, b, T = this.keySize + 6, S = this.invKeySchedule, _ = this.invSBox, A = this.invSubMix, R = A[0], L = A[1], D = A[2], w = A[3], k = this.uint8ArrayToUint32Array_(r), O = k[0], x = k[1], I = k[2], C = k[3], P = new Int32Array(e), F = new Int32Array(P.length), M = this.networkToHostOrderSwap; t < P.length;) {
              for (c = M(P[t]), h = M(P[t + 1]), g = M(P[t + 2]), v = M(P[t + 3]), l = c ^ S[0], d = v ^ S[1], u = g ^ S[2], f = h ^ S[3], p = 4, m = 1; m < T; m++) a = R[l >>> 24] ^ L[d >> 16 & 255] ^ D[u >> 8 & 255] ^ w[255 & f] ^ S[p], n = R[d >>> 24] ^ L[u >> 16 & 255] ^ D[f >> 8 & 255] ^ w[255 & l] ^ S[p + 1], s = R[u >>> 24] ^ L[f >> 16 & 255] ^ D[l >> 8 & 255] ^ w[255 & d] ^ S[p + 2], o = R[f >>> 24] ^ L[l >> 16 & 255] ^ D[d >> 8 & 255] ^ w[255 & u] ^ S[p + 3], l = a, d = n, u = s, f = o, p += 4;
              a = _[l >>> 24] << 24 ^ _[d >> 16 & 255] << 16 ^ _[u >> 8 & 255] << 8 ^ _[255 & f] ^ S[p], n = _[d >>> 24] << 24 ^ _[u >> 16 & 255] << 16 ^ _[f >> 8 & 255] << 8 ^ _[255 & l] ^ S[p + 1], s = _[u >>> 24] << 24 ^ _[f >> 16 & 255] << 16 ^ _[l >> 8 & 255] << 8 ^ _[255 & d] ^ S[p + 2], o = _[f >>> 24] << 24 ^ _[l >> 16 & 255] << 16 ^ _[d >> 8 & 255] << 8 ^ _[255 & u] ^ S[p + 3], p += 3, F[t] = M(a ^ O), F[t + 1] = M(o ^ x), F[t + 2] = M(s ^ I), F[t + 3] = M(n ^ C), O = c, x = h, I = g, C = v, t += 4
            }
            return i ? (y = F.buffer, E = y.byteLength, (b = E && new DataView(y).getUint8(E - 1)) ? y.slice(0, E - b) : y) : F.buffer
          }, t.destroy = function () {
            this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0
          }, e
        }(),
        l = r("./src/utils/logger.js"),
        d = r("./src/utils/get-self-scope.js"),
        u = Object(d.getSelfScope)(),
        f = function () {
          function e(e, t, r) {
            var i = (void 0 === r ? {} : r).removePKCS7Padding,
              a = void 0 === i || i;
            if (this.logEnabled = !0, this.observer = e, this.config = t, this.removePKCS7Padding = a, a) try {
              var n = u.crypto;
              n && (this.subtle = n.subtle || n.webkitSubtle)
            } catch (e) {}
            this.disableWebCrypto = !this.subtle
          }
          var t = e.prototype;
          return t.isSync = function () {
            return this.disableWebCrypto && this.config.enableSoftwareAES
          }, t.decrypt = function (e, t, r, i) {
            var a = this;
            if (this.disableWebCrypto && this.config.enableSoftwareAES) {
              this.logEnabled && (l.logger.log("JS AES decrypt"), this.logEnabled = !1);
              var d = this.decryptor;
              d || (this.decryptor = d = new o), d.expandKey(t), i(d.decrypt(e, 0, r, this.removePKCS7Padding))
            } else {
              this.logEnabled && (l.logger.log("WebCrypto AES decrypt"), this.logEnabled = !1);
              var u = this.subtle;
              this.key !== t && (this.key = t, this.fastAesKey = new s(u, t)), this.fastAesKey.expandKey().then((function (s) {
                new n(u, r).decrypt(e, s).catch((function (n) {
                  a.onWebCryptoError(n, e, t, r, i)
                })).then((function (e) {
                  i(e)
                }))
              })).catch((function (n) {
                a.onWebCryptoError(n, e, t, r, i)
              }))
            }
          }, t.onWebCryptoError = function (e, t, r, n, s) {
            this.config.enableSoftwareAES ? (l.logger.log("WebCrypto Error, disable WebCrypto API"), this.disableWebCrypto = !0, this.logEnabled = !0, this.decrypt(t, r, n, s)) : (l.logger.error("decrypting error : " + e.message), this.observer.trigger(i.default.ERROR, {
              type: a.ErrorTypes.MEDIA_ERROR,
              details: a.ErrorDetails.FRAG_DECRYPT_ERROR,
              fatal: !0,
              reason: e.message
            }))
          }, t.destroy = function () {
            var e = this.decryptor;
            e && (e.destroy(), this.decryptor = void 0)
          }, e
        }(),
        c = r("./src/polyfills/number-isFinite.js");

      function h(e, t) {
        return 255 === e[t] && 240 == (246 & e[t + 1])
      }

      function g(e, t) {
        return 1 & e[t + 1] ? 7 : 9
      }

      function v(e, t) {
        return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5
      }

      function p(e, t) {
        return !!(t + 1 < e.length && h(e, t))
      }

      function m(e, t) {
        if (p(e, t)) {
          var r = g(e, t);
          if (t + r >= e.length) return !1;
          var i = v(e, t);
          if (i <= r) return !1;
          var a = t + i;
          if (a === e.length || a + 1 < e.length && h(e, a)) return !0
        }
        return !1
      }

      function y(e, t, r, n, s) {
        if (!e.samplerate) {
          var o = function (e, t, r, n) {
            var s, o, d, u, f, c = navigator.userAgent.toLowerCase(),
              h = n,
              g = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
            if (s = 1 + ((192 & t[r + 2]) >>> 6), !((o = (60 & t[r + 2]) >>> 2) > g.length - 1)) return u = (1 & t[r + 2]) << 2, u |= (192 & t[r + 3]) >>> 6, l.logger.log("manifest codec:" + n + ",ADTS data:type:" + s + ",sampleingIndex:" + o + "[" + g[o] + "Hz],channelConfig:" + u), /firefox/i.test(c) ? o >= 6 ? (s = 5, f = new Array(4), d = o - 3) : (s = 2, f = new Array(2), d = o) : -1 !== c.indexOf("android") ? (s = 2, f = new Array(2), d = o) : (s = 5, f = new Array(4), n && (-1 !== n.indexOf("mp4a.40.29") || -1 !== n.indexOf("mp4a.40.5")) || !n && o >= 6 ? d = o - 3 : ((n && -1 !== n.indexOf("mp4a.40.2") && (o >= 6 && 1 === u || /vivaldi/i.test(c)) || !n && 1 === u) && (s = 2, f = new Array(2)), d = o)), f[0] = s << 3, f[0] |= (14 & o) >> 1, f[1] |= (1 & o) << 7, f[1] |= u << 3, 5 === s && (f[1] |= (14 & d) >> 1, f[2] = (1 & d) << 7, f[2] |= 8, f[3] = 0), {
              config: f,
              samplerate: g[o],
              channelCount: u,
              codec: "mp4a.40." + s,
              manifestCodec: h
            };
            e.trigger(i.default.ERROR, {
              type: a.ErrorTypes.MEDIA_ERROR,
              details: a.ErrorDetails.FRAG_PARSING_ERROR,
              fatal: !0,
              reason: "invalid ADTS sampling index:" + o
            })
          }(t, r, n, s);
          e.config = o.config, e.samplerate = o.samplerate, e.channelCount = o.channelCount, e.codec = o.codec, e.manifestCodec = o.manifestCodec, l.logger.log("parsed codec:" + e.codec + ",rate:" + o.samplerate + ",nb channel:" + o.channelCount)
        }
      }

      function E(e) {
        return 9216e4 / e
      }

      function b(e, t, r, i, a) {
        var n = function (e, t, r, i, a) {
          var n, s, o = e.length;
          if (n = g(e, t), s = v(e, t), (s -= n) > 0 && t + n + s <= o) return {
            headerLength: n,
            frameLength: s,
            stamp: r + i * a
          }
        }(t, r, i, a, E(e.samplerate));
        if (n) {
          var s = n.stamp,
            o = n.headerLength,
            l = n.frameLength,
            d = {
              unit: t.subarray(r + o, r + o + l),
              pts: s,
              dts: s
            };
          return e.samples.push(d), {
            sample: d,
            length: l + o
          }
        }
      }
      var T = r("./src/demux/id3.js"),
        S = function () {
          function e(e, t, r) {
            this.observer = e, this.config = r, this.remuxer = t
          }
          var t = e.prototype;
          return t.resetInitSegment = function (e, t, r, i) {
            this._audioTrack = {
              container: "audio/adts",
              type: "audio",
              id: 0,
              sequenceNumber: 0,
              isAAC: !0,
              samples: [],
              len: 0,
              manifestCodec: t,
              duration: i,
              inputTimeScale: 9e4
            }
          }, t.resetTimeStamp = function () {}, e.probe = function (e) {
            if (!e) return !1;
            for (var t = (T.default.getID3Data(e, 0) || []).length, r = e.length; t < r; t++)
              if (m(e, t)) return l.logger.log("ADTS sync word found !"), !0;
            return !1
          }, t.append = function (e, t, r, i) {
            for (var a = this._audioTrack, n = T.default.getID3Data(e, 0) || [], s = T.default.getTimeStamp(n), o = Object(c.isFiniteNumber)(s) ? 90 * s : 9e4 * t, d = 0, u = o, f = e.length, h = n.length, g = [{
                pts: u,
                dts: u,
                data: n
              }]; h < f - 1;)
              if (p(e, h) && h + 5 < f) {
                y(a, this.observer, e, h, a.manifestCodec);
                var v = b(a, e, h, o, d);
                if (!v) {
                  l.logger.log("Unable to parse AAC frame");
                  break
                }
                h += v.length, u = v.sample.pts, d++
              } else T.default.isHeader(e, h) ? (n = T.default.getID3Data(e, h), g.push({
                pts: u,
                dts: u,
                data: n
              }), h += n.length) : h++;
            this.remuxer.remux(a, {
              samples: []
            }, {
              samples: g,
              inputTimeScale: 9e4
            }, {
              samples: []
            }, t, r, i)
          }, t.destroy = function () {}, e
        }(),
        _ = r("./src/demux/mp4demuxer.js"),
        A = {
          BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
          SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
          SamplesCoefficients: [
            [0, 72, 144, 12],
            [0, 0, 0, 0],
            [0, 72, 144, 12],
            [0, 144, 144, 12]
          ],
          BytesInSlot: [0, 1, 1, 4],
          appendFrame: function (e, t, r, i, a) {
            if (!(r + 24 > t.length)) {
              var n = this.parseHeader(t, r);
              if (n && r + n.frameLength <= t.length) {
                var s = i + a * (9e4 * n.samplesPerFrame / n.sampleRate),
                  o = {
                    unit: t.subarray(r, r + n.frameLength),
                    pts: s,
                    dts: s
                  };
                return e.config = [], e.channelCount = n.channelCount, e.samplerate = n.sampleRate, e.samples.push(o), {
                  sample: o,
                  length: n.frameLength
                }
              }
            }
          },
          parseHeader: function (e, t) {
            var r = e[t + 1] >> 3 & 3,
              i = e[t + 1] >> 1 & 3,
              a = e[t + 2] >> 4 & 15,
              n = e[t + 2] >> 2 & 3,
              s = e[t + 2] >> 1 & 1;
            if (1 !== r && 0 !== a && 15 !== a && 3 !== n) {
              var o = 3 === r ? 3 - i : 3 === i ? 3 : 4,
                l = 1e3 * A.BitratesMap[14 * o + a - 1],
                d = 3 === r ? 0 : 2 === r ? 1 : 2,
                u = A.SamplingRateMap[3 * d + n],
                f = e[t + 3] >> 6 == 3 ? 1 : 2,
                c = A.SamplesCoefficients[r][i],
                h = A.BytesInSlot[i],
                g = 8 * c * h;
              return {
                sampleRate: u,
                channelCount: f,
                frameLength: parseInt(c * l / u + s, 10) * h,
                samplesPerFrame: g
              }
            }
          },
          isHeaderPattern: function (e, t) {
            return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1])
          },
          isHeader: function (e, t) {
            return !!(t + 1 < e.length && this.isHeaderPattern(e, t))
          },
          probe: function (e, t) {
            if (t + 1 < e.length && this.isHeaderPattern(e, t)) {
              var r = this.parseHeader(e, t),
                i = 4;
              r && r.frameLength && (i = r.frameLength);
              var a = t + i;
              if (a === e.length || a + 1 < e.length && this.isHeaderPattern(e, a)) return !0
            }
            return !1
          }
        },
        R = A,
        L = function () {
          function e(e) {
            this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0
          }
          var t = e.prototype;
          return t.loadWord = function () {
            var e = this.data,
              t = this.bytesAvailable,
              r = e.byteLength - t,
              i = new Uint8Array(4),
              a = Math.min(4, t);
            if (0 === a) throw new Error("no bytes available");
            i.set(e.subarray(r, r + a)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * a, this.bytesAvailable -= a
          }, t.skipBits = function (e) {
            var t;
            this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, e -= (t = e >> 3) >> 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e)
          }, t.readBits = function (e) {
            var t = Math.min(this.bitsAvailable, e),
              r = this.word >>> 32 - t;
            return e > 32 && l.logger.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0 ? this.word <<= t : this.bytesAvailable > 0 && this.loadWord(), (t = e - t) > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r
          }, t.skipLZ = function () {
            var e;
            for (e = 0; e < this.bitsAvailable; ++e)
              if (0 != (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e;
            return this.loadWord(), e + this.skipLZ()
          }, t.skipUEG = function () {
            this.skipBits(1 + this.skipLZ())
          }, t.skipEG = function () {
            this.skipBits(1 + this.skipLZ())
          }, t.readUEG = function () {
            var e = this.skipLZ();
            return this.readBits(e + 1) - 1
          }, t.readEG = function () {
            var e = this.readUEG();
            return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
          }, t.readBoolean = function () {
            return 1 === this.readBits(1)
          }, t.readUByte = function () {
            return this.readBits(8)
          }, t.readUShort = function () {
            return this.readBits(16)
          }, t.readUInt = function () {
            return this.readBits(32)
          }, t.skipScalingList = function (e) {
            var t, r = 8,
              i = 8;
            for (t = 0; t < e; t++) 0 !== i && (i = (r + this.readEG() + 256) % 256), r = 0 === i ? r : i
          }, t.readSPS = function () {
            var e, t, r, i, a, n, s, o = 0,
              l = 0,
              d = 0,
              u = 0,
              f = this.readUByte.bind(this),
              c = this.readBits.bind(this),
              h = this.readUEG.bind(this),
              g = this.readBoolean.bind(this),
              v = this.skipBits.bind(this),
              p = this.skipEG.bind(this),
              m = this.skipUEG.bind(this),
              y = this.skipScalingList.bind(this);
            if (f(), e = f(), c(5), v(3), f(), m(), 100 === e || 110 === e || 122 === e || 244 === e || 44 === e || 83 === e || 86 === e || 118 === e || 128 === e) {
              var E = h();
              if (3 === E && v(1), m(), m(), v(1), g())
                for (n = 3 !== E ? 8 : 12, s = 0; s < n; s++) g() && y(s < 6 ? 16 : 64)
            }
            m();
            var b = h();
            if (0 === b) h();
            else if (1 === b)
              for (v(1), p(), p(), t = h(), s = 0; s < t; s++) p();
            m(), v(1), r = h(), i = h(), 0 === (a = c(1)) && v(1), v(1), g() && (o = h(), l = h(), d = h(), u = h());
            var T = [1, 1];
            if (g() && g()) switch (f()) {
            case 1:
              T = [1, 1];
              break;
            case 2:
              T = [12, 11];
              break;
            case 3:
              T = [10, 11];
              break;
            case 4:
              T = [16, 11];
              break;
            case 5:
              T = [40, 33];
              break;
            case 6:
              T = [24, 11];
              break;
            case 7:
              T = [20, 11];
              break;
            case 8:
              T = [32, 11];
              break;
            case 9:
              T = [80, 33];
              break;
            case 10:
              T = [18, 11];
              break;
            case 11:
              T = [15, 11];
              break;
            case 12:
              T = [64, 33];
              break;
            case 13:
              T = [160, 99];
              break;
            case 14:
              T = [4, 3];
              break;
            case 15:
              T = [3, 2];
              break;
            case 16:
              T = [2, 1];
              break;
            case 255:
              T = [f() << 8 | f(), f() << 8 | f()]
            }
            return {
              width: Math.ceil(16 * (r + 1) - 2 * o - 2 * l),
              height: (2 - a) * (i + 1) * 16 - (a ? 2 : 4) * (d + u),
              pixelRatio: T
            }
          }, t.readSliceType = function () {
            return this.readUByte(), this.readUEG(), this.readUEG()
          }, e
        }(),
        D = function () {
          function e(e, t, r, i) {
            this.decryptdata = r, this.discardEPB = i, this.decrypter = new f(e, t, {
              removePKCS7Padding: !1
            })
          }
          var t = e.prototype;
          return t.decryptBuffer = function (e, t) {
            this.decrypter.decrypt(e, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, t)
          }, t.decryptAacSample = function (e, t, r, i) {
            var a = e[t].unit,
              n = a.subarray(16, a.length - a.length % 16),
              s = n.buffer.slice(n.byteOffset, n.byteOffset + n.length),
              o = this;
            this.decryptBuffer(s, (function (n) {
              n = new Uint8Array(n), a.set(n, 16), i || o.decryptAacSamples(e, t + 1, r)
            }))
          }, t.decryptAacSamples = function (e, t, r) {
            for (;; t++) {
              if (t >= e.length) return void r();
              if (!(e[t].unit.length < 32)) {
                var i = this.decrypter.isSync();
                if (this.decryptAacSample(e, t, r, i), !i) return
              }
            }
          }, t.getAvcEncryptedData = function (e) {
            for (var t = 16 * Math.floor((e.length - 48) / 160) + 16, r = new Int8Array(t), i = 0, a = 32; a <= e.length - 16; a += 160, i += 16) r.set(e.subarray(a, a + 16), i);
            return r
          }, t.getAvcDecryptedUnit = function (e, t) {
            t = new Uint8Array(t);
            for (var r = 0, i = 32; i <= e.length - 16; i += 160, r += 16) e.set(t.subarray(r, r + 16), i);
            return e
          }, t.decryptAvcSample = function (e, t, r, i, a, n) {
            var s = this.discardEPB(a.data),
              o = this.getAvcEncryptedData(s),
              l = this;
            this.decryptBuffer(o.buffer, (function (o) {
              a.data = l.getAvcDecryptedUnit(s, o), n || l.decryptAvcSamples(e, t, r + 1, i)
            }))
          }, t.decryptAvcSamples = function (e, t, r, i) {
            for (;; t++, r = 0) {
              if (t >= e.length) return void i();
              for (var a = e[t].units; !(r >= a.length); r++) {
                var n = a[r];
                if (!(n.length <= 48 || 1 !== n.type && 5 !== n.type)) {
                  var s = this.decrypter.isSync();
                  if (this.decryptAvcSample(e, t, r, i, n, s), !s) return
                }
              }
            }
          }, e
        }(),
        w = {
          video: 1,
          audio: 2,
          id3: 3,
          text: 4
        },
        k = function () {
          function e(e, t, r, i) {
            this.observer = e, this.config = r, this.typeSupported = i, this.remuxer = t, this.sampleAes = null, this.pmtUnknownTypes = {}
          }
          var t = e.prototype;
          return t.setDecryptData = function (e) {
            null != e && null != e.key && "SAMPLE-AES" === e.method ? this.sampleAes = new D(this.observer, this.config, e, this.discardEPB) : this.sampleAes = null
          }, e.probe = function (t) {
            var r = e._syncOffset(t);
            return !(r < 0) && (r && l.logger.warn("MPEG2-TS detected but first sync word found @ offset " + r + ", junk ahead ?"), !0)
          }, e._syncOffset = function (e) {
            for (var t = Math.min(1e3, e.length - 564), r = 0; r < t;) {
              if (71 === e[r] && 71 === e[r + 188] && 71 === e[r + 376]) return r;
              r++
            }
            return -1
          }, e.createTrack = function (e, t) {
            return {
              container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
              type: e,
              id: w[e],
              pid: -1,
              inputTimeScale: 9e4,
              sequenceNumber: 0,
              samples: [],
              dropped: "video" === e ? 0 : void 0,
              isAAC: "audio" === e || void 0,
              duration: "audio" === e ? t : void 0
            }
          }, t.resetInitSegment = function (t, r, i, a) {
            this.pmtParsed = !1, this._pmtId = -1, this.pmtUnknownTypes = {}, this._avcTrack = e.createTrack("video", a), this._audioTrack = e.createTrack("audio", a), this._id3Track = e.createTrack("id3", a), this._txtTrack = e.createTrack("text", a), this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = r, this.videoCodec = i, this._duration = a
          }, t.resetTimeStamp = function () {}, t.append = function (t, r, n, s) {
            var o, d, u, f, c, h = t.length,
              g = !1;
            this.pmtUnknownTypes = {}, this.contiguous = n;
            var v = this.pmtParsed,
              p = this._avcTrack,
              m = this._audioTrack,
              y = this._id3Track,
              E = p.pid,
              b = m.pid,
              T = y.pid,
              S = this._pmtId,
              _ = p.pesData,
              A = m.pesData,
              R = y.pesData,
              L = this._parsePAT,
              D = this._parsePMT.bind(this),
              w = this._parsePES,
              k = this._parseAVCPES.bind(this),
              O = this._parseAACPES.bind(this),
              x = this._parseMPEGPES.bind(this),
              I = this._parseID3PES.bind(this),
              C = e._syncOffset(t);
            for (h -= (h + C) % 188, o = C; o < h; o += 188)
              if (71 === t[o]) {
                if (d = !!(64 & t[o + 1]), u = ((31 & t[o + 1]) << 8) + t[o + 2], (48 & t[o + 3]) >> 4 > 1) {
                  if ((f = o + 5 + t[o + 4]) === o + 188) continue
                } else f = o + 4;
                switch (u) {
                case E:
                  d && (_ && (c = w(_)) && k(c, !1), _ = {
                    data: [],
                    size: 0
                  }), _ && (_.data.push(t.subarray(f, o + 188)), _.size += o + 188 - f);
                  break;
                case b:
                  d && (A && (c = w(A)) && (m.isAAC ? O(c) : x(c)), A = {
                    data: [],
                    size: 0
                  }), A && (A.data.push(t.subarray(f, o + 188)), A.size += o + 188 - f);
                  break;
                case T:
                  d && (R && (c = w(R)) && I(c), R = {
                    data: [],
                    size: 0
                  }), R && (R.data.push(t.subarray(f, o + 188)), R.size += o + 188 - f);
                  break;
                case 0:
                  d && (f += t[f] + 1), S = this._pmtId = L(t, f);
                  break;
                case S:
                  d && (f += t[f] + 1);
                  var P = D(t, f, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, null != this.sampleAes);
                  (E = P.avc) > 0 && (p.pid = E), (b = P.audio) > 0 && (m.pid = b, m.isAAC = P.isAAC), (T = P.id3) > 0 && (y.pid = T), g && !v && (l.logger.log("reparse from beginning"), g = !1, o = C - 188), v = this.pmtParsed = !0;
                  break;
                case 17:
                case 8191:
                  break;
                default:
                  g = !0
                }
              } else this.observer.trigger(i.default.ERROR, {
                type: a.ErrorTypes.MEDIA_ERROR,
                details: a.ErrorDetails.FRAG_PARSING_ERROR,
                fatal: !1,
                reason: "TS packet did not start with 0x47"
              });
            _ && (c = w(_)) ? (k(c, !0), p.pesData = null) : p.pesData = _, A && (c = w(A)) ? (m.isAAC ? O(c) : x(c), m.pesData = null) : (A && A.size && l.logger.log("last AAC PES packet truncated,might overlap between fragments"), m.pesData = A), R && (c = w(R)) ? (I(c), y.pesData = null) : y.pesData = R, null == this.sampleAes ? this.remuxer.remux(m, p, y, this._txtTrack, r, n, s) : this.decryptAndRemux(m, p, y, this._txtTrack, r, n, s)
          }, t.decryptAndRemux = function (e, t, r, i, a, n, s) {
            if (e.samples && e.isAAC) {
              var o = this;
              this.sampleAes.decryptAacSamples(e.samples, 0, (function () {
                o.decryptAndRemuxAvc(e, t, r, i, a, n, s)
              }))
            } else this.decryptAndRemuxAvc(e, t, r, i, a, n, s)
          }, t.decryptAndRemuxAvc = function (e, t, r, i, a, n, s) {
            if (t.samples) {
              var o = this;
              this.sampleAes.decryptAvcSamples(t.samples, 0, 0, (function () {
                o.remuxer.remux(e, t, r, i, a, n, s)
              }))
            } else this.remuxer.remux(e, t, r, i, a, n, s)
          }, t.destroy = function () {
            this._initPTS = this._initDTS = void 0, this._duration = 0
          }, t._parsePAT = function (e, t) {
            return (31 & e[t + 10]) << 8 | e[t + 11]
          }, t._trackUnknownPmt = function (e, t, r) {
            var i = this.pmtUnknownTypes[e] || 0;
            return 0 === i && (this.pmtUnknownTypes[e] = 0, t.call(l.logger, r)), this.pmtUnknownTypes[e]++, i
          }, t._parsePMT = function (e, t, r, i) {
            var a, n, s = {
              audio: -1,
              avc: -1,
              id3: -1,
              isAAC: !0
            };
            for (a = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4, t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < a;) {
              switch (n = (31 & e[t + 1]) << 8 | e[t + 2], e[t]) {
              case 207:
                if (!i) {
                  this._trackUnknownPmt(e[t], l.logger.warn, "ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                  break
                }
                case 15:
                  -1 === s.audio && (s.audio = n);
                  break;
                case 21:
                  -1 === s.id3 && (s.id3 = n);
                  break;
                case 219:
                  if (!i) {
                    this._trackUnknownPmt(e[t], l.logger.warn, "H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                    break
                  }
                  case 27:
                    -1 === s.avc && (s.avc = n);
                    break;
                  case 3:
                  case 4:
                    r ? -1 === s.audio && (s.audio = n, s.isAAC = !1) : this._trackUnknownPmt(e[t], l.logger.warn, "MPEG audio found, not supported in this browser");
                    break;
                  case 36:
                    this._trackUnknownPmt(e[t], l.logger.warn, "Unsupported HEVC stream type found");
                    break;
                  default:
                    this._trackUnknownPmt(e[t], l.logger.log, "Unknown stream type:" + e[t])
              }
              t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4])
            }
            return s
          }, t._parsePES = function (e) {
            var t, r, i, a, n, s, o, d, u = 0,
              f = e.data;
            if (!e || 0 === e.size) return null;
            for (; f[0].length < 19 && f.length > 1;) {
              var c = new Uint8Array(f[0].length + f[1].length);
              c.set(f[0]), c.set(f[1], f[0].length), f[0] = c, f.splice(1, 1)
            }
            if (1 === ((t = f[0])[0] << 16) + (t[1] << 8) + t[2]) {
              if ((i = (t[4] << 8) + t[5]) && i > e.size - 6) return null;
              if (192 & (r = t[7]) && ((s = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2) > 4294967295 && (s -= 8589934592), 64 & r ? ((o = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2) > 4294967295 && (o -= 8589934592), s - o > 54e5 && (l.logger.warn(Math.round((s - o) / 9e4) + "s delta between PTS and DTS, align them"), s = o)) : o = s), d = (a = t[8]) + 9, e.size <= d) return null;
              e.size -= d, n = new Uint8Array(e.size);
              for (var h = 0, g = f.length; h < g; h++) {
                var v = (t = f[h]).byteLength;
                if (d) {
                  if (d > v) {
                    d -= v;
                    continue
                  }
                  t = t.subarray(d), v -= d, d = 0
                }
                n.set(t, u), u += v
              }
              return i && (i -= a + 3), {
                data: n,
                pts: s,
                dts: o,
                len: i
              }
            }
            return null
          }, t.pushAccesUnit = function (e, t) {
            if (e.units.length && e.frame) {
              var r = t.samples,
                i = r.length;
              if (isNaN(e.pts)) {
                if (!i) return void t.dropped++;
                var a = r[i - 1];
                e.pts = a.pts, e.dts = a.dts
              }!this.config.forceKeyFrameOnDiscontinuity || !0 === e.key || t.sps && (i || this.contiguous) ? (e.id = i, r.push(e)) : t.dropped++
            }
            e.debug.length && l.logger.log(e.pts + "/" + e.dts + ":" + e.debug)
          }, t._parseAVCPES = function (e, t) {
            var r, i, a, n = this,
              s = this._avcTrack,
              o = this._parseAVCNALu(e.data),
              l = this.avcSample,
              d = !1,
              u = this.pushAccesUnit.bind(this),
              f = function (e, t, r, i) {
                return {
                  key: e,
                  pts: t,
                  dts: r,
                  units: [],
                  debug: i
                }
              };
            e.data = null, l && o.length && !s.audFound && (u(l, s), l = this.avcSample = f(!1, e.pts, e.dts, "")), o.forEach((function (t) {
              switch (t.type) {
              case 1:
                i = !0, l || (l = n.avcSample = f(!0, e.pts, e.dts, "")), l.frame = !0;
                var o = t.data;
                if (d && o.length > 4) {
                  var c = new L(o).readSliceType();
                  2 !== c && 4 !== c && 7 !== c && 9 !== c || (l.key = !0)
                }
                break;
              case 5:
                i = !0, l || (l = n.avcSample = f(!0, e.pts, e.dts, "")), l.key = !0, l.frame = !0;
                break;
              case 6:
                i = !0, (r = new L(n.discardEPB(t.data))).readUByte();
                for (var h = 0, g = 0, v = !1, p = 0; !v && r.bytesAvailable > 1;) {
                  h = 0;
                  do {
                    h += p = r.readUByte()
                  } while (255 === p);
                  g = 0;
                  do {
                    g += p = r.readUByte()
                  } while (255 === p);
                  if (4 === h && 0 !== r.bytesAvailable) {
                    if (v = !0, 181 === r.readUByte())
                      if (49 === r.readUShort())
                        if (1195456820 === r.readUInt())
                          if (3 === r.readUByte()) {
                            var m = r.readUByte(),
                              y = 31 & m,
                              E = [m, r.readUByte()];
                            for (a = 0; a < y; a++) E.push(r.readUByte()), E.push(r.readUByte()), E.push(r.readUByte());
                            n._insertSampleInOrder(n._txtTrack.samples, {
                              type: 3,
                              pts: e.pts,
                              bytes: E
                            })
                          }
                  } else if (5 === h && 0 !== r.bytesAvailable) {
                    if (v = !0, g > 16) {
                      var b = [];
                      for (a = 0; a < 16; a++) b.push(r.readUByte().toString(16)), 3 !== a && 5 !== a && 7 !== a && 9 !== a || b.push("-");
                      var S = g - 16,
                        _ = new Uint8Array(S);
                      for (a = 0; a < S; a++) _[a] = r.readUByte();
                      n._insertSampleInOrder(n._txtTrack.samples, {
                        pts: e.pts,
                        payloadType: h,
                        uuid: b.join(""),
                        userDataBytes: _,
                        userData: Object(T.utf8ArrayToStr)(_.buffer)
                      })
                    }
                  } else if (g < r.bytesAvailable)
                    for (a = 0; a < g; a++) r.readUByte()
                }
                break;
              case 7:
                if (i = !0, d = !0, !s.sps) {
                  var A = (r = new L(t.data)).readSPS();
                  s.width = A.width, s.height = A.height, s.pixelRatio = A.pixelRatio, s.sps = [t.data], s.duration = n._duration;
                  var R = t.data.subarray(1, 4),
                    D = "avc1.";
                  for (a = 0; a < 3; a++) {
                    var w = R[a].toString(16);
                    w.length < 2 && (w = "0" + w), D += w
                  }
                  s.codec = D
                }
                break;
              case 8:
                i = !0, s.pps || (s.pps = [t.data]);
                break;
              case 9:
                i = !1, s.audFound = !0, l && u(l, s), l = n.avcSample = f(!1, e.pts, e.dts, "");
                break;
              case 12:
                i = !1;
                break;
              default:
                i = !1, l && (l.debug += "unknown NAL " + t.type + " ")
              }
              l && i && l.units.push(t)
            })), t && l && (u(l, s), this.avcSample = null)
          }, t._insertSampleInOrder = function (e, t) {
            var r = e.length;
            if (r > 0) {
              if (t.pts >= e[r - 1].pts) e.push(t);
              else
                for (var i = r - 1; i >= 0; i--)
                  if (t.pts < e[i].pts) {
                    e.splice(i, 0, t);
                    break
                  }
            } else e.push(t)
          }, t._getLastNalUnit = function () {
            var e, t = this.avcSample;
            if (!t || 0 === t.units.length) {
              var r = this._avcTrack.samples;
              t = r[r.length - 1]
            }
            if (t) {
              var i = t.units;
              e = i[i.length - 1]
            }
            return e
          }, t._parseAVCNALu = function (e) {
            var t, r, i, a, n = 0,
              s = e.byteLength,
              o = this._avcTrack,
              l = o.naluState || 0,
              d = l,
              u = [],
              f = -1;
            for (-1 === l && (f = 0, a = 31 & e[0], l = 0, n = 1); n < s;)
              if (t = e[n++], l)
                if (1 !== l)
                  if (t)
                    if (1 === t) {
                      if (f >= 0) i = {
                        data: e.subarray(f, n - l - 1),
                        type: a
                      }, u.push(i);
                      else {
                        var c = this._getLastNalUnit();
                        if (c && (d && n <= 4 - d && c.state && (c.data = c.data.subarray(0, c.data.byteLength - d)), (r = n - l - 1) > 0)) {
                          var h = new Uint8Array(c.data.byteLength + r);
                          h.set(c.data, 0), h.set(e.subarray(0, r), c.data.byteLength), c.data = h
                        }
                      }
                      n < s ? (f = n, a = 31 & e[n], l = 0) : l = -1
                    } else l = 0;
            else l = 3;
            else l = t ? 0 : 2;
            else l = t ? 0 : 1;
            if (f >= 0 && l >= 0 && (i = {
                data: e.subarray(f, s),
                type: a,
                state: l
              }, u.push(i)), 0 === u.length) {
              var g = this._getLastNalUnit();
              if (g) {
                var v = new Uint8Array(g.data.byteLength + e.byteLength);
                v.set(g.data, 0), v.set(e, g.data.byteLength), g.data = v
              }
            }
            return o.naluState = l, u
          }, t.discardEPB = function (e) {
            for (var t, r, i = e.byteLength, a = [], n = 1; n < i - 2;) 0 === e[n] && 0 === e[n + 1] && 3 === e[n + 2] ? (a.push(n + 2), n += 2) : n++;
            if (0 === a.length) return e;
            t = i - a.length, r = new Uint8Array(t);
            var s = 0;
            for (n = 0; n < t; s++, n++) s === a[0] && (s++, a.shift()), r[n] = e[s];
            return r
          }, t._parseAACPES = function (e) {
            var t, r, n, s, o, d, u, f = this._audioTrack,
              c = e.data,
              h = e.pts,
              g = this.aacOverFlow,
              v = this.aacLastPTS;
            if (g) {
              var m = new Uint8Array(g.byteLength + c.byteLength);
              m.set(g, 0), m.set(c, g.byteLength), c = m
            }
            for (n = 0, o = c.length; n < o - 1 && !p(c, n); n++);
            if (n && (n < o - 1 ? (d = "AAC PES did not start with ADTS header,offset:" + n, u = !1) : (d = "no ADTS header found in AAC PES", u = !0), l.logger.warn("parsing error:" + d), this.observer.trigger(i.default.ERROR, {
                type: a.ErrorTypes.MEDIA_ERROR,
                details: a.ErrorDetails.FRAG_PARSING_ERROR,
                fatal: u,
                reason: d
              }), u)) return;
            if (y(f, this.observer, c, n, this.audioCodec), r = 0, t = E(f.samplerate), g && v) {
              var T = v + t;
              Math.abs(T - h) > 1 && (l.logger.log("AAC: align PTS for overlapping frames by " + Math.round((T - h) / 90)), h = T)
            }
            for (; n < o;) {
              if (p(c, n)) {
                if (n + 5 < o) {
                  var S = b(f, c, n, h, r);
                  if (S) {
                    n += S.length, s = S.sample.pts, r++;
                    continue
                  }
                }
                break
              }
              n++
            }
            g = n < o ? c.subarray(n, o) : null, this.aacOverFlow = g, this.aacLastPTS = s
          }, t._parseMPEGPES = function (e) {
            for (var t = e.data, r = t.length, i = 0, a = 0, n = e.pts; a < r;)
              if (R.isHeader(t, a)) {
                var s = R.appendFrame(this._audioTrack, t, a, n, i);
                if (!s) break;
                a += s.length, i++
              } else a++
          }, t._parseID3PES = function (e) {
            this._id3Track.samples.push(e)
          }, e
        }(),
        O = function () {
          function e(e, t, r) {
            this.observer = e, this.config = r, this.remuxer = t
          }
          var t = e.prototype;
          return t.resetInitSegment = function (e, t, r, i) {
            this._audioTrack = {
              container: "audio/mpeg",
              type: "audio",
              id: -1,
              sequenceNumber: 0,
              isAAC: !1,
              samples: [],
              len: 0,
              manifestCodec: t,
              duration: i,
              inputTimeScale: 9e4
            }
          }, t.resetTimeStamp = function () {}, e.probe = function (e) {
            var t, r, i = T.default.getID3Data(e, 0);
            if (i && void 0 !== T.default.getTimeStamp(i))
              for (t = i.length, r = Math.min(e.length - 1, t + 100); t < r; t++)
                if (R.probe(e, t)) return l.logger.log("MPEG Audio sync word found !"), !0;
            return !1
          }, t.append = function (e, t, r, i) {
            for (var a = T.default.getID3Data(e, 0), n = T.default.getTimeStamp(a), s = void 0 !== n ? 90 * n : 9e4 * t, o = a.length, l = e.length, d = 0, u = 0, f = this._audioTrack, c = [{
                pts: s,
                dts: s,
                data: a
              }]; o < l;)
              if (R.isHeader(e, o)) {
                var h = R.appendFrame(f, e, o, s, d);
                if (!h) break;
                o += h.length, u = h.sample.pts, d++
              } else T.default.isHeader(e, o) ? (a = T.default.getID3Data(e, o), c.push({
                pts: u,
                dts: u,
                data: a
              }), o += a.length) : o++;
            this.remuxer.remux(f, {
              samples: []
            }, {
              samples: c,
              inputTimeScale: 9e4
            }, {
              samples: []
            }, t, r, i)
          }, t.destroy = function () {}, e
        }(),
        x = function () {
          function e() {}
          return e.getSilentFrame = function (e, t) {
            switch (e) {
            case "mp4a.40.2":
              if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);
              if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
              if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
              if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
              if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
              if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
              break;
            default:
              if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
              if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
              if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
            }
            return null
          }, e
        }(),
        I = Math.pow(2, 32) - 1,
        C = function () {
          function e() {}
          return e.init = function () {
            var t;
            for (t in e.types = {
                avc1: [],
                avcC: [],
                btrt: [],
                dinf: [],
                dref: [],
                esds: [],
                ftyp: [],
                hdlr: [],
                mdat: [],
                mdhd: [],
                mdia: [],
                mfhd: [],
                minf: [],
                moof: [],
                moov: [],
                mp4a: [],
                ".mp3": [],
                mvex: [],
                mvhd: [],
                pasp: [],
                sdtp: [],
                stbl: [],
                stco: [],
                stsc: [],
                stsd: [],
                stsz: [],
                stts: [],
                tfdt: [],
                tfhd: [],
                traf: [],
                trak: [],
                trun: [],
                trex: [],
                tkhd: [],
                vmhd: [],
                smhd: []
              }, e.types) e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
            var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
              i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
            e.HDLR_TYPES = {
              video: r,
              audio: i
            };
            var a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
              n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
            e.STTS = e.STSC = e.STCO = n, e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
            var s = new Uint8Array([105, 115, 111, 109]),
              o = new Uint8Array([97, 118, 99, 49]),
              l = new Uint8Array([0, 0, 0, 1]);
            e.FTYP = e.box(e.types.ftyp, s, l, s, o), e.DINF = e.box(e.types.dinf, e.box(e.types.dref, a))
          }, e.box = function (e) {
            for (var t, r = Array.prototype.slice.call(arguments, 1), i = 8, a = r.length, n = a; a--;) i += r[a].byteLength;
            for ((t = new Uint8Array(i))[0] = i >> 24 & 255, t[1] = i >> 16 & 255, t[2] = i >> 8 & 255, t[3] = 255 & i, t.set(e, 4), a = 0, i = 8; a < n; a++) t.set(r[a], i), i += r[a].byteLength;
            return t
          }, e.hdlr = function (t) {
            return e.box(e.types.hdlr, e.HDLR_TYPES[t])
          }, e.mdat = function (t) {
            return e.box(e.types.mdat, t)
          }, e.mdhd = function (t, r) {
            r *= t;
            var i = Math.floor(r / (I + 1)),
              a = Math.floor(r % (I + 1));
            return e.box(e.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 85, 196, 0, 0]))
          }, e.mdia = function (t) {
            return e.box(e.types.mdia, e.mdhd(t.timescale, t.duration), e.hdlr(t.type), e.minf(t))
          }, e.mfhd = function (t) {
            return e.box(e.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]))
          }, e.minf = function (t) {
            return "audio" === t.type ? e.box(e.types.minf, e.box(e.types.smhd, e.SMHD), e.DINF, e.stbl(t)) : e.box(e.types.minf, e.box(e.types.vmhd, e.VMHD), e.DINF, e.stbl(t))
          }, e.moof = function (t, r, i) {
            return e.box(e.types.moof, e.mfhd(t), e.traf(i, r))
          }, e.moov = function (t) {
            for (var r = t.length, i = []; r--;) i[r] = e.trak(t[r]);
            return e.box.apply(null, [e.types.moov, e.mvhd(t[0].timescale, t[0].duration)].concat(i).concat(e.mvex(t)))
          }, e.mvex = function (t) {
            for (var r = t.length, i = []; r--;) i[r] = e.trex(t[r]);
            return e.box.apply(null, [e.types.mvex].concat(i))
          }, e.mvhd = function (t, r) {
            r *= t;
            var i = Math.floor(r / (I + 1)),
              a = Math.floor(r % (I + 1)),
              n = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
            return e.box(e.types.mvhd, n)
          }, e.sdtp = function (t) {
            var r, i, a = t.samples || [],
              n = new Uint8Array(4 + a.length);
            for (i = 0; i < a.length; i++) r = a[i].flags, n[i + 4] = r.dependsOn << 4 | r.isDependedOn << 2 | r.hasRedundancy;
            return e.box(e.types.sdtp, n)
          }, e.stbl = function (t) {
            return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.STTS), e.box(e.types.stsc, e.STSC), e.box(e.types.stsz, e.STSZ), e.box(e.types.stco, e.STCO))
          }, e.avc1 = function (t) {
            var r, i, a, n = [],
              s = [];
            for (r = 0; r < t.sps.length; r++) a = (i = t.sps[r]).byteLength, n.push(a >>> 8 & 255), n.push(255 & a), n = n.concat(Array.prototype.slice.call(i));
            for (r = 0; r < t.pps.length; r++) a = (i = t.pps[r]).byteLength, s.push(a >>> 8 & 255), s.push(255 & a), s = s.concat(Array.prototype.slice.call(i));
            var o = e.box(e.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | t.sps.length].concat(n).concat([t.pps.length]).concat(s))),
              l = t.width,
              d = t.height,
              u = t.pixelRatio[0],
              f = t.pixelRatio[1];
            return e.box(e.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, d >> 8 & 255, 255 & d, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), e.box(e.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u, f >> 24, f >> 16 & 255, f >> 8 & 255, 255 & f])))
          }, e.esds = function (e) {
            var t = e.config.length;
            return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]))
          }, e.mp4a = function (t) {
            var r = t.samplerate;
            return e.box(e.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), e.box(e.types.esds, e.esds(t)))
          }, e.mp3 = function (t) {
            var r = t.samplerate;
            return e.box(e.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]))
          }, e.stsd = function (t) {
            return "audio" === t.type ? t.isAAC || "mp3" !== t.codec ? e.box(e.types.stsd, e.STSD, e.mp4a(t)) : e.box(e.types.stsd, e.STSD, e.mp3(t)) : e.box(e.types.stsd, e.STSD, e.avc1(t))
          }, e.tkhd = function (t) {
            var r = t.id,
              i = t.duration * t.timescale,
              a = t.width,
              n = t.height,
              s = Math.floor(i / (I + 1)),
              o = Math.floor(i % (I + 1));
            return e.box(e.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, a >> 8 & 255, 255 & a, 0, 0, n >> 8 & 255, 255 & n, 0, 0]))
          }, e.traf = function (t, r) {
            var i = e.sdtp(t),
              a = t.id,
              n = Math.floor(r / (I + 1)),
              s = Math.floor(r % (I + 1));
            return e.box(e.types.traf, e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), e.box(e.types.tfdt, new Uint8Array([1, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), e.trun(t, i.length + 16 + 20 + 8 + 16 + 8 + 8), i)
          }, e.trak = function (t) {
            return t.duration = t.duration || 4294967295, e.box(e.types.trak, e.tkhd(t), e.mdia(t))
          }, e.trex = function (t) {
            var r = t.id;
            return e.box(e.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
          }, e.trun = function (t, r) {
            var i, a, n, s, o, l, d = t.samples || [],
              u = d.length,
              f = 12 + 16 * u,
              c = new Uint8Array(f);
            for (r += 8 + f, c.set([0, 0, 15, 1, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), i = 0; i < u; i++) n = (a = d[i]).duration, s = a.size, o = a.flags, l = a.cts, c.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i);
            return e.box(e.types.trun, c)
          }, e.initSegment = function (t) {
            e.types || e.init();
            var r, i = e.moov(t);
            return (r = new Uint8Array(e.FTYP.byteLength + i.byteLength)).set(e.FTYP), r.set(i, e.FTYP.byteLength), r
          }, e
        }();

      function P(e, t, r, i) {
        void 0 === r && (r = 1), void 0 === i && (i = !1);
        var a = e * t * r;
        return i ? Math.round(a) : a
      }

      function F(e, t) {
        return void 0 === t && (t = !1), P(e, 1e3, 1 / 9e4, t)
      }

      function M(e, t) {
        return void 0 === t && (t = 1), P(e, 9e4, 1 / t)
      }
      var U, N = M(10),
        B = M(.2),
        G = function () {
          function e(e, t, r, i) {
            this.observer = e, this.config = t, this.typeSupported = r;
            var a = navigator.userAgent;
            this.isSafari = i && i.indexOf("Apple") > -1 && a && !a.match("CriOS"), this.ISGenerated = !1
          }
          var t = e.prototype;
          return t.destroy = function () {}, t.resetTimeStamp = function (e) {
            this._initPTS = this._initDTS = e
          }, t.resetInitSegment = function () {
            this.ISGenerated = !1
          }, t.remux = function (e, t, r, a, n, s, o) {
            if (this.ISGenerated || this.generateIS(e, t, n), this.ISGenerated) {
              var d = e.samples.length,
                u = t.samples.length,
                f = n,
                c = n;
              if (d && u) {
                var h = (e.samples[0].pts - t.samples[0].pts) / t.inputTimeScale;
                f += Math.max(0, h), c += Math.max(0, -h)
              }
              if (d) {
                e.timescale || (l.logger.warn("regenerate InitSegment as audio detected"), this.generateIS(e, t, n));
                var g, v = this.remuxAudio(e, f, s, o);
                if (u) v && (g = v.endPTS - v.startPTS), t.timescale || (l.logger.warn("regenerate InitSegment as video detected"), this.generateIS(e, t, n)), this.remuxVideo(t, c, s, g, o)
              } else if (u) {
                var p = this.remuxVideo(t, c, s, 0, o);
                p && e.codec && this.remuxEmptyAudio(e, f, s, p)
              }
            }
            r.samples.length && this.remuxID3(r, n), a.samples.length && this.remuxText(a, n), this.observer.trigger(i.default.FRAG_PARSED)
          }, t.generateIS = function (e, t, r) {
            var n, s, o = this.observer,
              d = e.samples,
              u = t.samples,
              f = this.typeSupported,
              c = "audio/mp4",
              h = {},
              g = {
                tracks: h
              },
              v = void 0 === this._initPTS;
            if (v && (n = s = 1 / 0), e.config && d.length && (e.timescale = e.samplerate, l.logger.log("audio sampling rate : " + e.samplerate), e.isAAC || (f.mpeg ? (c = "audio/mpeg", e.codec = "") : f.mp3 && (e.codec = "mp3")), h.audio = {
                container: c,
                codec: e.codec,
                initSegment: !e.isAAC && f.mpeg ? new Uint8Array : C.initSegment([e]),
                metadata: {
                  channelCount: e.channelCount
                }
              }, v && (n = s = d[0].pts - e.inputTimeScale * r)), t.sps && t.pps && u.length) {
              var p = t.inputTimeScale;
              t.timescale = p, h.video = {
                container: "video/mp4",
                codec: t.codec,
                initSegment: C.initSegment([t]),
                metadata: {
                  width: t.width,
                  height: t.height
                }
              }, v && (n = Math.min(n, u[0].pts - p * r), s = Math.min(s, u[0].dts - p * r), this.observer.trigger(i.default.INIT_PTS_FOUND, {
                initPTS: n
              }))
            } else v && h.audio && this.observer.trigger(i.default.INIT_PTS_FOUND, {
              initPTS: n
            });
            Object.keys(h).length ? (o.trigger(i.default.FRAG_PARSING_INIT_SEGMENT, g), this.ISGenerated = !0, v && (this._initPTS = n, this._initDTS = s)) : o.trigger(i.default.ERROR, {
              type: a.ErrorTypes.MEDIA_ERROR,
              details: a.ErrorDetails.FRAG_PARSING_ERROR,
              fatal: !1,
              reason: "no audio/video samples found"
            })
          }, t.remuxVideo = function (e, t, r, n, s) {
            var o, d, u, f, c, h, g, v = 8,
              p = e.timescale,
              m = e.samples,
              y = [],
              E = m.length,
              b = this._PTSNormalize,
              T = this._initPTS,
              S = this.nextAvcDts,
              _ = this.isSafari;
            if (0 !== E) {
              _ && (r |= m.length && S && (s && Math.abs(t - S / p) < .1 || Math.abs(m[0].pts - S - T) < p / 5)), r || (S = t * p), m.forEach((function (e) {
                e.pts = b(e.pts - T, S), e.dts = b(e.dts - T, S)
              })), m.sort((function (e, t) {
                var r = e.dts - t.dts,
                  i = e.pts - t.pts;
                return r || i || e.id - t.id
              }));
              var A = m.reduce((function (e, t) {
                return Math.max(Math.min(e, t.pts - t.dts), -1 * B)
              }), 0);
              if (A < 0) {
                l.logger.warn("PTS < DTS detected in video samples, shifting DTS by " + F(A, !0) + " ms to overcome this issue");
                for (var R = 0; R < m.length; R++) m[R].dts += A
              }
              var L = m[0];
              c = Math.max(L.dts, 0), f = Math.max(L.pts, 0);
              var D = c - S;
              r && D && (D > 1 ? l.logger.log("AVC: " + F(D, !0) + " ms hole between fragments detected,filling it") : D < -1 && l.logger.log("AVC: " + F(-D, !0) + " ms overlapping between fragments detected"), c = S, m[0].dts = c, f = Math.max(f - D, S), m[0].pts = f, l.logger.log("Video: PTS/DTS adjusted: " + F(f, !0) + "/" + F(c, !0) + ", delta: " + F(D, !0) + " ms")), L = m[m.length - 1], g = Math.max(L.dts, 0), h = Math.max(L.pts, 0, g), _ && (o = Math.round((g - c) / (m.length - 1)));
              for (var w = 0, k = 0, O = 0; O < E; O++) {
                for (var x = m[O], I = x.units, P = I.length, M = 0, U = 0; U < P; U++) M += I[U].data.length;
                k += M, w += P, x.length = M, x.dts = _ ? c + O * o : Math.max(x.dts, c), x.pts = Math.max(x.pts, x.dts)
              }
              var N = k + 4 * w + 8;
              try {
                d = new Uint8Array(N)
              } catch (e) {
                return void this.observer.trigger(i.default.ERROR, {
                  type: a.ErrorTypes.MUX_ERROR,
                  details: a.ErrorDetails.REMUX_ALLOC_ERROR,
                  fatal: !1,
                  bytes: N,
                  reason: "fail allocating video mdat " + N
                })
              }
              var G = new DataView(d.buffer);
              G.setUint32(0, N), d.set(C.types.mdat, 4);
              for (var j = 0; j < E; j++) {
                for (var K = m[j], H = K.units, V = 0, W = void 0, Y = 0, z = H.length; Y < z; Y++) {
                  var X = H[Y],
                    q = X.data,
                    Q = X.data.byteLength;
                  G.setUint32(v, Q), v += 4, d.set(q, v), v += Q, V += 4 + Q
                }
                if (_) W = Math.max(0, o * Math.round((K.pts - K.dts) / o));
                else {
                  if (j < E - 1) o = m[j + 1].dts - K.dts;
                  else {
                    var Z = this.config,
                      J = K.dts - m[j > 0 ? j - 1 : j].dts;
                    if (Z.stretchShortVideoTrack) {
                      var $ = Z.maxBufferHole,
                        ee = Math.floor($ * p),
                        te = (n ? f + n * p : this.nextAudioPts) - K.pts;
                      te > ee ? ((o = te - J) < 0 && (o = J), l.logger.log("It is approximately " + F(te, !1) + " ms to the next segment; using duration " + F(o, !1) + " ms for the last video frame.")) : o = J
                    } else o = J
                  }
                  W = Math.round(K.pts - K.dts)
                }
                y.push({
                  size: V,
                  duration: o,
                  cts: W,
                  flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: K.key ? 2 : 1,
                    isNonSync: K.key ? 0 : 1
                  }
                })
              }
              this.nextAvcDts = g + o;
              var re = e.dropped;
              if (e.nbNalu = 0, e.dropped = 0, y.length && navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                var ie = y[0].flags;
                ie.dependsOn = 2, ie.isNonSync = 0
              }
              e.samples = y, u = C.moof(e.sequenceNumber++, c, e), e.samples = [];
              var ae = {
                data1: u,
                data2: d,
                startPTS: f / p,
                endPTS: (h + o) / p,
                startDTS: c / p,
                endDTS: this.nextAvcDts / p,
                type: "video",
                hasAudio: !1,
                hasVideo: !0,
                nb: y.length,
                dropped: re
              };
              return this.observer.trigger(i.default.FRAG_PARSING_DATA, ae), ae
            }
          }, t.remuxAudio = function (e, t, r, n) {
            var s, o, d, u, f, c, h = e.inputTimeScale,
              g = e.timescale,
              v = h / g,
              p = (e.isAAC ? 1024 : 1152) * v,
              m = this._PTSNormalize,
              y = this._initPTS,
              E = !e.isAAC && this.typeSupported.mpeg,
              b = E ? 0 : 8,
              T = e.samples,
              S = [],
              _ = this.nextAudioPts;
            if (r |= T.length && _ && (n && Math.abs(t - _ / h) < .1 || Math.abs(T[0].pts - _ - y) < 20 * p), T.forEach((function (e) {
                e.pts = e.dts = m(e.pts - y, t * h)
              })), 0 !== (T = T.filter((function (e) {
                return e.pts >= 0
              }))).length) {
              if (r || (_ = n ? t * h : T[0].pts), e.isAAC)
                for (var A = this.config.maxAudioFramesDrift, R = 0, L = _; R < T.length;) {
                  var D, w = T[R];
                  if ((D = w.pts - L) <= -A * p) l.logger.warn("Dropping 1 audio frame @ " + F(L, !0) + " ms due to " + F(D, !0) + " ms overlap."), T.splice(R, 1);
                  else if (D >= A * p && D < N && L) {
                    var k = Math.round(D / p);
                    l.logger.warn("Injecting " + k + " audio frames @ " + F(L, !0) + " ms due to " + F(D, !0) + " ms gap.");
                    for (var O = 0; O < k; O++) {
                      var I = Math.max(L, 0);
                      (o = x.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (l.logger.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), o = w.unit.subarray()), T.splice(R, 0, {
                        unit: o,
                        pts: I,
                        dts: I
                      }), L += p, R++
                    }
                    w.pts = w.dts = L, L += p, R++
                  } else Math.abs(D), w.pts = w.dts = L, L += p, R++
                }
              for (var P = T.length, M = 0; P--;) M += T[P].unit.byteLength;
              for (var U = 0, B = T.length; U < B; U++) {
                var G = T[U],
                  j = G.unit,
                  K = G.pts;
                if (void 0 !== c) s.duration = Math.round((K - c) / v);
                else {
                  var H = K - _,
                    V = 0;
                  if (r && e.isAAC && H) {
                    if (H > 0 && H < N) V = Math.round((K - _) / p), l.logger.log(F(H, !0) + " ms hole between AAC samples detected,filling it"), V > 0 && ((o = x.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (o = j.subarray()), M += V * o.length);
                    else if (H < -12) {
                      l.logger.log("drop overlapping AAC sample, expected/parsed/delta: " + F(_, !0) + " ms / " + F(K, !0) + " ms / " + F(-H, !0) + " ms"), M -= j.byteLength;
                      continue
                    }
                    K = _
                  }
                  if (f = K, !(M > 0)) return;
                  M += b;
                  try {
                    d = new Uint8Array(M)
                  } catch (e) {
                    return void this.observer.trigger(i.default.ERROR, {
                      type: a.ErrorTypes.MUX_ERROR,
                      details: a.ErrorDetails.REMUX_ALLOC_ERROR,
                      fatal: !1,
                      bytes: M,
                      reason: "fail allocating audio mdat " + M
                    })
                  }
                  E || (new DataView(d.buffer).setUint32(0, M), d.set(C.types.mdat, 4));
                  for (var W = 0; W < V; W++)(o = x.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (l.logger.log("Unable to get silent frame for given audio codec; duplicating this frame instead."), o = j.subarray()), d.set(o, b), b += o.byteLength, s = {
                    size: o.byteLength,
                    cts: 0,
                    duration: 1024,
                    flags: {
                      isLeading: 0,
                      isDependedOn: 0,
                      hasRedundancy: 0,
                      degradPrio: 0,
                      dependsOn: 1
                    }
                  }, S.push(s)
                }
                d.set(j, b);
                var Y = j.byteLength;
                b += Y, s = {
                  size: Y,
                  cts: 0,
                  duration: 0,
                  flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: 1
                  }
                }, S.push(s), c = K
              }
              var z = 0;
              if ((P = S.length) >= 2 && (z = S[P - 2].duration, s.duration = z), P) {
                this.nextAudioPts = _ = c + v * z, e.samples = S, u = E ? new Uint8Array : C.moof(e.sequenceNumber++, f / v, e), e.samples = [];
                var X = f / h,
                  q = _ / h,
                  Q = {
                    data1: u,
                    data2: d,
                    startPTS: X,
                    endPTS: q,
                    startDTS: X,
                    endDTS: q,
                    type: "audio",
                    hasAudio: !0,
                    hasVideo: !1,
                    nb: P
                  };
                return this.observer.trigger(i.default.FRAG_PARSING_DATA, Q), Q
              }
              return null
            }
          }, t.remuxEmptyAudio = function (e, t, r, i) {
            var a = e.inputTimeScale,
              n = a / (e.samplerate ? e.samplerate : a),
              s = this.nextAudioPts,
              o = (void 0 !== s ? s : i.startDTS * a) + this._initDTS,
              d = i.endDTS * a + this._initDTS,
              u = 1024 * n,
              f = Math.ceil((d - o) / u),
              c = x.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
            if (l.logger.warn("remux empty Audio"), c) {
              for (var h = [], g = 0; g < f; g++) {
                var v = o + g * u;
                h.push({
                  unit: c,
                  pts: v,
                  dts: v
                })
              }
              e.samples = h, this.remuxAudio(e, t, r)
            } else l.logger.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!")
          }, t.remuxID3 = function (e) {
            var t = e.samples.length;
            if (t) {
              for (var r = e.inputTimeScale, a = this._initPTS, n = this._initDTS, s = 0; s < t; s++) {
                var o = e.samples[s];
                o.pts = (o.pts - a) / r, o.dts = (o.dts - n) / r
              }
              this.observer.trigger(i.default.FRAG_PARSING_METADATA, {
                samples: e.samples
              }), e.samples = []
            }
          }, t.remuxText = function (e) {
            e.samples.sort((function (e, t) {
              return e.pts - t.pts
            }));
            var t, r = e.samples.length,
              a = e.inputTimeScale,
              n = this._initPTS;
            if (r) {
              for (var s = 0; s < r; s++)(t = e.samples[s]).pts = (t.pts - n) / a;
              this.observer.trigger(i.default.FRAG_PARSING_USERDATA, {
                samples: e.samples
              })
            }
            e.samples = []
          }, t._PTSNormalize = function (e, t) {
            var r;
            if (void 0 === t) return e;
            for (r = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;) e += r;
            return e
          }, e
        }(),
        j = function () {
          function e(e) {
            this.observer = e
          }
          var t = e.prototype;
          return t.destroy = function () {}, t.resetTimeStamp = function () {}, t.resetInitSegment = function () {}, t.remux = function (e, t, r, a, n, s, o, l) {
            var d = this.observer,
              u = "";
            e && (u += "audio"), t && (u += "video"), d.trigger(i.default.FRAG_PARSING_DATA, {
              data1: l,
              startPTS: n,
              startDTS: n,
              type: u,
              hasAudio: !!e,
              hasVideo: !!t,
              nb: 1,
              dropped: 0
            }), d.trigger(i.default.FRAG_PARSED)
          }, e
        }(),
        K = Object(d.getSelfScope)();
      try {
        U = K.performance.now.bind(K.performance)
      } catch (e) {
        l.logger.debug("Unable to use Performance API on this environment"), U = K.Date.now
      }
      var H = function () {
        function e(e, t, r, i) {
          this.observer = e, this.typeSupported = t, this.config = r, this.vendor = i
        }
        var t = e.prototype;
        return t.destroy = function () {
          var e = this.demuxer;
          e && e.destroy()
        }, t.push = function (e, t, r, a, n, s, o, l, d, u, c, h) {
          var g = this;
          if (e.byteLength > 0 && null != t && null != t.key && "AES-128" === t.method) {
            var v = this.decrypter;
            null == v && (v = this.decrypter = new f(this.observer, this.config));
            var p = U();
            v.decrypt(e, t.key.buffer, t.iv.buffer, (function (e) {
              var f = U();
              g.observer.trigger(i.default.FRAG_DECRYPTED, {
                stats: {
                  tstart: p,
                  tdecrypt: f
                }
              }), g.pushDecrypted(new Uint8Array(e), t, new Uint8Array(r), a, n, s, o, l, d, u, c, h)
            }))
          } else this.pushDecrypted(new Uint8Array(e), t, new Uint8Array(r), a, n, s, o, l, d, u, c, h)
        }, t.pushDecrypted = function (e, t, r, n, s, o, l, d, u, f, c, h) {
          var g = this.demuxer;
          if (!g || (l || d) && !this.probe(e)) {
            for (var v = this.observer, p = this.typeSupported, m = this.config, y = [{
                demux: k,
                remux: G
              }, {
                demux: _.default,
                remux: j
              }, {
                demux: S,
                remux: G
              }, {
                demux: O,
                remux: G
              }], E = 0, b = y.length; E < b; E++) {
              var T = y[E],
                A = T.demux.probe;
              if (A(e)) {
                var R = this.remuxer = new T.remux(v, m, p, this.vendor);
                g = new T.demux(v, R, m, p), this.probe = A;
                break
              }
            }
            if (!g) return void v.trigger(i.default.ERROR, {
              type: a.ErrorTypes.MEDIA_ERROR,
              details: a.ErrorDetails.FRAG_PARSING_ERROR,
              fatal: !0,
              reason: "no demux matching with content found"
            });
            this.demuxer = g
          }
          var L = this.remuxer;
          (l || d) && (g.resetInitSegment(r, n, s, f), L.resetInitSegment()), l && (g.resetTimeStamp(h), L.resetTimeStamp(h)), "function" == typeof g.setDecryptData && g.setDecryptData(t), g.append(e, o, u, c)
        }, e
      }();
      t.default = H
    },
    "./src/demux/demuxer-worker.js": function (e, t, r) {
      "use strict";
      r.r(t);
      var i = r("./src/demux/demuxer-inline.js"),
        a = r("./src/events.js"),
        n = r("./src/utils/logger.js"),
        s = r("./node_modules/eventemitter3/index.js");
      r.n(s);
      t.default = function (e) {
        var t = new s.EventEmitter;
        t.trigger = function (e) {
          for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++) i[a - 1] = arguments[a];
          t.emit.apply(t, [e, e].concat(i))
        }, t.off = function (e) {
          for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++) i[a - 1] = arguments[a];
          t.removeListener.apply(t, [e].concat(i))
        };
        var r = function (t, r) {
          e.postMessage({
            event: t,
            data: r
          })
        };
        e.addEventListener("message", (function (a) {
          var s = a.data;
          switch (s.cmd) {
          case "init":
            var o = JSON.parse(s.config);
            e.demuxer = new i.default(t, s.typeSupported, o, s.vendor), Object(n.enableLogs)(o.debug), r("init", null);
            break;
          case "demux":
            e.demuxer.push(s.data, s.decryptdata, s.initSegment, s.audioCodec, s.videoCodec, s.timeOffset, s.discontinuity, s.trackSwitch, s.contiguous, s.duration, s.accurateTimeOffset, s.defaultInitPTS)
          }
        })), t.on(a.default.FRAG_DECRYPTED, r), t.on(a.default.FRAG_PARSING_INIT_SEGMENT, r), t.on(a.default.FRAG_PARSED, r), t.on(a.default.ERROR, r), t.on(a.default.FRAG_PARSING_METADATA, r), t.on(a.default.FRAG_PARSING_USERDATA, r), t.on(a.default.INIT_PTS_FOUND, r), t.on(a.default.FRAG_PARSING_DATA, (function (t, r) {
          var i = [],
            a = {
              event: t,
              data: r
            };
          r.data1 && (a.data1 = r.data1.buffer, i.push(r.data1.buffer), delete r.data1), r.data2 && (a.data2 = r.data2.buffer, i.push(r.data2.buffer), delete r.data2), e.postMessage(a, i)
        }))
      }
    },
    "./src/demux/id3.js": function (e, t, r) {
      "use strict";
      r.r(t), r.d(t, "utf8ArrayToStr", (function () {
        return o
      }));
      var i, a = r("./src/utils/get-self-scope.js"),
        n = function () {
          function e() {}
          return e.isHeader = function (e, t) {
            return t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
          }, e.isFooter = function (e, t) {
            return t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
          }, e.getID3Data = function (t, r) {
            for (var i = r, a = 0; e.isHeader(t, r);) {
              a += 10, a += e._readSize(t, r + 6), e.isFooter(t, r + 10) && (a += 10), r += a
            }
            if (a > 0) return t.subarray(i, i + a)
          }, e._readSize = function (e, t) {
            var r = 0;
            return r = (127 & e[t]) << 21, r |= (127 & e[t + 1]) << 14, r |= (127 & e[t + 2]) << 7, r |= 127 & e[t + 3]
          }, e.getTimeStamp = function (t) {
            for (var r = e.getID3Frames(t), i = 0; i < r.length; i++) {
              var a = r[i];
              if (e.isTimeStampFrame(a)) return e._readTimeStamp(a)
            }
          }, e.isTimeStampFrame = function (e) {
            return e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info
          }, e._getFrameData = function (t) {
            var r = String.fromCharCode(t[0], t[1], t[2], t[3]),
              i = e._readSize(t, 4);
            return {
              type: r,
              size: i,
              data: t.subarray(10, 10 + i)
            }
          }, e.getID3Frames = function (t) {
            for (var r = 0, i = []; e.isHeader(t, r);) {
              for (var a = e._readSize(t, r + 6), n = (r += 10) + a; r + 8 < n;) {
                var s = e._getFrameData(t.subarray(r)),
                  o = e._decodeFrame(s);
                o && i.push(o), r += s.size + 10
              }
              e.isFooter(t, r) && (r += 10)
            }
            return i
          }, e._decodeFrame = function (t) {
            return "PRIV" === t.type ? e._decodePrivFrame(t) : "T" === t.type[0] ? e._decodeTextFrame(t) : "W" === t.type[0] ? e._decodeURLFrame(t) : void 0
          }, e._readTimeStamp = function (e) {
            if (8 === e.data.byteLength) {
              var t = new Uint8Array(e.data),
                r = 1 & t[3],
                i = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];
              return i /= 45, r && (i += 47721858.84), Math.round(i)
            }
          }, e._decodePrivFrame = function (t) {
            if (!(t.size < 2)) {
              var r = e._utf8ArrayToStr(t.data, !0),
                i = new Uint8Array(t.data.subarray(r.length + 1));
              return {
                key: t.type,
                info: r,
                data: i.buffer
              }
            }
          }, e._decodeTextFrame = function (t) {
            if (!(t.size < 2)) {
              if ("TXXX" === t.type) {
                var r = 1,
                  i = e._utf8ArrayToStr(t.data.subarray(r), !0);
                r += i.length + 1;
                var a = e._utf8ArrayToStr(t.data.subarray(r));
                return {
                  key: t.type,
                  info: i,
                  data: a
                }
              }
              var n = e._utf8ArrayToStr(t.data.subarray(1));
              return {
                key: t.type,
                data: n
              }
            }
          }, e._decodeURLFrame = function (t) {
            if ("WXXX" === t.type) {
              if (t.size < 2) return;
              var r = 1,
                i = e._utf8ArrayToStr(t.data.subarray(r));
              r += i.length + 1;
              var a = e._utf8ArrayToStr(t.data.subarray(r));
              return {
                key: t.type,
                info: i,
                data: a
              }
            }
            var n = e._utf8ArrayToStr(t.data);
            return {
              key: t.type,
              data: n
            }
          }, e._utf8ArrayToStr = function (e, t) {
            void 0 === t && (t = !1);
            var r = s();
            if (r) {
              var i = r.decode(e);
              if (t) {
                var a = i.indexOf("\0");
                return -1 !== a ? i.substring(0, a) : i
              }
              return i.replace(/\0/g, "")
            }
            for (var n, o, l, d = e.length, u = "", f = 0; f < d;) {
              if (0 === (n = e[f++]) && t) return u;
              if (0 !== n && 3 !== n) switch (n >> 4) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
                u += String.fromCharCode(n);
                break;
              case 12:
              case 13:
                o = e[f++], u += String.fromCharCode((31 & n) << 6 | 63 & o);
                break;
              case 14:
                o = e[f++], l = e[f++], u += String.fromCharCode((15 & n) << 12 | (63 & o) << 6 | (63 & l) << 0)
              }
            }
            return u
          }, e
        }();

      function s() {
        var e = Object(a.getSelfScope)();
        return i || void 0 === e.TextDecoder || (i = new e.TextDecoder("utf-8")), i
      }
      var o = n._utf8ArrayToStr;
      t.default = n
    },
    "./src/demux/mp4demuxer.js": function (e, t, r) {
      "use strict";
      r.r(t);
      var i = r("./src/utils/logger.js"),
        a = r("./src/events.js"),
        n = Math.pow(2, 32) - 1,
        s = function () {
          function e(e, t) {
            this.observer = e, this.remuxer = t
          }
          var t = e.prototype;
          return t.resetTimeStamp = function (e) {
            this.initPTS = e
          }, t.resetInitSegment = function (t, r, i, n) {
            if (t && t.byteLength) {
              var s = this.initData = e.parseInitSegment(t);
              null == r && (r = "mp4a.40.5"), null == i && (i = "avc1.42e01e");
              var o = {};
              s.audio && s.video ? o.audiovideo = {
                container: "video/mp4",
                codec: r + "," + i,
                initSegment: n ? t : null
              } : (s.audio && (o.audio = {
                container: "audio/mp4",
                codec: r,
                initSegment: n ? t : null
              }), s.video && (o.video = {
                container: "video/mp4",
                codec: i,
                initSegment: n ? t : null
              })), this.observer.trigger(a.default.FRAG_PARSING_INIT_SEGMENT, {
                tracks: o
              })
            } else r && (this.audioCodec = r), i && (this.videoCodec = i)
          }, e.probe = function (t) {
            return e.findBox({
              data: t,
              start: 0,
              end: Math.min(t.length, 16384)
            }, ["moof"]).length > 0
          }, e.bin2str = function (e) {
            return String.fromCharCode.apply(null, e)
          }, e.readUint16 = function (e, t) {
            e.data && (t += e.start, e = e.data);
            var r = e[t] << 8 | e[t + 1];
            return r < 0 ? 65536 + r : r
          }, e.readUint32 = function (e, t) {
            e.data && (t += e.start, e = e.data);
            var r = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
            return r < 0 ? 4294967296 + r : r
          }, e.writeUint32 = function (e, t, r) {
            e.data && (t += e.start, e = e.data), e[t] = r >> 24, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = 255 & r
          }, e.findBox = function (t, r) {
            var i, a, n, s, o, l, d = [];
            if (t.data ? (o = t.start, n = t.end, t = t.data) : (o = 0, n = t.byteLength), !r.length) return null;
            for (i = o; i < n;) l = (a = e.readUint32(t, i)) > 1 ? i + a : n, e.bin2str(t.subarray(i + 4, i + 8)) === r[0] && (1 === r.length ? d.push({
              data: t,
              start: i + 8,
              end: l
            }) : (s = e.findBox({
              data: t,
              start: i + 8,
              end: l
            }, r.slice(1))).length && (d = d.concat(s))), i = l;
            return d
          }, e.parseSegmentIndex = function (t) {
            var r, i = e.findBox(t, ["moov"])[0],
              a = i ? i.end : null,
              n = 0,
              s = e.findBox(t, ["sidx"]);
            if (!s || !s[0]) return null;
            r = [];
            var o = (s = s[0]).data[0];
            n = 0 === o ? 8 : 16;
            var l = e.readUint32(s, n);
            n += 4;
            n += 0 === o ? 8 : 16, n += 2;
            var d = s.end + 0,
              u = e.readUint16(s, n);
            n += 2;
            for (var f = 0; f < u; f++) {
              var c = n,
                h = e.readUint32(s, c);
              c += 4;
              var g = 2147483647 & h;
              if (1 === (2147483648 & h) >>> 31) return void console.warn("SIDX has hierarchical references (not supported)");
              var v = e.readUint32(s, c);
              c += 4, r.push({
                referenceSize: g,
                subsegmentDuration: v,
                info: {
                  duration: v / l,
                  start: d,
                  end: d + g - 1
                }
              }), d += g, n = c += 4
            }
            return {
              earliestPresentationTime: 0,
              timescale: l,
              version: o,
              referencesCount: u,
              references: r,
              moovEndOffset: a
            }
          }, e.parseInitSegment = function (t) {
            var r = [];
            return e.findBox(t, ["moov", "trak"]).forEach((function (t) {
              var a = e.findBox(t, ["tkhd"])[0];
              if (a) {
                var n = a.data[a.start],
                  s = 0 === n ? 12 : 20,
                  o = e.readUint32(a, s),
                  l = e.findBox(t, ["mdia", "mdhd"])[0];
                if (l) {
                  s = 0 === (n = l.data[l.start]) ? 12 : 20;
                  var d = e.readUint32(l, s),
                    u = e.findBox(t, ["mdia", "hdlr"])[0];
                  if (u) {
                    var f = {
                      soun: "audio",
                      vide: "video"
                    } [e.bin2str(u.data.subarray(u.start + 8, u.start + 12))];
                    if (f) {
                      var c = e.findBox(t, ["mdia", "minf", "stbl", "stsd"]);
                      if (c.length) {
                        c = c[0];
                        var h = e.bin2str(c.data.subarray(c.start + 12, c.start + 16));
                        i.logger.log("MP4Demuxer:" + f + ":" + h + " found")
                      }
                      r[o] = {
                        timescale: d,
                        type: f
                      }, r[f] = {
                        timescale: d,
                        id: o
                      }
                    }
                  }
                }
              }
            })), r
          }, e.getStartDTS = function (t, r) {
            var i, a, n;
            return i = e.findBox(r, ["moof", "traf"]), a = [].concat.apply([], i.map((function (r) {
              return e.findBox(r, ["tfhd"]).map((function (i) {
                var a, n;
                return a = e.readUint32(i, 4), n = t[a].timescale || 9e4, e.findBox(r, ["tfdt"]).map((function (t) {
                  var r, i;
                  return r = t.data[t.start], i = e.readUint32(t, 4), 1 === r && (i *= Math.pow(2, 32), i += e.readUint32(t, 8)), i
                }))[0] / n
              }))
            }))), n = Math.min.apply(null, a), isFinite(n) ? n : 0
          }, e.offsetStartDTS = function (t, r, i) {
            e.findBox(r, ["moof", "traf"]).map((function (r) {
              return e.findBox(r, ["tfhd"]).map((function (a) {
                var s = e.readUint32(a, 4),
                  o = t[s].timescale || 9e4;
                e.findBox(r, ["tfdt"]).map((function (t) {
                  var r = t.data[t.start],
                    a = e.readUint32(t, 4);
                  if (0 === r) e.writeUint32(t, 4, a - i * o);
                  else {
                    a *= Math.pow(2, 32), a += e.readUint32(t, 8), a -= i * o, a = Math.max(a, 0);
                    var s = Math.floor(a / (n + 1)),
                      l = Math.floor(a % (n + 1));
                    e.writeUint32(t, 4, s), e.writeUint32(t, 8, l)
                  }
                }))
              }))
            }))
          }, t.append = function (t, r, i, n) {
            var s = this.initData;
            s || (this.resetInitSegment(t, this.audioCodec, this.videoCodec, !1), s = this.initData);
            var o, l = this.initPTS;
            if (void 0 === l) {
              var d = e.getStartDTS(s, t);
              this.initPTS = l = d - r, this.observer.trigger(a.default.INIT_PTS_FOUND, {
                initPTS: l
              })
            }
            e.offsetStartDTS(s, t, l), o = e.getStartDTS(s, t), this.remuxer.remux(s.audio, s.video, null, null, o, i, n, t)
          }, t.destroy = function () {}, e
        }();
      t.default = s
    },
    "./src/empty.js": function (e, t) {
      e.exports = void 0
    },
    "./src/errors.ts": function (e, t, r) {
      "use strict";
      var i, a;
      r.r(t), r.d(t, "ErrorTypes", (function () {
          return i
        })), r.d(t, "ErrorDetails", (function () {
          return a
        })),
        function (e) {
          e.NETWORK_ERROR = "networkError", e.MEDIA_ERROR = "mediaError", e.KEY_SYSTEM_ERROR = "keySystemError", e.MUX_ERROR = "muxError", e.OTHER_ERROR = "otherError"
        }(i || (i = {})),
        function (e) {
          e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e.KEY_SYSTEM_NO_INIT_DATA = "keySystemNoInitData", e.MANIFEST_LOAD_ERROR = "manifestLoadError", e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e.MANIFEST_PARSING_ERROR = "manifestParsingError", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e.LEVEL_EMPTY_ERROR = "levelEmptyError", e.LEVEL_LOAD_ERROR = "levelLoadError", e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e.LEVEL_SWITCH_ERROR = "levelSwitchError", e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e.FRAG_LOAD_ERROR = "fragLoadError", e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e.FRAG_DECRYPT_ERROR = "fragDecryptError", e.FRAG_PARSING_ERROR = "fragParsingError", e.REMUX_ALLOC_ERROR = "remuxAllocError", e.KEY_LOAD_ERROR = "keyLoadError", e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e.BUFFER_APPEND_ERROR = "bufferAppendError", e.BUFFER_APPENDING_ERROR = "bufferAppendingError", e.BUFFER_STALLED_ERROR = "bufferStalledError", e.BUFFER_FULL_ERROR = "bufferFullError", e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e.INTERNAL_EXCEPTION = "internalException"
        }(a || (a = {}))
    },
    "./src/events.js": function (e, t, r) {
      "use strict";
      r.r(t);
      t.default = {
        MEDIA_ATTACHING: "hlsMediaAttaching",
        MEDIA_ATTACHED: "hlsMediaAttached",
        MEDIA_DETACHING: "hlsMediaDetaching",
        MEDIA_DETACHED: "hlsMediaDetached",
        BUFFER_RESET: "hlsBufferReset",
        BUFFER_CODECS: "hlsBufferCodecs",
        BUFFER_CREATED: "hlsBufferCreated",
        BUFFER_APPENDING: "hlsBufferAppending",
        BUFFER_APPENDED: "hlsBufferAppended",
        BUFFER_EOS: "hlsBufferEos",
        BUFFER_FLUSHING: "hlsBufferFlushing",
        BUFFER_FLUSHED: "hlsBufferFlushed",
        MANIFEST_LOADING: "hlsManifestLoading",
        MANIFEST_LOADED: "hlsManifestLoaded",
        MANIFEST_PARSED: "hlsManifestParsed",
        LEVEL_SWITCHING: "hlsLevelSwitching",
        LEVEL_SWITCHED: "hlsLevelSwitched",
        LEVEL_LOADING: "hlsLevelLoading",
        LEVEL_LOADED: "hlsLevelLoaded",
        LEVEL_UPDATED: "hlsLevelUpdated",
        LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated",
        LEVELS_UPDATED: "hlsLevelsUpdated",
        AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated",
        AUDIO_TRACK_SWITCHING: "hlsAudioTrackSwitching",
        AUDIO_TRACK_SWITCHED: "hlsAudioTrackSwitched",
        AUDIO_TRACK_LOADING: "hlsAudioTrackLoading",
        AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded",
        SUBTITLE_TRACKS_UPDATED: "hlsSubtitleTracksUpdated",
        SUBTITLE_TRACK_SWITCH: "hlsSubtitleTrackSwitch",
        SUBTITLE_TRACK_LOADING: "hlsSubtitleTrackLoading",
        SUBTITLE_TRACK_LOADED: "hlsSubtitleTrackLoaded",
        SUBTITLE_FRAG_PROCESSED: "hlsSubtitleFragProcessed",
        CUES_PARSED: "hlsCuesParsed",
        NON_NATIVE_TEXT_TRACKS_FOUND: "hlsNonNativeTextTracksFound",
        INIT_PTS_FOUND: "hlsInitPtsFound",
        FRAG_LOADING: "hlsFragLoading",
        FRAG_LOAD_PROGRESS: "hlsFragLoadProgress",
        FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted",
        FRAG_LOADED: "hlsFragLoaded",
        FRAG_DECRYPTED: "hlsFragDecrypted",
        FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment",
        FRAG_PARSING_USERDATA: "hlsFragParsingUserdata",
        FRAG_PARSING_METADATA: "hlsFragParsingMetadata",
        FRAG_PARSING_DATA: "hlsFragParsingData",
        FRAG_PARSED: "hlsFragParsed",
        FRAG_BUFFERED: "hlsFragBuffered",
        FRAG_CHANGED: "hlsFragChanged",
        FPS_DROP: "hlsFpsDrop",
        FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping",
        ERROR: "hlsError",
        DESTROYING: "hlsDestroying",
        KEY_LOADING: "hlsKeyLoading",
        KEY_LOADED: "hlsKeyLoaded",
        STREAM_STATE_TRANSITION: "hlsStreamStateTransition",
        LIVE_BACK_BUFFER_REACHED: "hlsLiveBackBufferReached"
      }
    },
    "./src/hls.ts": function (e, t, r) {
      "use strict";
      r.r(t), r.d(t, "default", (function () {
        return et
      }));
      var i, a, n = r("./node_modules/url-toolkit/src/url-toolkit.js"),
        s = r("./src/errors.ts"),
        o = r("./src/polyfills/number-isFinite.js"),
        l = r("./src/events.js"),
        d = r("./src/utils/logger.js"),
        u = {
          hlsEventGeneric: !0,
          hlsHandlerDestroying: !0,
          hlsHandlerDestroyed: !0
        },
        f = function () {
          function e(e) {
            this.hls = void 0, this.handledEvents = void 0, this.useGenericHandler = void 0, this.hls = e, this.onEvent = this.onEvent.bind(this);
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) r[i - 1] = arguments[i];
            this.handledEvents = r, this.useGenericHandler = !0, this.registerListeners()
          }
          var t = e.prototype;
          return t.destroy = function () {
            this.onHandlerDestroying(), this.unregisterListeners(), this.onHandlerDestroyed()
          }, t.onHandlerDestroying = function () {}, t.onHandlerDestroyed = function () {}, t.isEventHandler = function () {
            return "object" == typeof this.handledEvents && this.handledEvents.length && "function" == typeof this.onEvent
          }, t.registerListeners = function () {
            this.isEventHandler() && this.handledEvents.forEach((function (e) {
              if (u[e]) throw new Error("Forbidden event-name: " + e);
              this.hls.on(e, this.onEvent)
            }), this)
          }, t.unregisterListeners = function () {
            this.isEventHandler() && this.handledEvents.forEach((function (e) {
              this.hls.off(e, this.onEvent)
            }), this)
          }, t.onEvent = function (e, t) {
            this.onEventGeneric(e, t)
          }, t.onEventGeneric = function (e, t) {
            try {
              (function (e, t) {
                var r = "on" + e.replace("hls", "");
                if ("function" != typeof this[r]) throw new Error("Event " + e + " has no generic handler in this " + this.constructor.name + " class (tried " + r + ")");
                return this[r].bind(this, t)
              }).call(this, e, t).call()
            } catch (t) {
              d.logger.error("An internal error happened while handling event " + e + '. Error message: "' + t.message + '". Here is a stacktrace:', t), this.hls.trigger(l.default.ERROR, {
                type: s.ErrorTypes.OTHER_ERROR,
                details: s.ErrorDetails.INTERNAL_EXCEPTION,
                fatal: !1,
                event: e,
                err: t
              })
            }
          }, e
        }();
      ! function (e) {
        e.MANIFEST = "manifest", e.LEVEL = "level", e.AUDIO_TRACK = "audioTrack", e.SUBTITLE_TRACK = "subtitleTrack"
      }(i || (i = {})),
      function (e) {
        e.MAIN = "main", e.AUDIO = "audio", e.SUBTITLE = "subtitle"
      }(a || (a = {}));
      var c = r("./src/demux/mp4demuxer.js");

      function h(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
      }
      var g, v = function () {
        function e(e, t) {
          this._uri = null, this.baseuri = void 0, this.reluri = void 0, this.method = null, this.key = null, this.iv = null, this.baseuri = e, this.reluri = t
        }
        var t, r, i;
        return t = e, (r = [{
          key: "uri",
          get: function () {
            return !this._uri && this.reluri && (this._uri = Object(n.buildAbsoluteURL)(this.baseuri, this.reluri, {
              alwaysNormalize: !0
            })), this._uri
          }
        }]) && h(t.prototype, r), i && h(t, i), e
      }();

      function p(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
      }! function (e) {
        e.AUDIO = "audio", e.VIDEO = "video"
      }(g || (g = {}));
      var m = function () {
        function e() {
          var e;
          this._url = null, this._byteRange = null, this._decryptdata = null, this._elementaryStreams = ((e = {})[g.AUDIO] = !1, e[g.VIDEO] = !1, e), this.deltaPTS = 0, this.rawProgramDateTime = null, this.programDateTime = null, this.title = null, this.tagList = [], this.cc = void 0, this.type = void 0, this.relurl = void 0, this.baseurl = void 0, this.duration = void 0, this.start = void 0, this.sn = 0, this.urlId = 0, this.level = 0, this.levelkey = void 0, this.loader = void 0
        }
        var t, r, i, a = e.prototype;
        return a.setByteRange = function (e, t) {
          var r = e.split("@", 2),
            i = [];
          1 === r.length ? i[0] = t ? t.byteRangeEndOffset : 0 : i[0] = parseInt(r[1]), i[1] = parseInt(r[0]) + i[0], this._byteRange = i
        }, a.addElementaryStream = function (e) {
          this._elementaryStreams[e] = !0
        }, a.hasElementaryStream = function (e) {
          return !0 === this._elementaryStreams[e]
        }, a.createInitializationVector = function (e) {
          for (var t = new Uint8Array(16), r = 12; r < 16; r++) t[r] = e >> 8 * (15 - r) & 255;
          return t
        }, a.setDecryptDataFromLevelKey = function (e, t) {
          var r = e;
          return (null == e ? void 0 : e.method) && e.uri && !e.iv && ((r = new v(e.baseuri, e.reluri)).method = e.method, r.iv = this.createInitializationVector(t)), r
        }, t = e, (r = [{
          key: "url",
          get: function () {
            return !this._url && this.relurl && (this._url = Object(n.buildAbsoluteURL)(this.baseurl, this.relurl, {
              alwaysNormalize: !0
            })), this._url
          },
          set: function (e) {
            this._url = e
          }
        }, {
          key: "byteRange",
          get: function () {
            return this._byteRange ? this._byteRange : []
          }
        }, {
          key: "byteRangeStartOffset",
          get: function () {
            return this.byteRange[0]
          }
        }, {
          key: "byteRangeEndOffset",
          get: function () {
            return this.byteRange[1]
          }
        }, {
          key: "decryptdata",
          get: function () {
            if (!this.levelkey && !this._decryptdata) return null;
            if (!this._decryptdata && this.levelkey) {
              var e = this.sn;
              "number" != typeof e && (this.levelkey && "AES-128" === this.levelkey.method && !this.levelkey.iv && d.logger.warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue'), e = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, e)
            }
            return this._decryptdata
          }
        }, {
          key: "endProgramDateTime",
          get: function () {
            if (null === this.programDateTime) return null;
            if (!Object(o.isFiniteNumber)(this.programDateTime)) return null;
            var e = Object(o.isFiniteNumber)(this.duration) ? this.duration : 0;
            return this.programDateTime + 1e3 * e
          }
        }, {
          key: "encrypted",
          get: function () {
            return !(!this.decryptdata || null === this.decryptdata.uri || null !== this.decryptdata.key)
          }
        }]) && p(t.prototype, r), i && p(t, i), e
      }();

      function y(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
      }
      var E = function () {
          function e(e) {
            this.endCC = 0, this.endSN = 0, this.fragments = [], this.initSegment = null, this.live = !0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = e, this.version = null
          }
          var t, r, i;
          return t = e, (r = [{
            key: "hasProgramDateTime",
            get: function () {
              return !(!this.fragments[0] || !Object(o.isFiniteNumber)(this.fragments[0].programDateTime))
            }
          }]) && y(t.prototype, r), i && y(t, i), e
        }(),
        b = /^(\d+)x(\d+)$/,
        T = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g,
        S = function () {
          function e(t) {
            for (var r in "string" == typeof t && (t = e.parseAttrList(t)), t) t.hasOwnProperty(r) && (this[r] = t[r])
          }
          var t = e.prototype;
          return t.decimalInteger = function (e) {
            var t = parseInt(this[e], 10);
            return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
          }, t.hexadecimalInteger = function (e) {
            if (this[e]) {
              var t = (this[e] || "0x").slice(2);
              t = (1 & t.length ? "0" : "") + t;
              for (var r = new Uint8Array(t.length / 2), i = 0; i < t.length / 2; i++) r[i] = parseInt(t.slice(2 * i, 2 * i + 2), 16);
              return r
            }
            return null
          }, t.hexadecimalIntegerAsNumber = function (e) {
            var t = parseInt(this[e], 16);
            return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
          }, t.decimalFloatingPoint = function (e) {
            return parseFloat(this[e])
          }, t.enumeratedString = function (e) {
            return this[e]
          }, t.decimalResolution = function (e) {
            var t = b.exec(this[e]);
            if (null !== t) return {
              width: parseInt(t[1], 10),
              height: parseInt(t[2], 10)
            }
          }, e.parseAttrList = function (e) {
            var t, r = {};
            for (T.lastIndex = 0; null !== (t = T.exec(e));) {
              var i = t[2];
              0 === i.indexOf('"') && i.lastIndexOf('"') === i.length - 1 && (i = i.slice(1, -1)), r[t[1]] = i
            }
            return r
          }, e
        }(),
        _ = {
          audio: {
            a3ds: !0,
            "ac-3": !0,
            "ac-4": !0,
            alac: !0,
            alaw: !0,
            dra1: !0,
            "dts+": !0,
            "dts-": !0,
            dtsc: !0,
            dtse: !0,
            dtsh: !0,
            "ec-3": !0,
            enca: !0,
            g719: !0,
            g726: !0,
            m4ae: !0,
            mha1: !0,
            mha2: !0,
            mhm1: !0,
            mhm2: !0,
            mlpa: !0,
            mp4a: !0,
            "raw ": !0,
            Opus: !0,
            samr: !0,
            sawb: !0,
            sawp: !0,
            sevc: !0,
            sqcp: !0,
            ssmv: !0,
            twos: !0,
            ulaw: !0
          },
          video: {
            avc1: !0,
            avc2: !0,
            avc3: !0,
            avc4: !0,
            avcp: !0,
            drac: !0,
            dvav: !0,
            dvhe: !0,
            encv: !0,
            hev1: !0,
            hvc1: !0,
            mjp2: !0,
            mp4v: !0,
            mvc1: !0,
            mvc2: !0,
            mvc3: !0,
            mvc4: !0,
            resv: !0,
            rv60: !0,
            s263: !0,
            svc1: !0,
            svc2: !0,
            "vc-1": !0,
            vp08: !0,
            vp09: !0
          }
        };

      function A(e, t) {
        return MediaSource.isTypeSupported((t || "video") + '/mp4;codecs="' + e + '"')
      }
      var R = /(?:#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)|#EXT-X-SESSION-DATA:([^\n\r]*)[\r\n]+)/g,
        L = /#EXT-X-MEDIA:(.*)/g,
        D = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /|(?!#)([\S+ ?]+)/.source, /|#EXT-X-BYTERANGE:*(.+)/.source, /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /|#.*/.source].join(""), "g"),
        w = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/,
        k = /\.(mp4|m4s|m4v|m4a)$/i,
        O = function () {
          function e() {}
          return e.findGroup = function (e, t) {
            for (var r = 0; r < e.length; r++) {
              var i = e[r];
              if (i.id === t) return i
            }
          }, e.convertAVC1ToAVCOTI = function (e) {
            var t, r = e.split(".");
            return r.length > 2 ? (t = r.shift() + ".", t += parseInt(r.shift()).toString(16), t += ("000" + parseInt(r.shift()).toString(16)).substr(-4)) : t = e, t
          }, e.resolve = function (e, t) {
            return n.buildAbsoluteURL(t, e, {
              alwaysNormalize: !0
            })
          }, e.parseMasterPlaylist = function (t, r) {
            var i, a = [],
              n = {},
              s = !1;

            function o(e, t) {
              ["video", "audio"].forEach((function (r) {
                var i = e.filter((function (e) {
                  return function (e, t) {
                    var r = _[t];
                    return !!r && !0 === r[e.slice(0, 4)]
                  }(e, r)
                }));
                if (i.length) {
                  var a = i.filter((function (e) {
                    return 0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0)
                  }));
                  t[r + "Codec"] = a.length > 0 ? a[0] : i[0], e = e.filter((function (e) {
                    return -1 === i.indexOf(e)
                  }))
                }
              })), t.unknownCodecs = e
            }
            for (R.lastIndex = 0; null != (i = R.exec(t));)
              if (i[1]) {
                var l = {},
                  d = l.attrs = new S(i[1]);
                l.url = e.resolve(i[2], r);
                var u = d.decimalResolution("RESOLUTION");
                u && (l.width = u.width, l.height = u.height), l.bitrate = d.decimalInteger("AVERAGE-BANDWIDTH") || d.decimalInteger("BANDWIDTH"), l.name = d.NAME, o([].concat((d.CODECS || "").split(/[ ,]+/)), l), l.videoCodec && -1 !== l.videoCodec.indexOf("avc1") && (l.videoCodec = e.convertAVC1ToAVCOTI(l.videoCodec)), a.push(l)
              } else if (i[3]) {
              var f = new S(i[3]);
              f["DATA-ID"] && (s = !0, n[f["DATA-ID"]] = f)
            }
            return {
              levels: a,
              sessionData: s ? n : null
            }
          }, e.parseMasterPlaylistMedia = function (t, r, i, a) {
            var n;
            void 0 === a && (a = []);
            var s = [],
              o = 0;
            for (L.lastIndex = 0; null !== (n = L.exec(t));) {
              var l = new S(n[1]);
              if (l.TYPE === i) {
                var d = {
                  attrs: l,
                  id: o++,
                  groupId: l["GROUP-ID"],
                  instreamId: l["INSTREAM-ID"],
                  name: l.NAME || l.LANGUAGE,
                  type: i,
                  default: "YES" === l.DEFAULT,
                  autoselect: "YES" === l.AUTOSELECT,
                  forced: "YES" === l.FORCED,
                  lang: l.LANGUAGE
                };
                if (l.URI && (d.url = e.resolve(l.URI, r)), a.length) {
                  var u = e.findGroup(a, d.groupId);
                  d.audioCodec = u ? u.codec : a[0].codec
                }
                s.push(d)
              }
            }
            return s
          }, e.parseLevelPlaylist = function (e, t, r, i, a) {
            var n, s, l, u = 0,
              f = 0,
              c = new E(t),
              h = 0,
              g = null,
              p = new m,
              y = null;
            for (D.lastIndex = 0; null !== (n = D.exec(e));) {
              var b = n[1];
              if (b) {
                p.duration = parseFloat(b);
                var T = (" " + n[2]).slice(1);
                p.title = T || null, p.tagList.push(T ? ["INF", b, T] : ["INF", b])
              } else if (n[3]) {
                if (Object(o.isFiniteNumber)(p.duration)) {
                  var _ = u++;
                  p.type = i, p.start = f, l && (p.levelkey = l), p.sn = _, p.level = r, p.cc = h, p.urlId = a, p.baseurl = t, p.relurl = (" " + n[3]).slice(1), x(p, g), c.fragments.push(p), g = p, f += p.duration, p = new m
                }
              } else if (n[4]) {
                var A = (" " + n[4]).slice(1);
                g ? p.setByteRange(A, g) : p.setByteRange(A)
              } else if (n[5]) p.rawProgramDateTime = (" " + n[5]).slice(1), p.tagList.push(["PROGRAM-DATE-TIME", p.rawProgramDateTime]), null === y && (y = c.fragments.length);
              else {
                if (!(n = n[0].match(w))) {
                  d.logger.warn("No matches on slow regex match for level playlist!");
                  continue
                }
                for (s = 1; s < n.length && void 0 === n[s]; s++);
                var R = (" " + n[s + 1]).slice(1),
                  L = (" " + n[s + 2]).slice(1);
                switch (n[s]) {
                case "#":
                  p.tagList.push(L ? [R, L] : [R]);
                  break;
                case "PLAYLIST-TYPE":
                  c.type = R.toUpperCase();
                  break;
                case "MEDIA-SEQUENCE":
                  u = c.startSN = parseInt(R);
                  break;
                case "TARGETDURATION":
                  c.targetduration = parseFloat(R);
                  break;
                case "VERSION":
                  c.version = parseInt(R);
                  break;
                case "EXTM3U":
                  break;
                case "ENDLIST":
                  c.live = !1;
                  break;
                case "DIS":
                  h++, p.tagList.push(["DIS"]);
                  break;
                case "DISCONTINUITY-SEQ":
                  h = parseInt(R);
                  break;
                case "KEY":
                  var O = new S(R),
                    I = O.enumeratedString("METHOD"),
                    C = O.URI,
                    P = O.hexadecimalInteger("IV");
                  if ("com.apple.streamingkeydelivery" === (O.KEYFORMAT || "identity")) {
                    d.logger.warn("Keyformat com.apple.streamingkeydelivery is not supported");
                    continue
                  }
                  I && (l = new v(t, C), C && ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(I) >= 0 && (l.method = I, l.key = null, l.iv = P));
                  break;
                case "START":
                  var F = new S(R).decimalFloatingPoint("TIME-OFFSET");
                  Object(o.isFiniteNumber)(F) && (c.startTimeOffset = F);
                  break;
                case "MAP":
                  var M = new S(R);
                  p.relurl = M.URI, M.BYTERANGE && p.setByteRange(M.BYTERANGE), p.baseurl = t, p.level = r, p.type = i, p.sn = "initSegment", c.initSegment = p, (p = new m).rawProgramDateTime = c.initSegment.rawProgramDateTime;
                  break;
                default:
                  d.logger.warn("line parsed but not handled: " + n)
                }
              }
            }
            return (p = g) && !p.relurl && (c.fragments.pop(), f -= p.duration), c.totalduration = f, c.averagetargetduration = f / c.fragments.length, c.endSN = u - 1, c.startCC = c.fragments[0] ? c.fragments[0].cc : 0, c.endCC = h, !c.initSegment && c.fragments.length && c.fragments.every((function (e) {
              return k.test(e.relurl)
            })) && (d.logger.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"), (p = new m).relurl = c.fragments[0].relurl, p.baseurl = t, p.level = r, p.type = i, p.sn = "initSegment", c.initSegment = p, c.needSidxRanges = !0), y && function (e, t) {
              for (var r = e[t], i = t - 1; i >= 0; i--) {
                var a = e[i];
                a.programDateTime = r.programDateTime - 1e3 * a.duration, r = a
              }
            }(c.fragments, y), c
          }, e
        }();

      function x(e, t) {
        e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : (null == t ? void 0 : t.programDateTime) && (e.programDateTime = t.endProgramDateTime), Object(o.isFiniteNumber)(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null)
      }
      var I = window.performance,
        C = function (e) {
          var t, r;

          function n(t) {
            var r;
            return (r = e.call(this, t, l.default.MANIFEST_LOADING, l.default.LEVEL_LOADING, l.default.AUDIO_TRACK_LOADING, l.default.SUBTITLE_TRACK_LOADING) || this).loaders = {}, r
          }
          r = e, (t = n).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, n.canHaveQualityLevels = function (e) {
            return e !== i.AUDIO_TRACK && e !== i.SUBTITLE_TRACK
          }, n.mapContextToLevelType = function (e) {
            switch (e.type) {
            case i.AUDIO_TRACK:
              return a.AUDIO;
            case i.SUBTITLE_TRACK:
              return a.SUBTITLE;
            default:
              return a.MAIN
            }
          }, n.getResponseUrl = function (e, t) {
            var r = e.url;
            return void 0 !== r && 0 !== r.indexOf("data:") || (r = t.url), r
          };
          var u = n.prototype;
          return u.createInternalLoader = function (e) {
            var t = this.hls.config,
              r = t.pLoader,
              i = t.loader,
              a = new(r || i)(t);
            return e.loader = a, this.loaders[e.type] = a, a
          }, u.getInternalLoader = function (e) {
            return this.loaders[e.type]
          }, u.resetInternalLoader = function (e) {
            this.loaders[e] && delete this.loaders[e]
          }, u.destroyInternalLoaders = function () {
            for (var e in this.loaders) {
              var t = this.loaders[e];
              t && t.destroy(), this.resetInternalLoader(e)
            }
          }, u.destroy = function () {
            this.destroyInternalLoaders(), e.prototype.destroy.call(this)
          }, u.onManifestLoading = function (e) {
            this.load({
              url: e.url,
              type: i.MANIFEST,
              level: 0,
              id: null,
              responseType: "text"
            })
          }, u.onLevelLoading = function (e) {
            this.load({
              url: e.url,
              type: i.LEVEL,
              level: e.level,
              id: e.id,
              responseType: "text"
            })
          }, u.onAudioTrackLoading = function (e) {
            this.load({
              url: e.url,
              type: i.AUDIO_TRACK,
              level: null,
              id: e.id,
              responseType: "text"
            })
          }, u.onSubtitleTrackLoading = function (e) {
            this.load({
              url: e.url,
              type: i.SUBTITLE_TRACK,
              level: null,
              id: e.id,
              responseType: "text"
            })
          }, u.load = function (e) {
            var t = this.hls.config;
            d.logger.debug("Loading playlist of type " + e.type + ", level: " + e.level + ", id: " + e.id);
            var r, a, n, s, o = this.getInternalLoader(e);
            if (o) {
              var l = o.context;
              if (l && l.url === e.url) return d.logger.trace("playlist request ongoing"), !1;
              d.logger.warn("aborting previous loader for type: " + e.type), o.abort()
            }
            switch (e.type) {
            case i.MANIFEST:
              r = t.manifestLoadingMaxRetry, a = t.manifestLoadingTimeOut, n = t.manifestLoadingRetryDelay, s = t.manifestLoadingMaxRetryTimeout;
              break;
            case i.LEVEL:
              r = 0, s = 0, n = 0, a = t.levelLoadingTimeOut;
              break;
            default:
              r = t.levelLoadingMaxRetry, a = t.levelLoadingTimeOut, n = t.levelLoadingRetryDelay, s = t.levelLoadingMaxRetryTimeout
            }
            o = this.createInternalLoader(e);
            var u = {
                timeout: a,
                maxRetry: r,
                retryDelay: n,
                maxRetryDelay: s
              },
              f = {
                onSuccess: this.loadsuccess.bind(this),
                onError: this.loaderror.bind(this),
                onTimeout: this.loadtimeout.bind(this)
              };
            return d.logger.debug("Calling internal loader delegate for URL: " + e.url), o.load(e, u, f), !0
          }, u.loadsuccess = function (e, t, r, i) {
            if (void 0 === i && (i = null), r.isSidxRequest) return this._handleSidxRequest(e, r), void this._handlePlaylistLoaded(e, t, r, i);
            if (this.resetInternalLoader(r.type), "string" != typeof e.data) throw new Error('expected responseType of "text" for PlaylistLoader');
            var a = e.data;
            t.tload = I.now(), 0 === a.indexOf("#EXTM3U") ? a.indexOf("#EXTINF:") > 0 || a.indexOf("#EXT-X-TARGETDURATION:") > 0 ? this._handleTrackOrLevelPlaylist(e, t, r, i) : this._handleMasterPlaylist(e, t, r, i) : this._handleManifestParsingError(e, r, "no EXTM3U delimiter", i)
          }, u.loaderror = function (e, t, r) {
            void 0 === r && (r = null), this._handleNetworkError(t, r, !1, e)
          }, u.loadtimeout = function (e, t, r) {
            void 0 === r && (r = null), this._handleNetworkError(t, r, !0)
          }, u._handleMasterPlaylist = function (e, t, r, i) {
            var a = this.hls,
              s = e.data,
              o = n.getResponseUrl(e, r),
              u = O.parseMasterPlaylist(s, o),
              f = u.levels,
              c = u.sessionData;
            if (f.length) {
              var h = f.map((function (e) {
                  return {
                    id: e.attrs.AUDIO,
                    codec: e.audioCodec
                  }
                })),
                g = O.parseMasterPlaylistMedia(s, o, "AUDIO", h),
                v = O.parseMasterPlaylistMedia(s, o, "SUBTITLES"),
                p = O.parseMasterPlaylistMedia(s, o, "CLOSED-CAPTIONS");
              if (g.length) {
                var m = !1;
                g.forEach((function (e) {
                  e.url || (m = !0)
                })), !1 === m && f[0].audioCodec && !f[0].attrs.AUDIO && (d.logger.log("audio codec signaled in quality level, but no embedded audio track signaled, create one"), g.unshift({
                  type: "main",
                  name: "main",
                  default: !1,
                  autoselect: !1,
                  forced: !1,
                  id: -1,
                  attrs: {},
                  url: ""
                }))
              }
              a.trigger(l.default.MANIFEST_LOADED, {
                levels: f,
                audioTracks: g,
                subtitles: v,
                captions: p,
                url: o,
                stats: t,
                networkDetails: i,
                sessionData: c
              })
            } else this._handleManifestParsingError(e, r, "no level found in manifest", i)
          }, u._handleTrackOrLevelPlaylist = function (e, t, r, a) {
            var d = this.hls,
              u = r.id,
              f = r.level,
              c = r.type,
              h = n.getResponseUrl(e, r),
              g = Object(o.isFiniteNumber)(u) ? u : 0,
              v = Object(o.isFiniteNumber)(f) ? f : g,
              p = n.mapContextToLevelType(r),
              m = O.parseLevelPlaylist(e.data, h, v, p, g);
            if (m.tload = t.tload, m.fragments.length) {
              if (c === i.MANIFEST) {
                var y = {
                  url: h,
                  details: m
                };
                d.trigger(l.default.MANIFEST_LOADED, {
                  levels: [y],
                  audioTracks: [],
                  url: h,
                  stats: t,
                  networkDetails: a,
                  sessionData: null
                })
              }
              if (t.tparsed = I.now(), m.needSidxRanges) {
                var E = m.initSegment.url;
                this.load({
                  url: E,
                  isSidxRequest: !0,
                  type: c,
                  level: f,
                  levelDetails: m,
                  id: u,
                  rangeStart: 0,
                  rangeEnd: 2048,
                  responseType: "arraybuffer"
                })
              } else r.levelDetails = m, this._handlePlaylistLoaded(e, t, r, a)
            } else d.trigger(l.default.ERROR, {
              type: s.ErrorTypes.NETWORK_ERROR,
              details: s.ErrorDetails.LEVEL_EMPTY_ERROR,
              fatal: !1,
              url: h,
              reason: "no fragments found in level",
              level: "number" == typeof r.level ? r.level : void 0
            })
          }, u._handleSidxRequest = function (e, t) {
            if ("string" == typeof e.data) throw new Error("sidx request must be made with responseType of array buffer");
            var r = c.default.parseSegmentIndex(new Uint8Array(e.data));
            if (r) {
              var i = r.references,
                a = t.levelDetails;
              i.forEach((function (e, t) {
                var r = e.info;
                if (a) {
                  var i = a.fragments[t];
                  0 === i.byteRange.length && i.setByteRange(String(1 + r.end - r.start) + "@" + String(r.start))
                }
              })), a && a.initSegment.setByteRange(String(r.moovEndOffset) + "@0")
            }
          }, u._handleManifestParsingError = function (e, t, r, i) {
            this.hls.trigger(l.default.ERROR, {
              type: s.ErrorTypes.NETWORK_ERROR,
              details: s.ErrorDetails.MANIFEST_PARSING_ERROR,
              fatal: !0,
              url: e.url,
              reason: r,
              networkDetails: i
            })
          }, u._handleNetworkError = function (e, t, r, a) {
            var n, o;
            void 0 === r && (r = !1), void 0 === a && (a = null), d.logger.info("A network error occured while loading a " + e.type + "-type playlist");
            var u = this.getInternalLoader(e);
            switch (e.type) {
            case i.MANIFEST:
              n = r ? s.ErrorDetails.MANIFEST_LOAD_TIMEOUT : s.ErrorDetails.MANIFEST_LOAD_ERROR, o = !0;
              break;
            case i.LEVEL:
              n = r ? s.ErrorDetails.LEVEL_LOAD_TIMEOUT : s.ErrorDetails.LEVEL_LOAD_ERROR, o = !1;
              break;
            case i.AUDIO_TRACK:
              n = r ? s.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : s.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, o = !1;
              break;
            default:
              o = !1
            }
            u && (u.abort(), this.resetInternalLoader(e.type));
            var f = {
              type: s.ErrorTypes.NETWORK_ERROR,
              details: n,
              fatal: o,
              url: e.url,
              loader: u,
              context: e,
              networkDetails: t
            };
            a && (f.response = a), this.hls.trigger(l.default.ERROR, f)
          }, u._handlePlaylistLoaded = function (e, t, r, a) {
            var s = r.type,
              o = r.level,
              d = r.id,
              u = r.levelDetails;
            if (u && u.targetduration)
              if (n.canHaveQualityLevels(r.type)) this.hls.trigger(l.default.LEVEL_LOADED, {
                details: u,
                level: o || 0,
                id: d || 0,
                stats: t,
                networkDetails: a
              });
              else switch (s) {
              case i.AUDIO_TRACK:
                this.hls.trigger(l.default.AUDIO_TRACK_LOADED, {
                  details: u,
                  id: d,
                  stats: t,
                  networkDetails: a
                });
                break;
              case i.SUBTITLE_TRACK:
                this.hls.trigger(l.default.SUBTITLE_TRACK_LOADED, {
                  details: u,
                  id: d,
                  stats: t,
                  networkDetails: a
                })
              } else this._handleManifestParsingError(e, r, "invalid target duration", a)
          }, n
        }(f);
      var P = function (e) {
        var t, r;

        function i(t) {
          var r;
          return (r = e.call(this, t, l.default.FRAG_LOADING) || this).loaders = {}, r
        }
        r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
        var a = i.prototype;
        return a.destroy = function () {
          var t = this.loaders;
          for (var r in t) {
            var i = t[r];
            i && i.destroy()
          }
          this.loaders = {}, e.prototype.destroy.call(this)
        }, a.onFragLoading = function (e) {
          var t = e.frag,
            r = t.type,
            i = this.loaders,
            a = this.hls.config,
            n = a.fLoader,
            s = a.loader;
          t.loaded = 0;
          var l, u, f, c = i[r];
          c && (d.logger.warn("abort previous fragment loader for type: " + r), c.abort()), c = i[r] = t.loader = a.fLoader ? new n(a) : new s(a), l = {
            url: t.url,
            frag: t,
            responseType: "arraybuffer",
            progressData: !1
          };
          var h = t.byteRangeStartOffset,
            g = t.byteRangeEndOffset;
          Object(o.isFiniteNumber)(h) && Object(o.isFiniteNumber)(g) && (l.rangeStart = h, l.rangeEnd = g), u = {
            timeout: a.fragLoadingTimeOut,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: a.fragLoadingMaxRetryTimeout
          }, f = {
            onSuccess: this.loadsuccess.bind(this),
            onError: this.loaderror.bind(this),
            onTimeout: this.loadtimeout.bind(this),
            onProgress: this.loadprogress.bind(this)
          }, c.load(l, u, f)
        }, a.loadsuccess = function (e, t, r, i) {
          void 0 === i && (i = null);
          var a = e.data,
            n = r.frag;
          n.loader = void 0, this.loaders[n.type] = void 0, this.hls.trigger(l.default.FRAG_LOADED, {
            payload: a,
            frag: n,
            stats: t,
            networkDetails: i
          })
        }, a.loaderror = function (e, t, r) {
          void 0 === r && (r = null);
          var i = t.frag,
            a = i.loader;
          a && a.abort(), this.loaders[i.type] = void 0, this.hls.trigger(l.default.ERROR, {
            type: s.ErrorTypes.NETWORK_ERROR,
            details: s.ErrorDetails.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: t.frag,
            response: e,
            networkDetails: r
          })
        }, a.loadtimeout = function (e, t, r) {
          void 0 === r && (r = null);
          var i = t.frag,
            a = i.loader;
          a && a.abort(), this.loaders[i.type] = void 0, this.hls.trigger(l.default.ERROR, {
            type: s.ErrorTypes.NETWORK_ERROR,
            details: s.ErrorDetails.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: t.frag,
            networkDetails: r
          })
        }, a.loadprogress = function (e, t, r, i) {
          void 0 === i && (i = null);
          var a = t.frag;
          a.loaded = e.loaded, this.hls.trigger(l.default.FRAG_LOAD_PROGRESS, {
            frag: a,
            stats: e,
            networkDetails: i
          })
        }, i
      }(f);
      var F = function (e) {
        var t, r;

        function i(t) {
          var r;
          return (r = e.call(this, t, l.default.KEY_LOADING) || this).loaders = {}, r.decryptkey = null, r.decrypturl = null, r
        }
        r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
        var a = i.prototype;
        return a.destroy = function () {
          for (var t in this.loaders) {
            var r = this.loaders[t];
            r && r.destroy()
          }
          this.loaders = {}, e.prototype.destroy.call(this)
        }, a.onKeyLoading = function (e) {
          var t = e.frag,
            r = t.type,
            i = this.loaders[r];
          if (t.decryptdata) {
            var a = t.decryptdata.uri;
            if (a !== this.decrypturl || null === this.decryptkey) {
              var n = this.hls.config;
              if (i && (d.logger.warn("abort previous key loader for type:" + r), i.abort()), !a) return void d.logger.warn("key uri is falsy");
              t.loader = this.loaders[r] = new n.loader(n), this.decrypturl = a, this.decryptkey = null;
              var s = {
                  url: a,
                  frag: t,
                  responseType: "arraybuffer"
                },
                o = {
                  timeout: n.fragLoadingTimeOut,
                  maxRetry: 0,
                  retryDelay: n.fragLoadingRetryDelay,
                  maxRetryDelay: n.fragLoadingMaxRetryTimeout
                },
                u = {
                  onSuccess: this.loadsuccess.bind(this),
                  onError: this.loaderror.bind(this),
                  onTimeout: this.loadtimeout.bind(this)
                };
              t.loader.load(s, o, u)
            } else this.decryptkey && (t.decryptdata.key = this.decryptkey, this.hls.trigger(l.default.KEY_LOADED, {
              frag: t
            }))
          } else d.logger.warn("Missing decryption data on fragment in onKeyLoading")
        }, a.loadsuccess = function (e, t, r) {
          var i = r.frag;
          i.decryptdata ? (this.decryptkey = i.decryptdata.key = new Uint8Array(e.data), i.loader = void 0, delete this.loaders[i.type], this.hls.trigger(l.default.KEY_LOADED, {
            frag: i
          })) : d.logger.error("after key load, decryptdata unset")
        }, a.loaderror = function (e, t) {
          var r = t.frag,
            i = r.loader;
          i && i.abort(), delete this.loaders[r.type], this.hls.trigger(l.default.ERROR, {
            type: s.ErrorTypes.NETWORK_ERROR,
            details: s.ErrorDetails.KEY_LOAD_ERROR,
            fatal: !1,
            frag: r,
            response: e
          })
        }, a.loadtimeout = function (e, t) {
          var r = t.frag,
            i = r.loader;
          i && i.abort(), delete this.loaders[r.type], this.hls.trigger(l.default.ERROR, {
            type: s.ErrorTypes.NETWORK_ERROR,
            details: s.ErrorDetails.KEY_LOAD_TIMEOUT,
            fatal: !1,
            frag: r
          })
        }, i
      }(f);
      var M = "NOT_LOADED",
        U = "APPENDING",
        N = "PARTIAL",
        B = "OK",
        G = function (e) {
          var t, r;

          function i(t) {
            var r;
            return (r = e.call(this, t, l.default.BUFFER_APPENDED, l.default.FRAG_BUFFERED, l.default.FRAG_LOADED) || this).bufferPadding = .2, r.fragments = Object.create(null), r.timeRanges = Object.create(null), r.config = t.config, r
          }
          r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          var a = i.prototype;
          return a.destroy = function () {
            this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.config = null, f.prototype.destroy.call(this), e.prototype.destroy.call(this)
          }, a.getBufferedFrag = function (e, t) {
            var r = this.fragments,
              i = Object.keys(r).filter((function (i) {
                var a = r[i];
                if (a.body.type !== t) return !1;
                if (!a.buffered) return !1;
                var n = a.body;
                return n.startPTS <= e && e <= n.endPTS
              }));
            if (0 === i.length) return null;
            var a = i.pop();
            return r[a].body
          }, a.detectEvictedFragments = function (e, t) {
            var r = this;
            Object.keys(this.fragments).forEach((function (i) {
              var a = r.fragments[i];
              if (a && a.buffered) {
                var n = a.range[e];
                if (n)
                  for (var s = n.time, o = 0; o < s.length; o++) {
                    var l = s[o];
                    if (!r.isTimeBuffered(l.startPTS, l.endPTS, t)) {
                      r.removeFragment(a.body);
                      break
                    }
                  }
              }
            }))
          }, a.detectPartialFragments = function (e) {
            var t = this,
              r = this.getFragmentKey(e),
              i = this.fragments[r];
            i && (i.buffered = !0, Object.keys(this.timeRanges).forEach((function (r) {
              if (e.hasElementaryStream(r)) {
                var a = t.timeRanges[r];
                i.range[r] = t.getBufferedTimes(e.startPTS, e.endPTS, a)
              }
            })))
          }, a.getBufferedTimes = function (e, t, r) {
            for (var i, a, n = [], s = !1, o = 0; o < r.length; o++) {
              if (i = r.start(o) - this.bufferPadding, a = r.end(o) + this.bufferPadding, e >= i && t <= a) {
                n.push({
                  startPTS: Math.max(e, r.start(o)),
                  endPTS: Math.min(t, r.end(o))
                });
                break
              }
              if (e < a && t > i) n.push({
                startPTS: Math.max(e, r.start(o)),
                endPTS: Math.min(t, r.end(o))
              }), s = !0;
              else if (t <= i) break
            }
            return {
              time: n,
              partial: s
            }
          }, a.getFragmentKey = function (e) {
            return e.type + "_" + e.level + "_" + e.urlId + "_" + e.sn
          }, a.getPartialFragment = function (e) {
            var t, r, i, a = this,
              n = null,
              s = 0;
            return Object.keys(this.fragments).forEach((function (o) {
              var l = a.fragments[o];
              a.isPartial(l) && (r = l.body.startPTS - a.bufferPadding, i = l.body.endPTS + a.bufferPadding, e >= r && e <= i && (t = Math.min(e - r, i - e), s <= t && (n = l.body, s = t)))
            })), n
          }, a.getState = function (e) {
            var t = this.getFragmentKey(e),
              r = this.fragments[t],
              i = M;
            return void 0 !== r && (i = r.buffered ? !0 === this.isPartial(r) ? N : B : U), i
          }, a.isPartial = function (e) {
            return !0 === e.buffered && (void 0 !== e.range.video && !0 === e.range.video.partial || void 0 !== e.range.audio && !0 === e.range.audio.partial)
          }, a.isTimeBuffered = function (e, t, r) {
            for (var i, a, n = 0; n < r.length; n++) {
              if (i = r.start(n) - this.bufferPadding, a = r.end(n) + this.bufferPadding, e >= i && t <= a) return !0;
              if (t <= i) return !1
            }
            return !1
          }, a.onFragLoaded = function (e) {
            var t = e.frag;
            Object(o.isFiniteNumber)(t.sn) && !t.bitrateTest && (this.fragments[this.getFragmentKey(t)] = {
              body: t,
              range: Object.create(null),
              buffered: !1
            })
          }, a.onBufferAppended = function (e) {
            var t = this;
            this.timeRanges = e.timeRanges, Object.keys(this.timeRanges).forEach((function (e) {
              var r = t.timeRanges[e];
              t.detectEvictedFragments(e, r)
            }))
          }, a.onFragBuffered = function (e) {
            this.detectPartialFragments(e.frag)
          }, a.hasFragment = function (e) {
            var t = this.getFragmentKey(e);
            return void 0 !== this.fragments[t]
          }, a.removeFragment = function (e) {
            var t = this.getFragmentKey(e);
            delete this.fragments[t]
          }, a.removeAllFragments = function () {
            this.fragments = Object.create(null)
          }, i
        }(f),
        j = {
          search: function (e, t) {
            for (var r = 0, i = e.length - 1, a = null, n = null; r <= i;) {
              var s = t(n = e[a = (r + i) / 2 | 0]);
              if (s > 0) r = a + 1;
              else {
                if (!(s < 0)) return n;
                i = a - 1
              }
            }
            return null
          }
        },
        K = function () {
          function e() {}
          return e.isBuffered = function (e, t) {
            try {
              if (e)
                for (var r = e.buffered, i = 0; i < r.length; i++)
                  if (t >= r.start(i) && t <= r.end(i)) return !0
            } catch (e) {}
            return !1
          }, e.bufferInfo = function (e, t, r) {
            try {
              if (e) {
                var i, a = e.buffered,
                  n = [];
                for (i = 0; i < a.length; i++) n.push({
                  start: a.start(i),
                  end: a.end(i)
                });
                return this.bufferedInfo(n, t, r)
              }
            } catch (e) {}
            return {
              len: 0,
              start: t,
              end: t,
              nextStart: void 0
            }
          }, e.bufferedInfo = function (e, t, r) {
            e.sort((function (e, t) {
              var r = e.start - t.start;
              return r || t.end - e.end
            }));
            var i = [];
            if (r)
              for (var a = 0; a < e.length; a++) {
                var n = i.length;
                if (n) {
                  var s = i[n - 1].end;
                  e[a].start - s < r ? e[a].end > s && (i[n - 1].end = e[a].end) : i.push(e[a])
                } else i.push(e[a])
              } else i = e;
            for (var o, l = 0, d = t, u = t, f = 0; f < i.length; f++) {
              var c = i[f].start,
                h = i[f].end;
              if (t + r >= c && t < h) d = c, l = (u = h) - t;
              else if (t + r < c) {
                o = c;
                break
              }
            }
            return {
              len: l,
              start: d,
              end: u,
              nextStart: o
            }
          }, e
        }(),
        H = r("./node_modules/eventemitter3/index.js"),
        V = r("./node_modules/webworkify-webpack/index.js"),
        W = r("./src/demux/demuxer-inline.js");

      function Y() {
        return window.MediaSource || window.WebKitMediaSource
      }
      var z = r("./src/utils/get-self-scope.js");
      var X = function (e) {
          var t, r;

          function i() {
            return e.apply(this, arguments) || this
          }
          return r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, i.prototype.trigger = function (e) {
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) r[i - 1] = arguments[i];
            this.emit.apply(this, [e, e].concat(r))
          }, i
        }(H.EventEmitter),
        q = Object(z.getSelfScope)(),
        Q = Y() || {
          isTypeSupported: function () {
            return !1
          }
        },
        Z = function () {
          function e(e, t) {
            var r = this;
            this.hls = e, this.id = t;
            var i = this.observer = new X,
              a = e.config,
              n = function (t, i) {
                (i = i || {}).frag = r.frag, i.id = r.id, e.trigger(t, i)
              };
            i.on(l.default.FRAG_DECRYPTED, n), i.on(l.default.FRAG_PARSING_INIT_SEGMENT, n), i.on(l.default.FRAG_PARSING_DATA, n), i.on(l.default.FRAG_PARSED, n), i.on(l.default.ERROR, n), i.on(l.default.FRAG_PARSING_METADATA, n), i.on(l.default.FRAG_PARSING_USERDATA, n), i.on(l.default.INIT_PTS_FOUND, n);
            var o = {
                mp4: Q.isTypeSupported("video/mp4"),
                mpeg: Q.isTypeSupported("audio/mpeg"),
                mp3: Q.isTypeSupported('audio/mp4; codecs="mp3"')
              },
              u = navigator.vendor;
            if (a.enableWorker && "undefined" != typeof Worker) {
              var f;
              d.logger.log("demuxing in webworker");
              try {
                f = this.w = V("./src/demux/demuxer-worker.js"), this.onwmsg = this.onWorkerMessage.bind(this), f.addEventListener("message", this.onwmsg), f.onerror = function (t) {
                  e.trigger(l.default.ERROR, {
                    type: s.ErrorTypes.OTHER_ERROR,
                    details: s.ErrorDetails.INTERNAL_EXCEPTION,
                    fatal: !0,
                    event: "demuxerWorker",
                    err: {
                      message: t.message + " (" + t.filename + ":" + t.lineno + ")"
                    }
                  })
                }, f.postMessage({
                  cmd: "init",
                  typeSupported: o,
                  vendor: u,
                  id: t,
                  config: JSON.stringify(a)
                })
              } catch (e) {
                d.logger.warn("Error in worker:", e), d.logger.error("Error while initializing DemuxerWorker, fallback on DemuxerInline"), f && q.URL.revokeObjectURL(f.objectURL), this.demuxer = new W.default(i, o, a, u), this.w = void 0
              }
            } else this.demuxer = new W.default(i, o, a, u)
          }
          var t = e.prototype;
          return t.destroy = function () {
            var e = this.w;
            if (e) e.removeEventListener("message", this.onwmsg), e.terminate(), this.w = null;
            else {
              var t = this.demuxer;
              t && (t.destroy(), this.demuxer = null)
            }
            var r = this.observer;
            r && (r.removeAllListeners(), this.observer = null)
          }, t.push = function (e, t, r, i, a, n, s, l) {
            var u = this.w,
              f = Object(o.isFiniteNumber)(a.startPTS) ? a.startPTS : a.start,
              c = a.decryptdata,
              h = this.frag,
              g = !(h && a.cc === h.cc),
              v = !(h && a.level === h.level),
              p = h && a.sn === h.sn + 1,
              m = !v && p;
            if (g && d.logger.log(this.id + ":discontinuity detected"), v && d.logger.log(this.id + ":switch detected"), this.frag = a, u) u.postMessage({
              cmd: "demux",
              data: e,
              decryptdata: c,
              initSegment: t,
              audioCodec: r,
              videoCodec: i,
              timeOffset: f,
              discontinuity: g,
              trackSwitch: v,
              contiguous: m,
              duration: n,
              accurateTimeOffset: s,
              defaultInitPTS: l
            }, e instanceof ArrayBuffer ? [e] : []);
            else {
              var y = this.demuxer;
              y && y.push(e, c, t, r, i, f, g, v, m, n, s, l)
            }
          }, t.onWorkerMessage = function (e) {
            var t = e.data,
              r = this.hls;
            switch (t.event) {
            case "init":
              q.URL.revokeObjectURL(this.w.objectURL);
              break;
            case l.default.FRAG_PARSING_DATA:
              t.data.data1 = new Uint8Array(t.data1), t.data2 && (t.data.data2 = new Uint8Array(t.data2));
            default:
              t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, r.trigger(t.event, t.data)
            }
          }, e
        }();

      function J(e, t, r) {
        switch (t) {
        case "audio":
          e.audioGroupIds || (e.audioGroupIds = []), e.audioGroupIds.push(r);
          break;
        case "text":
          e.textGroupIds || (e.textGroupIds = []), e.textGroupIds.push(r)
        }
      }

      function $(e, t, r) {
        var i = e[t],
          a = e[r],
          n = a.startPTS;
        Object(o.isFiniteNumber)(n) ? r > t ? (i.duration = n - i.start, i.duration < 0 && d.logger.warn("negative duration computed for frag " + i.sn + ",level " + i.level + ", there should be some duration drift between playlist and fragment!")) : (a.duration = i.start - n, a.duration < 0 && d.logger.warn("negative duration computed for frag " + a.sn + ",level " + a.level + ", there should be some duration drift between playlist and fragment!")) : a.start = r > t ? i.start + i.duration : Math.max(i.start - a.duration, 0)
      }

      function ee(e, t, r, i, a, n) {
        var s = r;
        if (Object(o.isFiniteNumber)(t.startPTS)) {
          var l = Math.abs(t.startPTS - r);
          Object(o.isFiniteNumber)(t.deltaPTS) ? t.deltaPTS = Math.max(l, t.deltaPTS) : t.deltaPTS = l, s = Math.max(r, t.startPTS), r = Math.min(r, t.startPTS), i = Math.max(i, t.endPTS), a = Math.min(a, t.startDTS), n = Math.max(n, t.endDTS)
        }
        var d = r - t.start;
        t.start = t.startPTS = r, t.maxStartPTS = s, t.endPTS = i, t.startDTS = a, t.endDTS = n, t.duration = i - r;
        var u, f, c, h = t.sn;
        if (!e || h < e.startSN || h > e.endSN) return 0;
        for (u = h - e.startSN, (f = e.fragments)[u] = t, c = u; c > 0; c--) $(f, c, c - 1);
        for (c = u; c < f.length - 1; c++) $(f, c, c + 1);
        return e.PTSKnown = !0, d
      }

      function te(e, t, r) {
        if (e && t)
          for (var i = Math.max(e.startSN, t.startSN) - t.startSN, a = Math.min(e.endSN, t.endSN) - t.startSN, n = t.startSN - e.startSN, s = i; s <= a; s++) {
            var o = e.fragments[n + s],
              l = t.fragments[s];
            if (!o || !l) break;
            r(o, l, s)
          }
      }
      var re = {
        toString: function (e) {
          for (var t = "", r = e.length, i = 0; i < r; i++) t += "[" + e.start(i).toFixed(3) + "," + e.end(i).toFixed(3) + "]";
          return t
        }
      };

      function ie(e, t) {
        t.fragments.forEach((function (t) {
          if (t) {
            var r = t.start + e;
            t.start = t.startPTS = r, t.endPTS = r + t.duration
          }
        })), t.PTSKnown = !0
      }

      function ae(e, t, r) {
        ! function (e, t, r) {
          if (function (e, t, r) {
              var i = !1;
              return t && t.details && r && (r.endCC > r.startCC || e && e.cc < r.startCC) && (i = !0), i
            }(e, r, t)) {
            var i = function (e, t) {
              var r = e.fragments,
                i = t.fragments;
              if (i.length && r.length) {
                var a = function (e, t) {
                  for (var r = null, i = 0; i < e.length; i += 1) {
                    var a = e[i];
                    if (a && a.cc === t) {
                      r = a;
                      break
                    }
                  }
                  return r
                }(r, i[0].cc);
                if (a && (!a || a.startPTS)) return a;
                d.logger.log("No frag in previous level to align on")
              } else d.logger.log("No fragments to align")
            }(r.details, t);
            i && (d.logger.log("Adjusting PTS using last level due to CC increase within current level"), ie(i.start, t))
          }
        }(e, r, t), !r.PTSKnown && t && function (e, t) {
          if (t && t.fragments.length) {
            if (!e.hasProgramDateTime || !t.hasProgramDateTime) return;
            var r = t.fragments[0].programDateTime,
              i = (e.fragments[0].programDateTime - r) / 1e3 + t.fragments[0].start;
            Object(o.isFiniteNumber)(i) && (d.logger.log("adjusting PTS using programDateTime delta, sliding:" + i.toFixed(3)), ie(i, e))
          }
        }(r, t.details)
      }

      function ne(e, t, r) {
        void 0 === e && (e = 0), void 0 === t && (t = 0);
        var i = Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));
        return r.start + r.duration - i <= e ? 1 : r.start - i > e && r.start ? -1 : 0
      }

      function se(e, t, r) {
        var i = 1e3 * Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));
        return (r.endProgramDateTime || 0) - i > e
      }
      var oe = function () {
        function e(e, t, r, i) {
          this.config = e, this.media = t, this.fragmentTracker = r, this.hls = i, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1
        }
        var t = e.prototype;
        return t.poll = function (e) {
          var t = this.config,
            r = this.media,
            i = this.stalled,
            a = r.currentTime,
            n = r.seeking,
            s = this.seeking && !n,
            o = !this.seeking && n;
          if (this.seeking = n, a === e) {
            if ((o || s) && (this.stalled = null), !r.paused && !r.ended && 0 !== r.playbackRate && r.buffered.length) {
              var l = K.bufferInfo(r, a, 0),
                u = l.len > 0,
                f = l.nextStart || 0;
              if (u || f) {
                if (n) {
                  var c = l.len > 2,
                    h = !f || f - a > 2 && !this.fragmentTracker.getPartialFragment(a);
                  if (c || h) return;
                  this.moved = !1
                }
                if (!this.moved && this.stalled) {
                  var g = Math.max(f, l.start || 0) - a;
                  if (g > 0 && g <= 2) return void this._trySkipBufferHole(null)
                }
                var v = self.performance.now();
                if (null !== i) {
                  var p = v - i;
                  !n && p >= 250 && this._reportStall(l.len);
                  var m = K.bufferInfo(r, a, t.maxBufferHole);
                  this._tryFixBufferStall(m, p)
                } else this.stalled = v
              }
            }
          } else if (this.moved = !0, null !== i) {
            if (this.stallReported) {
              var y = self.performance.now() - i;
              d.logger.warn("playback not stuck anymore @" + a + ", after " + Math.round(y) + "ms"), this.stallReported = !1
            }
            this.stalled = null, this.nudgeRetry = 0
          }
        }, t._tryFixBufferStall = function (e, t) {
          var r = this.config,
            i = this.fragmentTracker,
            a = this.media.currentTime,
            n = i.getPartialFragment(a);
          if (n && this._trySkipBufferHole(n)) return;
          e.len > r.maxBufferHole && t > 1e3 * r.highBufferWatchdogPeriod && (d.logger.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
        }, t._reportStall = function (e) {
          var t = this.hls,
            r = this.media;
          this.stallReported || (this.stallReported = !0, d.logger.warn("Playback stalling at @" + r.currentTime + " due to low buffer (buffer=" + e + ")"), t.trigger(l.default.ERROR, {
            type: s.ErrorTypes.MEDIA_ERROR,
            details: s.ErrorDetails.BUFFER_STALLED_ERROR,
            fatal: !1,
            buffer: e
          }))
        }, t._trySkipBufferHole = function (e) {
          for (var t = this.config, r = this.hls, i = this.media, a = i.currentTime, n = 0, o = 0; o < i.buffered.length; o++) {
            var u = i.buffered.start(o);
            if (a + t.maxBufferHole >= n && a < u) {
              var f = Math.max(u + .05, i.currentTime + .1);
              return d.logger.warn("skipping hole, adjusting currentTime from " + a + " to " + f), this.moved = !0, this.stalled = null, i.currentTime = f, e && r.trigger(l.default.ERROR, {
                type: s.ErrorTypes.MEDIA_ERROR,
                details: s.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                fatal: !1,
                reason: "fragment loaded with buffer holes, seeking from " + a + " to " + f,
                frag: e
              }), f
            }
            n = i.buffered.end(o)
          }
          return 0
        }, t._tryNudgeBuffer = function () {
          var e = this.config,
            t = this.hls,
            r = this.media,
            i = r.currentTime,
            a = (this.nudgeRetry || 0) + 1;
          if (this.nudgeRetry = a, a < e.nudgeMaxRetry) {
            var n = i + a * e.nudgeOffset;
            d.logger.warn("Nudging 'currentTime' from " + i + " to " + n), r.currentTime = n, t.trigger(l.default.ERROR, {
              type: s.ErrorTypes.MEDIA_ERROR,
              details: s.ErrorDetails.BUFFER_NUDGE_ON_STALL,
              fatal: !1
            })
          } else d.logger.error("Playhead still not moving while enough data buffered @" + i + " after " + e.nudgeMaxRetry + " nudges"), t.trigger(l.default.ERROR, {
            type: s.ErrorTypes.MEDIA_ERROR,
            details: s.ErrorDetails.BUFFER_STALLED_ERROR,
            fatal: !0
          })
        }, e
      }();

      function le(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
      }
      var de = function (e) {
        var t, r;

        function i(t) {
          for (var r, i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) a[n - 1] = arguments[n];
          return (r = e.call.apply(e, [this, t].concat(a)) || this)._boundTick = void 0, r._tickTimer = null, r._tickInterval = null, r._tickCallCount = 0, r._boundTick = r.tick.bind(le(r)), r
        }
        r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
        var a = i.prototype;
        return a.onHandlerDestroying = function () {
          this.clearNextTick(), this.clearInterval()
        }, a.hasInterval = function () {
          return !!this._tickInterval
        }, a.hasNextTick = function () {
          return !!this._tickTimer
        }, a.setInterval = function (e) {
          return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, e), !0)
        }, a.clearInterval = function () {
          return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0)
        }, a.clearNextTick = function () {
          return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0)
        }, a.tick = function () {
          this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && (this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)), this._tickCallCount = 0)
        }, a.doTick = function () {}, i
      }(f);
      var ue = "STOPPED",
        fe = "IDLE",
        ce = "KEY_LOADING",
        he = "FRAG_LOADING",
        ge = "FRAG_LOADING_WAITING_RETRY",
        ve = "PARSING",
        pe = "PARSED",
        me = "BUFFER_FLUSHING",
        ye = "ENDED",
        Ee = "ERROR",
        be = "WAITING_LEVEL",
        Te = function (e) {
          var t, r;

          function i() {
            return e.apply(this, arguments) || this
          }
          r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          var a = i.prototype;
          return a.doTick = function () {}, a.startLoad = function () {}, a.stopLoad = function () {
            var e = this.fragCurrent;
            e && (e.loader && e.loader.abort(), this.fragmentTracker.removeFragment(e)), this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = ue
          }, a._streamEnded = function (e, t) {
            var r = this.fragCurrent,
              i = this.fragmentTracker;
            if (!t.live && r && !r.backtracked && r.sn === t.endSN && !e.nextStart) {
              var a = i.getState(r);
              return a === N || a === B
            }
            return !1
          }, a.onMediaSeeking = function () {
            var e = this.config,
              t = this.media,
              r = this.mediaBuffer,
              i = this.state,
              a = t ? t.currentTime : null,
              n = K.bufferInfo(r || t, a, this.config.maxBufferHole);
            if (Object(o.isFiniteNumber)(a) && d.logger.log("media seeking to " + a.toFixed(3)), i === he) {
              var s = this.fragCurrent;
              if (0 === n.len && s) {
                var l = e.maxFragLookUpTolerance,
                  u = s.start - l,
                  f = s.start + s.duration + l;
                a < u || a > f ? (s.loader && (d.logger.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), s.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = fe) : d.logger.log("seeking outside of buffer but within currently loaded fragment range")
              }
            } else i === ye && (0 === n.len && (this.fragPrevious = null, this.fragCurrent = null), this.state = fe);
            t && (this.lastCurrentTime = a), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = a), this.tick()
          }, a.onMediaEnded = function () {
            this.startPosition = this.lastCurrentTime = 0
          }, a.onHandlerDestroying = function () {
            this.stopLoad(), e.prototype.onHandlerDestroying.call(this)
          }, a.onHandlerDestroyed = function () {
            this.state = ue, this.fragmentTracker = null
          }, a.computeLivePosition = function (e, t) {
            var r = void 0 !== this.config.liveSyncDuration ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * t.targetduration;
            return e + Math.max(0, t.totalduration - r)
          }, i
        }(de);

      function Se(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
      }
      var _e, Ae = function (e) {
        var t, r;

        function i(t, r) {
          var i;
          return (i = e.call(this, t, l.default.MEDIA_ATTACHED, l.default.MEDIA_DETACHING, l.default.MANIFEST_LOADING, l.default.MANIFEST_PARSED, l.default.LEVEL_LOADED, l.default.LEVELS_UPDATED, l.default.KEY_LOADED, l.default.FRAG_LOADED, l.default.FRAG_LOAD_EMERGENCY_ABORTED, l.default.FRAG_PARSING_INIT_SEGMENT, l.default.FRAG_PARSING_DATA, l.default.FRAG_PARSED, l.default.ERROR, l.default.AUDIO_TRACK_SWITCHING, l.default.AUDIO_TRACK_SWITCHED, l.default.BUFFER_CREATED, l.default.BUFFER_APPENDED, l.default.BUFFER_FLUSHED) || this).fragmentTracker = r, i.config = t.config, i.audioCodecSwap = !1, i._state = ue, i.stallReported = !1, i.gapController = null, i.altAudio = !1, i.audioOnly = !1, i.bitrateTest = !1, i
        }
        r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
        var n, u, f, c = i.prototype;
        return c.startLoad = function (e) {
          if (this.levels) {
            var t = this.lastCurrentTime,
              r = this.hls;
            if (this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {
              var i = r.startLevel; - 1 === i && (r.config.testBandwidth ? (i = 0, this.bitrateTest = !0) : i = r.nextAutoLevel), this.level = r.nextLoadLevel = i, this.loadedmetadata = !1
            }
            t > 0 && -1 === e && (d.logger.log("override startPosition with lastCurrentTime @" + t.toFixed(3)), e = t), this.state = fe, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
          } else this.forceStartLoad = !0, this.state = ue
        }, c.stopLoad = function () {
          this.forceStartLoad = !1, e.prototype.stopLoad.call(this)
        }, c.doTick = function () {
          switch (this.state) {
          case me:
            this.fragLoadError = 0;
            break;
          case fe:
            this._doTickIdle();
            break;
          case be:
            var e = this.levels[this.level];
            e && e.details && (this.state = fe);
            break;
          case ge:
            var t = window.performance.now(),
              r = this.retryDate;
            (!r || t >= r || this.media && this.media.seeking) && (d.logger.log("mediaController: retryDate reached, switch back to IDLE state"), this.state = fe)
          }
          this._checkBuffer(), this._checkFragmentChanged()
        }, c._doTickIdle = function () {
          var e = this.hls,
            t = e.config,
            r = this.media;
          if (void 0 !== this.levelLastLoaded && (r || !this.startFragRequested && t.startFragPrefetch))
            if (this.altAudio && this.audioOnly) this.demuxer.frag = null;
            else {
              var i;
              i = this.loadedmetadata ? r.currentTime : this.nextLoadPosition;
              var a = e.nextLoadLevel,
                n = this.levels[a];
              if (n) {
                var s, o = n.bitrate;
                s = o ? Math.max(8 * t.maxBufferSize / o, t.maxBufferLength) : t.maxBufferLength, s = Math.min(s, t.maxMaxBufferLength);
                var u = i < t.maxBufferHole ? Math.max(2, t.maxBufferHole) : t.maxBufferHole,
                  f = K.bufferInfo(this.mediaBuffer ? this.mediaBuffer : r, i, u),
                  c = f.len;
                if (!(c >= s)) {
                  d.logger.trace("buffer length of " + c.toFixed(3) + " is below max of " + s.toFixed(3) + ". checking for more payload ..."), this.level = e.nextLoadLevel = a;
                  var h = n.details;
                  if (!h || h.live && this.levelLastLoaded !== a) this.state = be;
                  else {
                    if (this._streamEnded(f, h)) {
                      var g = {};
                      return this.altAudio && (g.type = "video"), this.hls.trigger(l.default.BUFFER_EOS, g), void(this.state = ye)
                    }
                    this._fetchPayloadOrEos(i, f, h)
                  }
                }
              }
            }
        }, c._fetchPayloadOrEos = function (e, t, r) {
          var i = this.fragPrevious,
            a = (this.level, r.fragments),
            n = a.length;
          if (0 !== n) {
            var s, o = a[0].start,
              l = a[n - 1].start + a[n - 1].duration,
              u = t.end;
            if (r.initSegment && !r.initSegment.data) s = r.initSegment;
            else if (r.live) {
              var f = this.config.initialLiveManifestSize;
              if (n < f) return void d.logger.warn("Can not start playback of a level, reason: not enough fragments " + n + " < " + f);
              if (null === (s = this._ensureFragmentAtLivePoint(r, u, o, l, i, a))) return
            } else u < o && (s = a[0]);
            s || (s = this._findFragment(o, i, n, a, u, l, r)), s && (s.encrypted ? this._loadKey(s, r) : this._loadFragment(s, r, e, u))
          }
        }, c._ensureFragmentAtLivePoint = function (e, t, r, i, a, n) {
          var s, l = this.hls.config,
            u = this.media,
            f = 1 / 0;
          if (void 0 !== l.liveMaxLatencyDuration ? f = l.liveMaxLatencyDuration : Object(o.isFiniteNumber)(l.liveMaxLatencyDurationCount) && (f = l.liveMaxLatencyDurationCount * e.targetduration), t < Math.max(r - l.maxFragLookUpTolerance, i - f)) {
            var c = this.liveSyncPosition = this.computeLivePosition(r, e);
            t = c, u && !u.paused && u.readyState && u.duration > c && c > u.currentTime && (d.logger.log("buffer end: " + t.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + c.toFixed(3)), u.currentTime = c), this.nextLoadPosition = c
          }
          if (e.PTSKnown && t > i && u && u.readyState) return null;
          if (this.startFragRequested && !e.PTSKnown && a)
            if (e.hasProgramDateTime) d.logger.log("live playlist, switching playlist, load frag with same PDT: " + a.programDateTime), s = function (e, t, r) {
              if (null === t || !Array.isArray(e) || !e.length || !Object(o.isFiniteNumber)(t)) return null;
              if (t < (e[0].programDateTime || 0)) return null;
              if (t >= (e[e.length - 1].endProgramDateTime || 0)) return null;
              r = r || 0;
              for (var i = 0; i < e.length; ++i) {
                var a = e[i];
                if (se(t, r, a)) return a
              }
              return null
            }(n, a.endProgramDateTime, l.maxFragLookUpTolerance);
            else {
              var h = a.sn + 1;
              if (h >= e.startSN && h <= e.endSN) {
                var g = n[h - e.startSN];
                a.cc === g.cc && (s = g, d.logger.log("live playlist, switching playlist, load frag with next SN: " + s.sn))
              }
              s || (s = j.search(n, (function (e) {
                return a.cc - e.cc
              }))) && d.logger.log("live playlist, switching playlist, load frag with same CC: " + s.sn)
            } return s
        }, c._findFragment = function (e, t, r, i, a, n, s) {
          var o, l = this.hls.config;
          a < n ? o = function (e, t, r, i) {
            void 0 === r && (r = 0), void 0 === i && (i = 0);
            var a = null;
            if (e ? a = t[e.sn - t[0].sn + 1] : 0 === r && 0 === t[0].start && (a = t[0]), a && 0 === ne(r, i, a)) return a;
            var n = j.search(t, ne.bind(null, r, i));
            return n || a
          }(t, i, a, a > n - l.maxFragLookUpTolerance ? 0 : l.maxFragLookUpTolerance) : o = i[r - 1];
          if (o) {
            var u = o.sn - s.startSN,
              f = t && o.level === t.level,
              c = i[u - 1],
              h = i[u + 1];
            if (t && o.sn === t.sn)
              if (f && !o.backtracked)
                if (o.sn < s.endSN) {
                  var g = t.deltaPTS;
                  g && g > l.maxBufferHole && t.dropped && u ? (o = c, d.logger.warn("Previous fragment was dropped with large PTS gap between audio and video. Maybe fragment is not starting with a keyframe? Loading previous one to try to overcome this")) : (o = h, d.logger.log("Re-loading fragment with SN: " + o.sn))
                } else o = null;
            else o.backtracked && (h && h.backtracked ? (d.logger.warn("Already backtracked from fragment " + h.sn + ", will not backtrack to fragment " + o.sn + ". Loading fragment " + h.sn), o = h) : (d.logger.warn("Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe"), o.dropped = 0, c ? (o = c).backtracked = !0 : u && (o = null)))
          }
          return o
        }, c._loadKey = function (e, t) {
          d.logger.log("Loading key for " + e.sn + " of [" + t.startSN + " ," + t.endSN + "],level " + this.level), this.state = ce, this.hls.trigger(l.default.KEY_LOADING, {
            frag: e
          })
        }, c._loadFragment = function (e, t, r, i) {
          var a = this.fragmentTracker.getState(e);
          this.fragCurrent = e, "initSegment" !== e.sn && (this.startFragRequested = !0), Object(o.isFiniteNumber)(e.sn) && !e.bitrateTest && (this.nextLoadPosition = e.start + e.duration), e.backtracked || a === M || a === N ? (e.autoLevel = this.hls.autoLevelEnabled, e.bitrateTest = this.bitrateTest, d.logger.log("Loading " + e.sn + " of [" + t.startSN + " ," + t.endSN + "],level " + this.level + ", currentTime:" + r.toFixed(3) + ",bufferEnd:" + i.toFixed(3)), this.hls.trigger(l.default.FRAG_LOADING, {
            frag: e
          }), this.demuxer || (this.demuxer = new Z(this.hls, "main")), this.state = he) : a === U && this._reduceMaxBufferLength(e.duration) && this.fragmentTracker.removeFragment(e)
        }, c.getBufferedFrag = function (e) {
          return this.fragmentTracker.getBufferedFrag(e, a.MAIN)
        }, c.followingBufferedFrag = function (e) {
          return e ? this.getBufferedFrag(e.endPTS + .5) : null
        }, c._checkFragmentChanged = function () {
          var e, t, r = this.media;
          if (r && r.readyState && !1 === r.seeking && ((t = r.currentTime) > this.lastCurrentTime && (this.lastCurrentTime = t), K.isBuffered(r, t) ? e = this.getBufferedFrag(t) : K.isBuffered(r, t + .1) && (e = this.getBufferedFrag(t + .1)), e)) {
            var i = e;
            if (i !== this.fragPlaying) {
              this.hls.trigger(l.default.FRAG_CHANGED, {
                frag: i
              });
              var a = i.level;
              this.fragPlaying && this.fragPlaying.level === a || this.hls.trigger(l.default.LEVEL_SWITCHED, {
                level: a
              }), this.fragPlaying = i
            }
          }
        }, c.immediateLevelSwitch = function () {
          if (d.logger.log("immediateLevelSwitch"), !this.immediateSwitch) {
            this.immediateSwitch = !0;
            var e, t = this.media;
            t ? (e = t.paused, t.pause()) : e = !0, this.previouslyPaused = e
          }
          var r = this.fragCurrent;
          r && r.loader && r.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
        }, c.immediateLevelSwitchEnd = function () {
          var e = this.media;
          e && e.buffered.length && (this.immediateSwitch = !1, K.isBuffered(e, e.currentTime) && (e.currentTime -= 1e-4), this.previouslyPaused || e.play())
        }, c.nextLevelSwitch = function () {
          var e = this.media;
          if (e && e.readyState) {
            var t, r, i;
            if ((r = this.getBufferedFrag(e.currentTime)) && r.startPTS > 1 && this.flushMainBuffer(0, r.startPTS - 1), e.paused) t = 0;
            else {
              var a = this.hls.nextLoadLevel,
                n = this.levels[a],
                s = this.fragLastKbps;
              t = s && this.fragCurrent ? this.fragCurrent.duration * n.bitrate / (1e3 * s) + 1 : 0
            }
            if ((i = this.getBufferedFrag(e.currentTime + t)) && (i = this.followingBufferedFrag(i))) {
              var o = this.fragCurrent;
              o && o.loader && o.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(i.maxStartPTS, Number.POSITIVE_INFINITY)
            }
          }
        }, c.flushMainBuffer = function (e, t) {
          this.state = me;
          var r = {
            startOffset: e,
            endOffset: t
          };
          this.altAudio && (r.type = "video"), this.hls.trigger(l.default.BUFFER_FLUSHING, r)
        }, c.onMediaAttached = function (e) {
          var t = this.media = this.mediaBuffer = e.media;
          this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener("seeking", this.onvseeking), t.addEventListener("seeked", this.onvseeked), t.addEventListener("ended", this.onvended);
          var r = this.config;
          this.levels && r.autoStartLoad && this.hls.startLoad(r.startPosition), this.gapController = new oe(r, t, this.fragmentTracker, this.hls)
        }, c.onMediaDetaching = function () {
          var e = this.media;
          e && e.ended && (d.logger.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
          var t = this.levels;
          t && t.forEach((function (e) {
            e.details && e.details.fragments.forEach((function (e) {
              e.backtracked = void 0
            }))
          })), e && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("seeked", this.onvseeked), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.fragmentTracker.removeAllFragments(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad()
        }, c.onMediaSeeked = function () {
          var e = this.media,
            t = e ? e.currentTime : void 0;
          Object(o.isFiniteNumber)(t) && d.logger.log("media seeked to " + t.toFixed(3)), this.tick()
        }, c.onManifestLoading = function () {
          d.logger.log("trigger BUFFER_RESET"), this.hls.trigger(l.default.BUFFER_RESET), this.fragmentTracker.removeAllFragments(), this.stalled = !1, this.startPosition = this.lastCurrentTime = 0
        }, c.onManifestParsed = function (e) {
          var t, r = !1,
            i = !1;
          e.levels.forEach((function (e) {
            (t = e.audioCodec) && (-1 !== t.indexOf("mp4a.40.2") && (r = !0), -1 !== t.indexOf("mp4a.40.5") && (i = !0))
          })), this.audioCodecSwitch = r && i, this.audioCodecSwitch && d.logger.log("both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.altAudio = e.altAudio, this.levels = e.levels, this.startFragRequested = !1;
          var a = this.config;
          (a.autoStartLoad || this.forceStartLoad) && this.hls.startLoad(a.startPosition)
        }, c.onLevelLoaded = function (e) {
          var t = e.details,
            r = e.level,
            i = this.levels[this.levelLastLoaded],
            a = this.levels[r],
            n = t.totalduration,
            s = 0;
          if (d.logger.log("level " + r + " loaded [" + t.startSN + "," + t.endSN + "],duration:" + n), t.live) {
            var u = a.details;
            u && t.fragments.length > 0 ? (! function (e, t) {
              t.initSegment && e.initSegment && (t.initSegment = e.initSegment);
              var r, i = 0;
              if (te(e, t, (function (e, a) {
                  i = e.cc - a.cc, Object(o.isFiniteNumber)(e.startPTS) && (a.start = a.startPTS = e.startPTS, a.endPTS = e.endPTS, a.duration = e.duration, a.backtracked = e.backtracked, a.dropped = e.dropped, r = a), t.PTSKnown = !0
                })), t.PTSKnown) {
                if (i) {
                  d.logger.log("discontinuity sliding from playlist, take drift into account");
                  for (var a = t.fragments, n = 0; n < a.length; n++) a[n].cc += i
                }
                r ? ee(t, r, r.startPTS, r.endPTS, r.startDTS, r.endDTS) : function (e, t) {
                  var r = t.startSN - e.startSN,
                    i = e.fragments,
                    a = t.fragments;
                  if (r < 0 || r > i.length) return;
                  for (var n = 0; n < a.length; n++) a[n].start += i[r].start
                }(e, t), t.PTSKnown = e.PTSKnown
              }
            }(u, t), s = t.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(s, u), t.PTSKnown && Object(o.isFiniteNumber)(s) ? d.logger.log("live playlist sliding:" + s.toFixed(3)) : (d.logger.log("live playlist - outdated PTS, unknown sliding"), ae(this.fragPrevious, i, t))) : (d.logger.log("live playlist - first load, unknown sliding"), t.PTSKnown = !1, ae(this.fragPrevious, i, t))
          } else t.PTSKnown = !1;
          if (a.details = t, this.levelLastLoaded = r, this.hls.trigger(l.default.LEVEL_UPDATED, {
              details: t,
              level: r
            }), !1 === this.startFragRequested) {
            if (-1 === this.startPosition || -1 === this.lastCurrentTime) {
              var f = t.startTimeOffset;
              Object(o.isFiniteNumber)(f) ? (f < 0 && (d.logger.log("negative start time offset " + f + ", count from end of last fragment"), f = s + n + f), d.logger.log("start time offset found in playlist, adjust startPosition to " + f), this.startPosition = f) : t.live ? (this.startPosition = this.computeLivePosition(s, t), d.logger.log("configure startPosition to " + this.startPosition)) : this.startPosition = 0, this.lastCurrentTime = this.startPosition
            }
            this.nextLoadPosition = this.startPosition
          }
          this.state === be && (this.state = fe), this.tick()
        }, c.onKeyLoaded = function () {
          this.state === ce && (this.state = fe, this.tick())
        }, c.onFragLoaded = function (e) {
          var t = this.fragCurrent,
            r = this.hls,
            i = this.levels,
            a = this.media,
            n = e.frag;
          if (this.state === he && t && "main" === n.type && n.level === t.level && n.sn === t.sn) {
            var s = e.stats,
              o = i[t.level],
              u = o.details;
            if (this.bitrateTest = !1, this.stats = s, d.logger.log("Loaded " + t.sn + " of [" + u.startSN + " ," + u.endSN + "],level " + t.level), n.bitrateTest && r.nextLoadLevel) this.state = fe, this.startFragRequested = !1, s.tparsed = s.tbuffered = window.performance.now(), r.trigger(l.default.FRAG_BUFFERED, {
              stats: s,
              frag: t,
              id: "main"
            }), this.tick();
            else if ("initSegment" === n.sn) this.state = fe, s.tparsed = s.tbuffered = window.performance.now(), u.initSegment.data = e.payload, r.trigger(l.default.FRAG_BUFFERED, {
              stats: s,
              frag: t,
              id: "main"
            }), this.tick();
            else {
              d.logger.log("Parsing " + t.sn + " of [" + u.startSN + " ," + u.endSN + "],level " + t.level + ", cc " + t.cc), this.state = ve, this.pendingBuffering = !0, this.appended = !1, n.bitrateTest && (n.bitrateTest = !1, this.fragmentTracker.onFragLoaded({
                frag: n
              }));
              var f = !(a && a.seeking) && (u.PTSKnown || !u.live),
                c = u.initSegment ? u.initSegment.data : [],
                h = this._getAudioCodec(o);
              (this.demuxer = this.demuxer || new Z(this.hls, "main")).push(e.payload, c, h, o.videoCodec, t, u.totalduration, f)
            }
          }
          this.fragLoadError = 0
        }, c.onFragParsingInitSegment = function (e) {
          var t = this.fragCurrent,
            r = e.frag;
          if (t && "main" === e.id && r.sn === t.sn && r.level === t.level && this.state === ve) {
            var i, a, n = e.tracks;
            if (this.audioOnly = n.audio && !n.video, this.altAudio && !this.audioOnly && delete n.audio, a = n.audio) {
              var s = this.levels[this.level].audioCodec,
                o = navigator.userAgent.toLowerCase();
              s && this.audioCodecSwap && (d.logger.log("swapping playlist audio codec"), s = -1 !== s.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), this.audioCodecSwitch && 1 !== a.metadata.channelCount && -1 === o.indexOf("firefox") && (s = "mp4a.40.5"), -1 !== o.indexOf("android") && "audio/mpeg" !== a.container && (s = "mp4a.40.2", d.logger.log("Android: force audio codec to " + s)), a.levelCodec = s, a.id = e.id
            }
            for (i in (a = n.video) && (a.levelCodec = this.levels[this.level].videoCodec, a.id = e.id), this.hls.trigger(l.default.BUFFER_CODECS, n), n) {
              a = n[i], d.logger.log("main track:" + i + ",container:" + a.container + ",codecs[level/parsed]=[" + a.levelCodec + "/" + a.codec + "]");
              var u = a.initSegment;
              u && (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(l.default.BUFFER_APPENDING, {
                type: i,
                data: u,
                parent: "main",
                content: "initSegment"
              }))
            }
            this.tick()
          }
        }, c.onFragParsingData = function (e) {
          var t = this,
            r = this.fragCurrent,
            i = e.frag;
          if (r && "main" === e.id && i.sn === r.sn && i.level === r.level && ("audio" !== e.type || !this.altAudio) && this.state === ve) {
            var a = this.levels[this.level],
              n = r;
            if (Object(o.isFiniteNumber)(e.endPTS) || (e.endPTS = e.startPTS + r.duration, e.endDTS = e.startDTS + r.duration), !0 === e.hasAudio && n.addElementaryStream(g.AUDIO), !0 === e.hasVideo && n.addElementaryStream(g.VIDEO), d.logger.log("Parsed " + e.type + ",PTS:[" + e.startPTS.toFixed(3) + "," + e.endPTS.toFixed(3) + "],DTS:[" + e.startDTS.toFixed(3) + "/" + e.endDTS.toFixed(3) + "],nb:" + e.nb + ",dropped:" + (e.dropped || 0)), "video" === e.type)
              if (n.dropped = e.dropped, n.dropped)
                if (n.backtracked) d.logger.warn("Already backtracked on this fragment, appending with the gap", n.sn);
                else {
                  var s = a.details;
                  if (!s || n.sn !== s.startSN) return d.logger.warn("missing video frame(s), backtracking fragment", n.sn), this.fragmentTracker.removeFragment(n), n.backtracked = !0, this.nextLoadPosition = e.startPTS, this.state = fe, this.fragPrevious = n, void this.tick();
                  d.logger.warn("missing video frame(s) on first frag, appending with gap", n.sn)
                }
            else n.backtracked = !1;
            var u = ee(a.details, n, e.startPTS, e.endPTS, e.startDTS, e.endDTS),
              f = this.hls;
            f.trigger(l.default.LEVEL_PTS_UPDATED, {
              details: a.details,
              level: this.level,
              drift: u,
              type: e.type,
              start: e.startPTS,
              end: e.endPTS
            }), [e.data1, e.data2].forEach((function (r) {
              r && r.length && t.state === ve && (t.appended = !0, t.pendingBuffering = !0, f.trigger(l.default.BUFFER_APPENDING, {
                type: e.type,
                data: r,
                parent: "main",
                content: "data"
              }))
            })), this.tick()
          }
        }, c.onFragParsed = function (e) {
          var t = this.fragCurrent,
            r = e.frag;
          t && "main" === e.id && r.sn === t.sn && r.level === t.level && this.state === ve && (this.stats.tparsed = window.performance.now(), this.state = pe, this._checkAppendedParsed())
        }, c.onAudioTrackSwitching = function (e) {
          var t = !!e.url,
            r = e.id;
          if (!t) {
            if (this.mediaBuffer !== this.media) {
              d.logger.log("switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
              var i = this.fragCurrent;
              i.loader && (d.logger.log("switching to main audio track, cancel main fragment load"), i.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = fe
            }
            var a = this.hls;
            a.trigger(l.default.BUFFER_FLUSHING, {
              startOffset: 0,
              endOffset: Number.POSITIVE_INFINITY,
              type: "audio"
            }), a.trigger(l.default.AUDIO_TRACK_SWITCHED, {
              id: r
            }), this.altAudio = !1
          }
        }, c.onAudioTrackSwitched = function (e) {
          var t = e.id,
            r = !!this.hls.audioTracks[t].url;
          if (r) {
            var i = this.videoBuffer;
            i && this.mediaBuffer !== i && (d.logger.log("switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = i)
          }
          this.altAudio = r, this.tick()
        }, c.onBufferCreated = function (e) {
          var t, r, i = e.tracks,
            a = !1;
          for (var n in i) {
            var s = i[n];
            "main" === s.id ? (r = n, t = s, "video" === n && (this.videoBuffer = i[n].buffer)) : a = !0
          }
          a && t ? (d.logger.log("alternate track found, use " + r + ".buffered to schedule main fragment loading"), this.mediaBuffer = t.buffer) : this.mediaBuffer = this.media
        }, c.onBufferAppended = function (e) {
          if ("main" === e.parent) {
            var t = this.state;
            t !== ve && t !== pe || (this.pendingBuffering = e.pending > 0, this._checkAppendedParsed())
          }
        }, c._checkAppendedParsed = function () {
          if (!(this.state !== pe || this.appended && this.pendingBuffering)) {
            var e = this.fragCurrent;
            if (e) {
              var t = this.mediaBuffer ? this.mediaBuffer : this.media;
              d.logger.log("main buffered : " + re.toString(t.buffered)), this.fragPrevious = e;
              var r = this.stats;
              r.tbuffered = window.performance.now(), this.fragLastKbps = Math.round(8 * r.total / (r.tbuffered - r.tfirst)), this.hls.trigger(l.default.FRAG_BUFFERED, {
                stats: r,
                frag: e,
                id: "main"
              }), this.state = fe
            }(this.loadedmetadata || this.startPosition <= 0) && this.tick()
          }
        }, c.onError = function (e) {
          var t = e.frag || this.fragCurrent;
          if (!t || "main" === t.type) {
            var r = !!this.media && K.isBuffered(this.media, this.media.currentTime) && K.isBuffered(this.media, this.media.currentTime + .5);
            switch (e.details) {
            case s.ErrorDetails.FRAG_LOAD_ERROR:
            case s.ErrorDetails.FRAG_LOAD_TIMEOUT:
            case s.ErrorDetails.KEY_LOAD_ERROR:
            case s.ErrorDetails.KEY_LOAD_TIMEOUT:
              if (!e.fatal)
                if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
                  var i = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
                  d.logger.warn("mediaController: frag loading failed, retry in " + i + " ms"), this.retryDate = window.performance.now() + i, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.fragLoadError++, this.state = ge
                } else d.logger.error("mediaController: " + e.details + " reaches max retry, redispatch as fatal ..."), e.fatal = !0, this.state = Ee;
              break;
            case s.ErrorDetails.LEVEL_LOAD_ERROR:
            case s.ErrorDetails.LEVEL_LOAD_TIMEOUT:
              this.state !== Ee && (e.fatal ? (this.state = Ee, d.logger.warn("streamController: " + e.details + ",switch to " + this.state + " state ...")) : e.levelRetry || this.state !== be || (this.state = fe));
              break;
            case s.ErrorDetails.BUFFER_FULL_ERROR:
              "main" !== e.parent || this.state !== ve && this.state !== pe || (r ? (this._reduceMaxBufferLength(this.config.maxBufferLength), this.state = fe) : (d.logger.warn("buffer full error also media.currentTime is not buffered, flush everything"), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY)))
            }
          }
        }, c._reduceMaxBufferLength = function (e) {
          var t = this.config;
          return t.maxMaxBufferLength >= e && (t.maxMaxBufferLength /= 2, d.logger.warn("main:reduce max buffer length to " + t.maxMaxBufferLength + "s"), !0)
        }, c._checkBuffer = function () {
          var e = this.media;
          if (e && 0 !== e.readyState) {
            var t = (this.mediaBuffer ? this.mediaBuffer : e).buffered;
            !this.loadedmetadata && t.length ? (this.loadedmetadata = !0, this._seekToStartPos()) : this.immediateSwitch ? this.immediateLevelSwitchEnd() : this.gapController.poll(this.lastCurrentTime, t)
          }
        }, c.onFragLoadEmergencyAborted = function () {
          this.state = fe, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tick()
        }, c.onBufferFlushed = function () {
          var e = this.mediaBuffer ? this.mediaBuffer : this.media;
          if (e) {
            var t = this.audioOnly ? g.AUDIO : g.VIDEO;
            this.fragmentTracker.detectEvictedFragments(t, e.buffered)
          }
          this.state = fe, this.fragPrevious = null
        }, c.onLevelsUpdated = function (e) {
          this.levels = e.levels
        }, c.swapAudioCodec = function () {
          this.audioCodecSwap = !this.audioCodecSwap
        }, c._seekToStartPos = function () {
          var e = this.media,
            t = this.startPosition,
            r = e.currentTime;
          if (r !== t && t >= 0) {
            if (e.seeking) return void d.logger.log("could not seek to " + t + ", already seeking at " + r);
            d.logger.log("seek to target start position " + t + " from current time " + r + ". ready state " + e.readyState), e.currentTime = t
          }
        }, c._getAudioCodec = function (e) {
          var t = this.config.defaultAudioCodec || e.audioCodec;
          return this.audioCodecSwap && (d.logger.log("swapping playlist audio codec"), t && (t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5")), t
        }, n = i, (u = [{
          key: "state",
          set: function (e) {
            if (this.state !== e) {
              var t = this.state;
              this._state = e, d.logger.log("main stream-controller: " + t + "->" + e), this.hls.trigger(l.default.STREAM_STATE_TRANSITION, {
                previousState: t,
                nextState: e
              })
            }
          },
          get: function () {
            return this._state
          }
        }, {
          key: "currentLevel",
          get: function () {
            var e = this.media;
            if (e) {
              var t = this.getBufferedFrag(e.currentTime);
              if (t) return t.level
            }
            return -1
          }
        }, {
          key: "nextBufferedFrag",
          get: function () {
            var e = this.media;
            return e ? this.followingBufferedFrag(this.getBufferedFrag(e.currentTime)) : null
          }
        }, {
          key: "nextLevel",
          get: function () {
            var e = this.nextBufferedFrag;
            return e ? e.level : -1
          }
        }, {
          key: "liveSyncPosition",
          get: function () {
            return this._liveSyncPosition
          },
          set: function (e) {
            this._liveSyncPosition = e
          }
        }]) && Se(n.prototype, u), f && Se(n, f), i
      }(Te);

      function Re(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
      }
      var Le = function (e) {
          var t, r;

          function i(t) {
            var r;
            return (r = e.call(this, t, l.default.MANIFEST_LOADED, l.default.LEVEL_LOADED, l.default.AUDIO_TRACK_SWITCHED, l.default.FRAG_LOADED, l.default.ERROR) || this).canload = !1, r.currentLevelIndex = null, r.manualLevelIndex = -1, r.timer = null, _e = /chrome|firefox/.test(navigator.userAgent.toLowerCase()), r
          }
          r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          var a, n, o, u = i.prototype;
          return u.onHandlerDestroying = function () {
            this.clearTimer(), this.manualLevelIndex = -1
          }, u.clearTimer = function () {
            null !== this.timer && (clearTimeout(this.timer), this.timer = null)
          }, u.startLoad = function () {
            var e = this._levels;
            this.canload = !0, this.levelRetryCount = 0, e && e.forEach((function (e) {
              e.loadError = 0;
              var t = e.details;
              t && t.live && (e.details = void 0)
            })), null !== this.timer && this.loadLevel()
          }, u.stopLoad = function () {
            this.canload = !1
          }, u.onManifestLoaded = function (e) {
            var t, r = [],
              i = [],
              a = {},
              n = null,
              o = !1,
              u = !1;
            if (e.levels.forEach((function (e) {
                var t = e.attrs;
                e.loadError = 0, e.fragmentError = !1, o = o || !!e.videoCodec, u = u || !!e.audioCodec, _e && e.audioCodec && -1 !== e.audioCodec.indexOf("mp4a.40.34") && (e.audioCodec = void 0), (n = a[e.bitrate]) ? n.url.push(e.url) : (e.url = [e.url], e.urlId = 0, a[e.bitrate] = e, r.push(e)), t && (t.AUDIO && J(n || e, "audio", t.AUDIO), t.SUBTITLES && J(n || e, "text", t.SUBTITLES))
              })), o && u && (r = r.filter((function (e) {
                return !!e.videoCodec
              }))), r = r.filter((function (e) {
                var t = e.audioCodec,
                  r = e.videoCodec;
                return (!t || A(t, "audio")) && (!r || A(r, "video"))
              })), e.audioTracks && (i = e.audioTracks.filter((function (e) {
                return !e.audioCodec || A(e.audioCodec, "audio")
              }))).forEach((function (e, t) {
                e.id = t
              })), r.length > 0) {
              t = r[0].bitrate, r.sort((function (e, t) {
                return e.bitrate - t.bitrate
              })), this._levels = r;
              for (var f = 0; f < r.length; f++)
                if (r[f].bitrate === t) {
                  this._firstLevel = f, d.logger.log("manifest loaded," + r.length + " level(s) found, first bitrate:" + t);
                  break
                } var c = u && !o;
              this.hls.trigger(l.default.MANIFEST_PARSED, {
                levels: r,
                audioTracks: i,
                firstLevel: this._firstLevel,
                stats: e.stats,
                audio: u,
                video: o,
                altAudio: !c && i.some((function (e) {
                  return !!e.url
                }))
              })
            } else this.hls.trigger(l.default.ERROR, {
              type: s.ErrorTypes.MEDIA_ERROR,
              details: s.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
              fatal: !0,
              url: this.hls.url,
              reason: "no level with compatible codecs found in manifest"
            })
          }, u.setLevelInternal = function (e) {
            var t = this._levels,
              r = this.hls;
            if (e >= 0 && e < t.length) {
              if (this.clearTimer(), this.currentLevelIndex !== e) {
                d.logger.log("switching to level " + e), this.currentLevelIndex = e;
                var i = t[e];
                i.level = e, r.trigger(l.default.LEVEL_SWITCHING, i)
              }
              var a = t[e],
                n = a.details;
              if (!n || n.live) {
                var o = a.urlId;
                r.trigger(l.default.LEVEL_LOADING, {
                  url: a.url[o],
                  level: e,
                  id: o
                })
              }
            } else r.trigger(l.default.ERROR, {
              type: s.ErrorTypes.OTHER_ERROR,
              details: s.ErrorDetails.LEVEL_SWITCH_ERROR,
              level: e,
              fatal: !1,
              reason: "invalid level idx"
            })
          }, u.onError = function (e) {
            if (e.fatal) e.type === s.ErrorTypes.NETWORK_ERROR && this.clearTimer();
            else {
              var t, r = !1,
                i = !1;
              switch (e.details) {
              case s.ErrorDetails.FRAG_LOAD_ERROR:
              case s.ErrorDetails.FRAG_LOAD_TIMEOUT:
              case s.ErrorDetails.KEY_LOAD_ERROR:
              case s.ErrorDetails.KEY_LOAD_TIMEOUT:
                t = e.frag.level, i = !0;
                break;
              case s.ErrorDetails.LEVEL_LOAD_ERROR:
              case s.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                t = e.context.level, r = !0;
                break;
              case s.ErrorDetails.REMUX_ALLOC_ERROR:
                t = e.level, r = !0
              }
              void 0 !== t && this.recoverLevel(e, t, r, i)
            }
          }, u.recoverLevel = function (e, t, r, i) {
            var a, n, s, o = this,
              l = this.hls.config,
              u = e.details,
              f = this._levels[t];
            if (f.loadError++, f.fragmentError = i, r) {
              if (!(this.levelRetryCount + 1 <= l.levelLoadingMaxRetry)) return d.logger.error("level controller, cannot recover from " + u + " error"), this.currentLevelIndex = null, this.clearTimer(), void(e.fatal = !0);
              n = Math.min(Math.pow(2, this.levelRetryCount) * l.levelLoadingRetryDelay, l.levelLoadingMaxRetryTimeout), this.timer = setTimeout((function () {
                return o.loadLevel()
              }), n), e.levelRetry = !0, this.levelRetryCount++, d.logger.warn("level controller, " + u + ", retry in " + n + " ms, current retry count is " + this.levelRetryCount)
            }(r || i) && ((a = f.url.length) > 1 && f.loadError < a ? (f.urlId = (f.urlId + 1) % a, f.details = void 0, d.logger.warn("level controller, " + u + " for level " + t + ": switching to redundant URL-id " + f.urlId)) : -1 === this.manualLevelIndex ? (s = 0 === t ? this._levels.length - 1 : t - 1, d.logger.warn("level controller, " + u + ": switch to " + s), this.hls.nextAutoLevel = this.currentLevelIndex = s) : i && (d.logger.warn("level controller, " + u + ": reload a fragment"), this.currentLevelIndex = null))
          }, u.onFragLoaded = function (e) {
            var t = e.frag;
            if (void 0 !== t && "main" === t.type) {
              var r = this._levels[t.level];
              void 0 !== r && (r.fragmentError = !1, r.loadError = 0, this.levelRetryCount = 0)
            }
          }, u.onLevelLoaded = function (e) {
            var t = this,
              r = e.level,
              i = e.details;
            if (r === this.currentLevelIndex) {
              var a = this._levels[r];
              if (a.fragmentError || (a.loadError = 0, this.levelRetryCount = 0), i.live) {
                var n = function (e, t, r) {
                  var i = 1e3 * (t.averagetargetduration ? t.averagetargetduration : t.targetduration),
                    a = i / 2;
                  return e && t.endSN === e.endSN && (i = a), r && (i = Math.max(a, i - (window.performance.now() - r))), Math.round(i)
                }(a.details, i, e.stats.trequest);
                d.logger.log("live playlist, reload in " + Math.round(n) + " ms"), this.timer = setTimeout((function () {
                  return t.loadLevel()
                }), n)
              } else this.clearTimer()
            }
          }, u.onAudioTrackSwitched = function (e) {
            var t = this.hls.audioTracks[e.id].groupId,
              r = this.hls.levels[this.currentLevelIndex];
            if (r && r.audioGroupIds) {
              for (var i = -1, a = 0; a < r.audioGroupIds.length; a++)
                if (r.audioGroupIds[a] === t) {
                  i = a;
                  break
                } i !== r.urlId && (r.urlId = i, this.startLoad())
            }
          }, u.loadLevel = function () {
            if (d.logger.debug("call to loadLevel"), null !== this.currentLevelIndex && this.canload) {
              var e = this._levels[this.currentLevelIndex];
              if ("object" == typeof e && e.url.length > 0) {
                var t = this.currentLevelIndex,
                  r = e.urlId,
                  i = e.url[r];
                d.logger.log("Attempt loading level index " + t + " with URL-id " + r), this.hls.trigger(l.default.LEVEL_LOADING, {
                  url: i,
                  level: t,
                  id: r
                })
              }
            }
          }, u.removeLevel = function (e, t) {
            var r = this.levels.filter((function (r, i) {
              return i !== e || r.url.length > 1 && void 0 !== t && (r.url = r.url.filter((function (e, r) {
                return r !== t
              })), r.urlId = 0, !0)
            })).map((function (e, t) {
              var r = e.details;
              return r && r.fragments && r.fragments.forEach((function (e) {
                e.level = t
              })), e
            }));
            this._levels = r, this.hls.trigger(l.default.LEVELS_UPDATED, {
              levels: r
            })
          }, a = i, (n = [{
            key: "levels",
            get: function () {
              return this._levels
            }
          }, {
            key: "level",
            get: function () {
              return this.currentLevelIndex
            },
            set: function (e) {
              var t = this._levels;
              t && (e = Math.min(e, t.length - 1), this.currentLevelIndex === e && t[e].details || this.setLevelInternal(e))
            }
          }, {
            key: "manualLevel",
            get: function () {
              return this.manualLevelIndex
            },
            set: function (e) {
              this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e)
            }
          }, {
            key: "firstLevel",
            get: function () {
              return this._firstLevel
            },
            set: function (e) {
              this._firstLevel = e
            }
          }, {
            key: "startLevel",
            get: function () {
              if (void 0 === this._startLevel) {
                var e = this.hls.config.startLevel;
                return void 0 !== e ? e : this._firstLevel
              }
              return this._startLevel
            },
            set: function (e) {
              this._startLevel = e
            }
          }, {
            key: "nextLoadLevel",
            get: function () {
              return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
            },
            set: function (e) {
              this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e)
            }
          }]) && Re(a.prototype, n), o && Re(a, o), i
        }(f),
        De = r("./src/demux/id3.js");

      function we(e, t) {
        var r;
        try {
          r = new Event("addtrack")
        } catch (e) {
          (r = document.createEvent("Event")).initEvent("addtrack", !1, !1)
        }
        r.track = e, t.dispatchEvent(r)
      }
      var ke = function (e) {
        var t, r;

        function i(t) {
          var r;
          return (r = e.call(this, t, l.default.MEDIA_ATTACHED, l.default.MEDIA_DETACHING, l.default.FRAG_PARSING_METADATA, l.default.LIVE_BACK_BUFFER_REACHED) || this).id3Track = void 0, r.media = void 0, r
        }
        r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
        var a = i.prototype;
        return a.destroy = function () {
          f.prototype.destroy.call(this)
        }, a.onMediaAttached = function (e) {
          this.media = e.media, this.media
        }, a.onMediaDetaching = function () {
          ! function (e) {
            if (null == e ? void 0 : e.cues)
              for (; e.cues.length > 0;) e.removeCue(e.cues[0])
          }(this.id3Track), this.id3Track = void 0, this.media = void 0
        }, a.getID3Track = function (e) {
          for (var t = 0; t < e.length; t++) {
            var r = e[t];
            if ("metadata" === r.kind && "id3" === r.label) return we(r, this.media), r
          }
          return this.media.addTextTrack("metadata", "id3")
        }, a.onFragParsingMetadata = function (e) {
          var t = e.frag,
            r = e.samples;
          this.id3Track || (this.id3Track = this.getID3Track(this.media.textTracks), this.id3Track.mode = "hidden");
          for (var i = window.WebKitDataCue || window.VTTCue || window.TextTrackCue, a = 0; a < r.length; a++) {
            var n = De.default.getID3Frames(r[a].data);
            if (n) {
              var s = Math.max(r[a].pts, 0),
                o = a < r.length - 1 ? r[a + 1].pts : t.endPTS;
              o || (o = t.start + t.duration), s === o ? o += 1e-4 : s > o && (d.logger.warn("detected an id3 sample with endTime < startTime, adjusting endTime to (startTime + 0.25)"), o = s + .25);
              for (var l = 0; l < n.length; l++) {
                var u = n[l];
                if (!De.default.isTimeStampFrame(u)) {
                  var f = new i(s, o, "");
                  f.value = u, this.id3Track.addCue(f)
                }
              }
            }
          }
        }, a.onLiveBackBufferReached = function (e) {
          var t = e.bufferEnd,
            r = this.id3Track;
          if (r && r.cues && r.cues.length) {
            var i = function (e, t) {
              if (t < e[0].endTime) return e[0];
              if (t > e[e.length - 1].endTime) return e[e.length - 1];
              for (var r = 0, i = e.length - 1; r <= i;) {
                var a = Math.floor((i + r) / 2);
                if (t < e[a].endTime) i = a - 1;
                else {
                  if (!(t > e[a].endTime)) return e[a];
                  r = a + 1
                }
              }
              return e[r].endTime - t < t - e[i].endTime ? e[r] : e[i]
            }(r.cues, t);
            if (i)
              for (; r.cues[0] !== i;) r.removeCue(r.cues[0])
          }
        }, i
      }(f);
      var Oe = function () {
          function e(e) {
            this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = 0, this.totalWeight_ = 0
          }
          var t = e.prototype;
          return t.sample = function (e, t) {
            var r = Math.pow(this.alpha_, e);
            this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e
          }, t.getTotalWeight = function () {
            return this.totalWeight_
          }, t.getEstimate = function () {
            if (this.alpha_) {
              var e = 1 - Math.pow(this.alpha_, this.totalWeight_);
              return this.estimate_ / e
            }
            return this.estimate_
          }, e
        }(),
        xe = function () {
          function e(e, t, r, i) {
            this.hls = void 0, this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.hls = e, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new Oe(t), this.fast_ = new Oe(r)
          }
          var t = e.prototype;
          return t.sample = function (e, t) {
            var r = (e = Math.max(e, this.minDelayMs_)) / 1e3,
              i = 8 * t / r;
            this.fast_.sample(r, i), this.slow_.sample(r, i)
          }, t.canEstimate = function () {
            var e = this.fast_;
            return e && e.getTotalWeight() >= this.minWeight_
          }, t.getEstimate = function () {
            return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
          }, t.destroy = function () {}, e
        }();

      function Ie(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
      }
      var Ce = window.performance,
        Pe = function (e) {
          var t, r;

          function i(t) {
            var r;
            return (r = e.call(this, t, l.default.FRAG_LOADING, l.default.FRAG_LOADED, l.default.FRAG_BUFFERED, l.default.ERROR) || this).lastLoadedFragLevel = 0, r._nextAutoLevel = -1, r.hls = t, r.timer = null, r._bwEstimator = null, r.onCheck = r._abandonRulesCheck.bind(function (e) {
              if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e
            }(r)), r
          }
          r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          var a, n, u, c = i.prototype;
          return c.destroy = function () {
            this.clearTimer(), f.prototype.destroy.call(this)
          }, c.onFragLoading = function (e) {
            var t = e.frag;
            if ("main" === t.type && (this.timer || (this.fragCurrent = t, this.timer = setInterval(this.onCheck, 100)), !this._bwEstimator)) {
              var r, i, a = this.hls,
                n = a.config,
                s = t.level;
              a.levels[s].details.live ? (r = n.abrEwmaFastLive, i = n.abrEwmaSlowLive) : (r = n.abrEwmaFastVoD, i = n.abrEwmaSlowVoD), this._bwEstimator = new xe(a, i, r, n.abrEwmaDefaultEstimate)
            }
          }, c._abandonRulesCheck = function () {
            var e = this.hls,
              t = e.media,
              r = this.fragCurrent;
            if (r) {
              var i = r.loader;
              if (!i || i.stats && i.stats.aborted) return d.logger.warn("frag loader destroy or aborted, disarm abandonRules"), this.clearTimer(), void(this._nextAutoLevel = -1);
              var a = i.stats;
              if (t && a && (!t.paused && 0 !== t.playbackRate || !t.readyState) && r.autoLevel && r.level) {
                var n = Ce.now() - a.trequest,
                  s = Math.abs(t.playbackRate);
                if (n > 500 * r.duration / s) {
                  var o = e.levels,
                    u = Math.max(1, a.bw ? a.bw / 8 : 1e3 * a.loaded / n),
                    f = o[r.level];
                  if (!f) return;
                  var c = f.realBitrate ? Math.max(f.realBitrate, f.bitrate) : f.bitrate,
                    h = a.total ? a.total : Math.max(a.loaded, Math.round(r.duration * c / 8)),
                    g = t.currentTime,
                    v = (h - a.loaded) / u,
                    p = (K.bufferInfo(t, g, e.config.maxBufferHole).end - g) / s;
                  if (p < 2 * r.duration / s && v > p) {
                    var m, y = e.minAutoLevel;
                    for (m = r.level - 1; m > y; m--) {
                      var E = o[m].realBitrate ? Math.max(o[m].realBitrate, o[m].bitrate) : o[m].bitrate;
                      if (r.duration * E / (6.4 * u) < p) break
                    }
                    void 0 < v && (d.logger.warn("loading too slow, abort fragment loading and switch to level " + m + ":fragLoadedDelay[" + m + "]<fragLoadedDelay[" + (r.level - 1) + "];bufferStarvationDelay:" + (void 0).toFixed(1) + "<" + v.toFixed(1) + ":" + p.toFixed(1)), e.nextLoadLevel = m, this._bwEstimator.sample(n, a.loaded), i.abort(), this.clearTimer(), e.trigger(l.default.FRAG_LOAD_EMERGENCY_ABORTED, {
                      frag: r,
                      stats: a
                    }))
                  }
                }
              }
            }
          }, c.onFragLoaded = function (e) {
            var t = e.frag;
            if ("main" === t.type && Object(o.isFiniteNumber)(t.sn)) {
              if (this.clearTimer(), this.lastLoadedFragLevel = t.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
                var r = this.hls.levels[t.level],
                  i = (r.loaded ? r.loaded.bytes : 0) + e.stats.loaded,
                  a = (r.loaded ? r.loaded.duration : 0) + e.frag.duration;
                r.loaded = {
                  bytes: i,
                  duration: a
                }, r.realBitrate = Math.round(8 * i / a)
              }
              if (e.frag.bitrateTest) {
                var n = e.stats;
                n.tparsed = n.tbuffered = n.tload, this.onFragBuffered(e)
              }
            }
          }, c.onFragBuffered = function (e) {
            var t = e.stats,
              r = e.frag;
            if (!0 !== t.aborted && "main" === r.type && Object(o.isFiniteNumber)(r.sn) && (!r.bitrateTest || t.tload === t.tbuffered)) {
              var i = t.tparsed - t.trequest;
              d.logger.log("latency/loading/parsing/append/kbps:" + Math.round(t.tfirst - t.trequest) + "/" + Math.round(t.tload - t.tfirst) + "/" + Math.round(t.tparsed - t.tload) + "/" + Math.round(t.tbuffered - t.tparsed) + "/" + Math.round(8 * t.loaded / (t.tbuffered - t.trequest))), this._bwEstimator.sample(i, t.loaded), t.bwEstimate = this._bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = i / 1e3 : this.bitrateTestDelay = 0
            }
          }, c.onError = function (e) {
            switch (e.details) {
            case s.ErrorDetails.FRAG_LOAD_ERROR:
            case s.ErrorDetails.FRAG_LOAD_TIMEOUT:
              this.clearTimer()
            }
          }, c.clearTimer = function () {
            clearInterval(this.timer), this.timer = null
          }, c._findBestLevel = function (e, t, r, i, a, n, s, o, l) {
            for (var u = a; u >= i; u--) {
              var f = l[u];
              if (f) {
                var c = f.details,
                  h = c ? c.totalduration / c.fragments.length : t,
                  g = !!c && c.live,
                  v = void 0;
                v = u <= e ? s * r : o * r;
                var p = l[u].realBitrate ? Math.max(l[u].realBitrate, l[u].bitrate) : l[u].bitrate,
                  m = p * h / v;
                if (d.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + u + "/" + Math.round(v) + "/" + p + "/" + h + "/" + n + "/" + m), v > p && (!m || g && !this.bitrateTestDelay || m < n)) return u
              }
            }
            return -1
          }, a = i, (n = [{
            key: "nextAutoLevel",
            get: function () {
              var e = this._nextAutoLevel,
                t = this._bwEstimator;
              if (!(-1 === e || t && t.canEstimate())) return e;
              var r = this._nextABRAutoLevel;
              return -1 !== e && (r = Math.min(e, r)), r
            },
            set: function (e) {
              this._nextAutoLevel = e
            }
          }, {
            key: "_nextABRAutoLevel",
            get: function () {
              var e = this.hls,
                t = e.maxAutoLevel,
                r = e.levels,
                i = e.config,
                a = e.minAutoLevel,
                n = e.media,
                s = this.lastLoadedFragLevel,
                o = this.fragCurrent ? this.fragCurrent.duration : 0,
                l = n ? n.currentTime : 0,
                u = n && 0 !== n.playbackRate ? Math.abs(n.playbackRate) : 1,
                f = this._bwEstimator ? this._bwEstimator.getEstimate() : i.abrEwmaDefaultEstimate,
                c = (K.bufferInfo(n, l, i.maxBufferHole).end - l) / u,
                h = this._findBestLevel(s, o, f, a, t, c, i.abrBandWidthFactor, i.abrBandWidthUpFactor, r);
              if (h >= 0) return h;
              d.logger.trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering");
              var g = o ? Math.min(o, i.maxStarvationDelay) : i.maxStarvationDelay,
                v = i.abrBandWidthFactor,
                p = i.abrBandWidthUpFactor;
              if (0 === c) {
                var m = this.bitrateTestDelay;
                m && (g = (o ? Math.min(o, i.maxLoadingDelay) : i.maxLoadingDelay) - m, d.logger.trace("bitrate test took " + Math.round(1e3 * m) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * g) + " ms"), v = p = 1)
              }
              return h = this._findBestLevel(s, o, f, a, t, c + g, v, p, r), Math.max(h, 0)
            }
          }]) && Ie(a.prototype, n), u && Ie(a, u), i
        }(f);
      var Fe = Y(),
        Me = function (e) {
          var t, r;

          function i(t) {
            var r;
            return (r = e.call(this, t, l.default.MEDIA_ATTACHING, l.default.MEDIA_DETACHING, l.default.MANIFEST_PARSED, l.default.BUFFER_RESET, l.default.BUFFER_APPENDING, l.default.BUFFER_CODECS, l.default.BUFFER_EOS, l.default.BUFFER_FLUSHING, l.default.LEVEL_PTS_UPDATED, l.default.LEVEL_UPDATED) || this)._msDuration = null, r._levelDuration = null, r._levelTargetDuration = 10, r._live = null, r._objectUrl = null, r._needsFlush = !1, r._needsEos = !1, r.config = void 0, r.audioTimestampOffset = void 0, r.bufferCodecEventsExpected = 0, r._bufferCodecEventsTotal = 0, r.media = null, r.mediaSource = null, r.segments = [], r.parent = void 0, r.appending = !1, r.appended = 0, r.appendError = 0, r.flushBufferCounter = 0, r.tracks = {}, r.pendingTracks = {}, r.sourceBuffer = {}, r.flushRange = [], r._onMediaSourceOpen = function () {
              d.logger.log("media source opened"), r.hls.trigger(l.default.MEDIA_ATTACHED, {
                media: r.media
              });
              var e = r.mediaSource;
              e && e.removeEventListener("sourceopen", r._onMediaSourceOpen), r.checkPendingTracks()
            }, r._onMediaSourceClose = function () {
              d.logger.log("media source closed")
            }, r._onMediaSourceEnded = function () {
              d.logger.log("media source ended")
            }, r._onSBUpdateEnd = function () {
              if (r.audioTimestampOffset && r.sourceBuffer.audio) {
                var e = r.sourceBuffer.audio;
                d.logger.warn("change mpeg audio timestamp offset from " + e.timestampOffset + " to " + r.audioTimestampOffset), e.timestampOffset = r.audioTimestampOffset, delete r.audioTimestampOffset
              }
              r._needsFlush && r.doFlush(), r._needsEos && r.checkEos(), r.appending = !1;
              var t = r.parent,
                i = r.segments.reduce((function (e, r) {
                  return r.parent === t ? e + 1 : e
                }), 0),
                a = {},
                n = r.sourceBuffer;
              for (var s in n) {
                var o = n[s];
                if (!o) throw Error("handling source buffer update end error: source buffer for " + s + " uninitilized and unable to update buffered TimeRanges.");
                a[s] = o.buffered
              }
              r.hls.trigger(l.default.BUFFER_APPENDED, {
                parent: t,
                pending: i,
                timeRanges: a
              }), r._needsFlush || r.doAppending(), r.updateMediaElementDuration(), 0 === i && r.flushLiveBackBuffer()
            }, r._onSBUpdateError = function (e) {
              d.logger.error("sourceBuffer error:", e), r.hls.trigger(l.default.ERROR, {
                type: s.ErrorTypes.MEDIA_ERROR,
                details: s.ErrorDetails.BUFFER_APPENDING_ERROR,
                fatal: !1
              })
            }, r.config = t.config, r
          }
          r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          var a = i.prototype;
          return a.destroy = function () {
            f.prototype.destroy.call(this)
          }, a.onLevelPtsUpdated = function (e) {
            var t = e.type,
              r = this.tracks.audio;
            if ("audio" === t && r && "audio/mpeg" === r.container) {
              var i = this.sourceBuffer.audio;
              if (!i) throw Error("Level PTS Updated and source buffer for audio uninitalized");
              if (Math.abs(i.timestampOffset - e.start) > .1) {
                var a = i.updating;
                try {
                  i.abort()
                } catch (e) {
                  d.logger.warn("can not abort audio buffer: " + e)
                }
                a ? this.audioTimestampOffset = e.start : (d.logger.warn("change mpeg audio timestamp offset from " + i.timestampOffset + " to " + e.start), i.timestampOffset = e.start)
              }
            }
          }, a.onManifestParsed = function (e) {
            var t = 2;
            (e.audio && !e.video || !e.altAudio) && (t = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = t, d.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected")
          }, a.onMediaAttaching = function (e) {
            var t = this.media = e.media;
            if (t && Fe) {
              var r = this.mediaSource = new Fe;
              r.addEventListener("sourceopen", this._onMediaSourceOpen), r.addEventListener("sourceended", this._onMediaSourceEnded), r.addEventListener("sourceclose", this._onMediaSourceClose), t.src = window.URL.createObjectURL(r), this._objectUrl = t.src
            }
          }, a.onMediaDetaching = function () {
            d.logger.log("media source detaching");
            var e = this.mediaSource;
            if (e) {
              if ("open" === e.readyState) try {
                e.endOfStream()
              } catch (e) {
                d.logger.warn("onMediaDetaching:" + e.message + " while calling endOfStream")
              }
              e.removeEventListener("sourceopen", this._onMediaSourceOpen), e.removeEventListener("sourceended", this._onMediaSourceEnded), e.removeEventListener("sourceclose", this._onMediaSourceClose), this.media && (this._objectUrl && window.URL.revokeObjectURL(this._objectUrl), this.media.src === this._objectUrl ? (this.media.removeAttribute("src"), this.media.load()) : d.logger.warn("media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0
            }
            this.hls.trigger(l.default.MEDIA_DETACHED)
          }, a.checkPendingTracks = function () {
            var e = this.bufferCodecEventsExpected,
              t = this.pendingTracks,
              r = Object.keys(t).length;
            (r && !e || 2 === r) && (this.createSourceBuffers(t), this.pendingTracks = {}, this.doAppending())
          }, a.onBufferReset = function () {
            var e = this.sourceBuffer;
            for (var t in e) {
              var r = e[t];
              try {
                r && (this.mediaSource && this.mediaSource.removeSourceBuffer(r), r.removeEventListener("updateend", this._onSBUpdateEnd), r.removeEventListener("error", this._onSBUpdateError))
              } catch (e) {}
            }
            this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0
          }, a.onBufferCodecs = function (e) {
            var t = this;
            Object.keys(this.sourceBuffer).length || (Object.keys(e).forEach((function (r) {
              t.pendingTracks[r] = e[r]
            })), this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks())
          }, a.createSourceBuffers = function (e) {
            var t = this.sourceBuffer,
              r = this.mediaSource;
            if (!r) throw Error("createSourceBuffers called when mediaSource was null");
            for (var i in e)
              if (!t[i]) {
                var a = e[i];
                if (!a) throw Error("source buffer exists for track " + i + ", however track does not");
                var n = a.levelCodec || a.codec,
                  o = a.container + ";codecs=" + n;
                d.logger.log("creating sourceBuffer(" + o + ")");
                try {
                  var u = t[i] = r.addSourceBuffer(o);
                  u.addEventListener("updateend", this._onSBUpdateEnd), u.addEventListener("error", this._onSBUpdateError), this.tracks[i] = {
                    buffer: u,
                    codec: n,
                    id: a.id,
                    container: a.container,
                    levelCodec: a.levelCodec
                  }
                } catch (e) {
                  d.logger.error("error while trying to add sourceBuffer:" + e.message), this.hls.trigger(l.default.ERROR, {
                    type: s.ErrorTypes.MEDIA_ERROR,
                    details: s.ErrorDetails.BUFFER_ADD_CODEC_ERROR,
                    fatal: !1,
                    err: e,
                    mimeType: o
                  })
                }
              } this.hls.trigger(l.default.BUFFER_CREATED, {
              tracks: this.tracks
            })
          }, a.onBufferAppending = function (e) {
            this._needsFlush || (this.segments ? this.segments.push(e) : this.segments = [e], this.doAppending())
          }, a.onBufferEos = function (e) {
            for (var t in this.sourceBuffer)
              if (!e.type || e.type === t) {
                var r = this.sourceBuffer[t];
                r && !r.ended && (r.ended = !0, d.logger.log(t + " sourceBuffer now EOS"))
              } this.checkEos()
          }, a.checkEos = function () {
            var e = this.sourceBuffer,
              t = this.mediaSource;
            if (t && "open" === t.readyState) {
              for (var r in e) {
                var i = e[r];
                if (i) {
                  if (!i.ended) return;
                  if (i.updating) return void(this._needsEos = !0)
                }
              }
              d.logger.log("all media data are available, signal endOfStream() to MediaSource and stop loading fragment");
              try {
                t.endOfStream()
              } catch (e) {
                d.logger.warn("exception while calling mediaSource.endOfStream()")
              }
              this._needsEos = !1
            } else this._needsEos = !1
          }, a.onBufferFlushing = function (e) {
            e.type ? this.flushRange.push({
              start: e.startOffset,
              end: e.endOffset,
              type: e.type
            }) : (this.flushRange.push({
              start: e.startOffset,
              end: e.endOffset,
              type: "video"
            }), this.flushRange.push({
              start: e.startOffset,
              end: e.endOffset,
              type: "audio"
            })), this.flushBufferCounter = 0, this.doFlush()
          }, a.flushLiveBackBuffer = function () {
            if (this._live) {
              var e = this.config.liveBackBufferLength;
              if (isFinite(e) && !(e < 0))
                if (this.media)
                  for (var t = this.media.currentTime, r = this.sourceBuffer, i = Object.keys(r), a = t - Math.max(e, this._levelTargetDuration), n = i.length - 1; n >= 0; n--) {
                    var s = i[n],
                      o = r[s];
                    if (o) {
                      var u = o.buffered;
                      u.length > 0 && a > u.start(0) && this.removeBufferRange(s, o, 0, a) && this.hls.trigger(l.default.LIVE_BACK_BUFFER_REACHED, {
                        bufferEnd: a
                      })
                    }
                  } else d.logger.error("flushLiveBackBuffer called without attaching media")
            }
          }, a.onLevelUpdated = function (e) {
            var t = e.details;
            t.fragments.length > 0 && (this._levelDuration = t.totalduration + t.fragments[0].start, this._levelTargetDuration = t.averagetargetduration || t.targetduration || 10, this._live = t.live, this.updateMediaElementDuration())
          }, a.updateMediaElementDuration = function () {
            var e, t = this.config;
            if (null !== this._levelDuration && this.media && this.mediaSource && this.sourceBuffer && 0 !== this.media.readyState && "open" === this.mediaSource.readyState) {
              for (var r in this.sourceBuffer) {
                var i = this.sourceBuffer[r];
                if (i && !0 === i.updating) return
              }
              e = this.media.duration, null === this._msDuration && (this._msDuration = this.mediaSource.duration), !0 === this._live && !0 === t.liveDurationInfinity ? (d.logger.log("Media Source duration is set to Infinity"), this._msDuration = this.mediaSource.duration = 1 / 0) : (this._levelDuration > this._msDuration && this._levelDuration > e || !Object(o.isFiniteNumber)(e)) && (d.logger.log("Updating Media Source duration to " + this._levelDuration.toFixed(3)), this._msDuration = this.mediaSource.duration = this._levelDuration)
            }
          }, a.doFlush = function () {
            for (; this.flushRange.length;) {
              var e = this.flushRange[0];
              if (!this.flushBuffer(e.start, e.end, e.type)) return void(this._needsFlush = !0);
              this.flushRange.shift(), this.flushBufferCounter = 0
            }
            if (0 === this.flushRange.length) {
              this._needsFlush = !1;
              var t = 0,
                r = this.sourceBuffer;
              try {
                for (var i in r) {
                  var a = r[i];
                  a && (t += a.buffered.length)
                }
              } catch (e) {
                d.logger.error("error while accessing sourceBuffer.buffered")
              }
              this.appended = t, this.hls.trigger(l.default.BUFFER_FLUSHED)
            }
          }, a.doAppending = function () {
            var e = this.config,
              t = this.hls,
              r = this.segments,
              i = this.sourceBuffer;
            if (Object.keys(i).length) {
              if (!this.media || this.media.error) return this.segments = [], void d.logger.error("trying to append although a media error occured, flush segment and abort");
              if (!this.appending) {
                var a = r.shift();
                if (a) try {
                  var n = i[a.type];
                  if (!n) return void this._onSBUpdateEnd();
                  if (n.updating) return void r.unshift(a);
                  n.ended = !1, this.parent = a.parent, n.appendBuffer(a.data), this.appendError = 0, this.appended++, this.appending = !0
                } catch (i) {
                  d.logger.error("error while trying to append buffer:" + i.message), r.unshift(a);
                  var o = {
                    type: s.ErrorTypes.MEDIA_ERROR,
                    parent: a.parent,
                    details: "",
                    fatal: !1
                  };
                  22 === i.code ? (this.segments = [], o.details = s.ErrorDetails.BUFFER_FULL_ERROR) : (this.appendError++, o.details = s.ErrorDetails.BUFFER_APPEND_ERROR, this.appendError > e.appendErrorMaxRetry && (d.logger.log("fail " + e.appendErrorMaxRetry + " times to append segment in sourceBuffer"), this.segments = [], o.fatal = !0)), t.trigger(l.default.ERROR, o)
                }
              }
            }
          }, a.flushBuffer = function (e, t, r) {
            var i = this.sourceBuffer;
            if (!Object.keys(i).length) return !0;
            var a = "null";
            if (this.media && (a = this.media.currentTime.toFixed(3)), d.logger.log("flushBuffer,pos/start/end: " + a + "/" + e + "/" + t), this.flushBufferCounter >= this.appended) return d.logger.warn("abort flushing too many retries"), !0;
            var n = i[r];
            if (n) {
              if (n.ended = !1, n.updating) return d.logger.warn("cannot flush, sb updating in progress"), !1;
              if (this.removeBufferRange(r, n, e, t)) return this.flushBufferCounter++, !1
            }
            return d.logger.log("buffer flushed"), !0
          }, a.removeBufferRange = function (e, t, r, i) {
            try {
              for (var a = 0; a < t.buffered.length; a++) {
                var n = t.buffered.start(a),
                  s = t.buffered.end(a),
                  o = Math.max(n, r),
                  l = Math.min(s, i);
                if (Math.min(l, s) - o > .5) {
                  var u = "null";
                  return this.media && (u = this.media.currentTime.toString()), d.logger.log("sb remove " + e + " [" + o + "," + l + "], of [" + n + "," + s + "], pos:" + u), t.remove(o, l), !0
                }
              }
            } catch (e) {
              d.logger.warn("removeBufferRange failed", e)
            }
            return !1
          }, i
        }(f);

      function Ue(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
      }
      var Ne = function (e) {
        var t, r;

        function i(t) {
          var r;
          return (r = e.call(this, t, l.default.FPS_DROP_LEVEL_CAPPING, l.default.MEDIA_ATTACHING, l.default.MANIFEST_PARSED, l.default.LEVELS_UPDATED, l.default.BUFFER_CODECS, l.default.MEDIA_DETACHING) || this).autoLevelCapping = Number.POSITIVE_INFINITY, r.firstLevel = null, r.levels = [], r.media = null, r.restrictedLevels = [], r.timer = null, r.clientRect = null, r
        }
        r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
        var a, n, s, o = i.prototype;
        return o.destroy = function () {
          this.hls.config.capLevelToPlayerSize && (this.media = null, this.clientRect = null, this.stopCapping())
        }, o.onFpsDropLevelCapping = function (e) {
          i.isLevelAllowed(e.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(e.droppedLevel)
        }, o.onMediaAttaching = function (e) {
          this.media = e.media instanceof window.HTMLVideoElement ? e.media : null
        }, o.onManifestParsed = function (e) {
          var t = this.hls;
          this.restrictedLevels = [], this.levels = e.levels, this.firstLevel = e.firstLevel, t.config.capLevelToPlayerSize && e.video && this.startCapping()
        }, o.onBufferCodecs = function (e) {
          this.hls.config.capLevelToPlayerSize && e.video && this.startCapping()
        }, o.onLevelsUpdated = function (e) {
          this.levels = e.levels
        }, o.onMediaDetaching = function () {
          this.stopCapping()
        }, o.detectPlayerSize = function () {
          if (this.media) {
            var e = this.levels ? this.levels.length : 0;
            if (e) {
              var t = this.hls;
              t.autoLevelCapping = this.getMaxLevel(e - 1), t.autoLevelCapping > this.autoLevelCapping && t.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping
            }
          }
        }, o.getMaxLevel = function (e) {
          var t = this;
          if (!this.levels) return -1;
          var r = this.levels.filter((function (r, a) {
            return i.isLevelAllowed(a, t.restrictedLevels) && a <= e
          }));
          return this.clientRect = null, i.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight)
        }, o.startCapping = function () {
          this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
        }, o.stopCapping = function () {
          this.restrictedLevels = [], this.firstLevel = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer), this.timer = null)
        }, o.getDimensions = function () {
          if (this.clientRect) return this.clientRect;
          var e = this.media,
            t = {
              width: 0,
              height: 0
            };
          if (e) {
            var r = e.getBoundingClientRect();
            t.width = r.width, t.height = r.height, t.width || t.height || (t.width = r.right - r.left || e.width || 0, t.height = r.bottom - r.top || e.height || 0)
          }
          return this.clientRect = t, t
        }, i.isLevelAllowed = function (e, t) {
          return void 0 === t && (t = []), -1 === t.indexOf(e)
        }, i.getMaxLevelByMediaSize = function (e, t, r) {
          if (!e || e && !e.length) return -1;
          for (var i, a, n = e.length - 1, s = 0; s < e.length; s += 1) {
            var o = e[s];
            if ((o.width >= t || o.height >= r) && (i = o, !(a = e[s + 1]) || i.width !== a.width || i.height !== a.height)) {
              n = s;
              break
            }
          }
          return n
        }, a = i, s = [{
          key: "contentScaleFactor",
          get: function () {
            var e = 1;
            try {
              e = window.devicePixelRatio
            } catch (e) {}
            return e
          }
        }], (n = [{
          key: "mediaWidth",
          get: function () {
            return this.getDimensions().width * i.contentScaleFactor
          }
        }, {
          key: "mediaHeight",
          get: function () {
            return this.getDimensions().height * i.contentScaleFactor
          }
        }]) && Ue(a.prototype, n), s && Ue(a, s), i
      }(f);
      var Be, Ge = window.performance,
        je = function (e) {
          var t, r;

          function i(t) {
            return e.call(this, t, l.default.MEDIA_ATTACHING) || this
          }
          r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          var a = i.prototype;
          return a.destroy = function () {
            this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1
          }, a.onMediaAttaching = function (e) {
            var t = this.hls.config;
            t.capLevelOnFPSDrop && ("function" == typeof (this.video = e.media instanceof window.HTMLVideoElement ? e.media : null).getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), t.fpsDroppedMonitoringPeriod))
          }, a.checkFPS = function (e, t, r) {
            var i = Ge.now();
            if (t) {
              if (this.lastTime) {
                var a = i - this.lastTime,
                  n = r - this.lastDroppedFrames,
                  s = t - this.lastDecodedFrames,
                  o = 1e3 * n / a,
                  u = this.hls;
                if (u.trigger(l.default.FPS_DROP, {
                    currentDropped: n,
                    currentDecoded: s,
                    totalDroppedFrames: r
                  }), o > 0 && n > u.config.fpsDroppedMonitoringThreshold * s) {
                  var f = u.currentLevel;
                  d.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + f), f > 0 && (-1 === u.autoLevelCapping || u.autoLevelCapping >= f) && (f -= 1, u.trigger(l.default.FPS_DROP_LEVEL_CAPPING, {
                    level: f,
                    droppedLevel: u.currentLevel
                  }), u.autoLevelCapping = f, u.streamController.nextLevelSwitch())
                }
              }
              this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = t
            }
          }, a.checkFPSInterval = function () {
            var e = this.video;
            if (e)
              if (this.isVideoPlaybackQualityAvailable) {
                var t = e.getVideoPlaybackQuality();
                this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
              } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
          }, i
        }(f),
        Ke = function () {
          function e(e) {
            e && e.xhrSetup && (this.xhrSetup = e.xhrSetup)
          }
          var t = e.prototype;
          return t.destroy = function () {
            this.abort(), this.loader = null
          }, t.abort = function () {
            var e = this.loader;
            e && 4 !== e.readyState && (this.stats.aborted = !0, e.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null
          }, t.load = function (e, t, r) {
            this.context = e, this.config = t, this.callbacks = r, this.stats = {
              trequest: window.performance.now(),
              retry: 0
            }, this.retryDelay = t.retryDelay, this.loadInternal()
          }, t.loadInternal = function () {
            var e, t = this.context;
            e = this.loader = new window.XMLHttpRequest;
            var r = this.stats;
            r.tfirst = 0, r.loaded = 0;
            var i = this.xhrSetup;
            try {
              if (i) try {
                i(e, t.url)
              } catch (r) {
                e.open("GET", t.url, !0), i(e, t.url)
              }
              e.readyState || e.open("GET", t.url, !0)
            } catch (r) {
              return void this.callbacks.onError({
                code: e.status,
                text: r.message
              }, t, e)
            }
            t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), e.send()
          }, t.readystatechange = function (e) {
            var t = e.currentTarget,
              r = t.readyState,
              i = this.stats,
              a = this.context,
              n = this.config;
            if (!i.aborted && r >= 2)
              if (window.clearTimeout(this.requestTimeout), 0 === i.tfirst && (i.tfirst = Math.max(window.performance.now(), i.trequest)), 4 === r) {
                var s = t.status;
                if (s >= 200 && s < 300) {
                  var o, l;
                  i.tload = Math.max(i.tfirst, window.performance.now()), l = "arraybuffer" === a.responseType ? (o = t.response).byteLength : (o = t.responseText).length, i.loaded = i.total = l;
                  var u = {
                    url: t.responseURL,
                    data: o
                  };
                  this.callbacks.onSuccess(u, i, a, t)
                } else i.retry >= n.maxRetry || s >= 400 && s < 499 ? (d.logger.error(s + " while loading " + a.url), this.callbacks.onError({
                  code: s,
                  text: t.statusText
                }, a, t)) : (d.logger.warn(s + " while loading " + a.url + ", retrying in " + this.retryDelay + "..."), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, n.maxRetryDelay), i.retry++)
              } else this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), n.timeout)
          }, t.loadtimeout = function () {
            d.logger.warn("timeout while loading " + this.context.url), this.callbacks.onTimeout(this.stats, this.context, null)
          }, t.loadprogress = function (e) {
            var t = e.currentTarget,
              r = this.stats;
            r.loaded = e.loaded, e.lengthComputable && (r.total = e.total);
            var i = this.callbacks.onProgress;
            i && i(r, this.context, null, t)
          }, e
        }(),
        He = r("./src/empty.js");

      function Ve(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var i = Object.getOwnPropertySymbols(e);
          t && (i = i.filter((function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
          }))), r.push.apply(r, i)
        }
        return r
      }

      function We(e) {
        for (var t = 1; t < arguments.length; t++) {
          var r = null != arguments[t] ? arguments[t] : {};
          t % 2 ? Ve(Object(r), !0).forEach((function (t) {
            Ye(e, t, r[t])
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ve(Object(r)).forEach((function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
          }))
        }
        return e
      }

      function Ye(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[t] = r, e
      }! function (e) {
        e.WIDEVINE = "com.widevine.alpha", e.PLAYREADY = "com.microsoft.playready"
      }(Be || (Be = {}));
      var ze = We(We({
        autoStartLoad: !0,
        startPosition: -1,
        defaultAudioCodec: void 0,
        debug: !1,
        capLevelOnFPSDrop: !1,
        capLevelToPlayerSize: !1,
        initialLiveManifestSize: 1,
        maxBufferLength: 30,
        maxBufferSize: 6e7,
        maxBufferHole: .5,
        lowBufferWatchdogPeriod: .5,
        highBufferWatchdogPeriod: 3,
        nudgeOffset: .1,
        nudgeMaxRetry: 3,
        maxFragLookUpTolerance: .25,
        liveSyncDurationCount: 3,
        liveMaxLatencyDurationCount: 1 / 0,
        liveSyncDuration: void 0,
        liveMaxLatencyDuration: void 0,
        liveDurationInfinity: !1,
        liveBackBufferLength: 1 / 0,
        maxMaxBufferLength: 600,
        enableWorker: !0,
        enableSoftwareAES: !0,
        manifestLoadingTimeOut: 1e4,
        manifestLoadingMaxRetry: 1,
        manifestLoadingRetryDelay: 1e3,
        manifestLoadingMaxRetryTimeout: 64e3,
        startLevel: void 0,
        levelLoadingTimeOut: 1e4,
        levelLoadingMaxRetry: 4,
        levelLoadingRetryDelay: 1e3,
        levelLoadingMaxRetryTimeout: 64e3,
        fragLoadingTimeOut: 2e4,
        fragLoadingMaxRetry: 6,
        fragLoadingRetryDelay: 1e3,
        fragLoadingMaxRetryTimeout: 64e3,
        startFragPrefetch: !1,
        fpsDroppedMonitoringPeriod: 5e3,
        fpsDroppedMonitoringThreshold: .2,
        appendErrorMaxRetry: 3,
        loader: Ke,
        fLoader: void 0,
        pLoader: void 0,
        xhrSetup: void 0,
        licenseXhrSetup: void 0,
        abrController: Pe,
        bufferController: Me,
        capLevelController: Ne,
        fpsController: je,
        stretchShortVideoTrack: !1,
        maxAudioFramesDrift: 1,
        forceKeyFrameOnDiscontinuity: !0,
        abrEwmaFastLive: 3,
        abrEwmaSlowLive: 9,
        abrEwmaFastVoD: 3,
        abrEwmaSlowVoD: 9,
        abrEwmaDefaultEstimate: 5e5,
        abrBandWidthFactor: .95,
        abrBandWidthUpFactor: .7,
        abrMaxWithRealBitrate: !1,
        maxStarvationDelay: 4,
        maxLoadingDelay: 4,
        minAutoBitrate: 0,
        emeEnabled: !1,
        widevineLicenseUrl: void 0,
        drmSystemOptions: {},
        requestMediaKeySystemAccessFunc: "undefined" != typeof window && window.navigator && window.navigator.requestMediaKeySystemAccess ? window.navigator.requestMediaKeySystemAccess.bind(window.navigator) : null,
        testBandwidth: !0
      }, {
        cueHandler: He,
        enableCEA708Captions: !1,
        enableWebVTT: !1,
        captionsTextTrack1Label: "English",
        captionsTextTrack1LanguageCode: "en",
        captionsTextTrack2Label: "Spanish",
        captionsTextTrack2LanguageCode: "es",
        captionsTextTrack3Label: "Unknown CC",
        captionsTextTrack3LanguageCode: "",
        captionsTextTrack4Label: "Unknown CC",
        captionsTextTrack4LanguageCode: "",
        renderTextTracksNatively: !0
      }), {}, {
        subtitleStreamController: void 0,
        subtitleTrackController: void 0,
        timelineController: void 0,
        audioStreamController: void 0,
        audioTrackController: void 0,
        emeController: void 0
      });

      function Xe(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var i = Object.getOwnPropertySymbols(e);
          t && (i = i.filter((function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
          }))), r.push.apply(r, i)
        }
        return r
      }

      function qe(e) {
        for (var t = 1; t < arguments.length; t++) {
          var r = null != arguments[t] ? arguments[t] : {};
          t % 2 ? Xe(Object(r), !0).forEach((function (t) {
            Qe(e, t, r[t])
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Xe(Object(r)).forEach((function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
          }))
        }
        return e
      }

      function Qe(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[t] = r, e
      }

      function Ze(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
      }

      function Je(e, t) {
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
      }

      function $e(e, t, r) {
        return t && Je(e.prototype, t), r && Je(e, r), e
      }
      var et = function (e) {
        var t, r;

        function i(t) {
          var r;
          void 0 === t && (t = {}), (r = e.call(this) || this).config = void 0, r._autoLevelCapping = void 0, r.abrController = void 0, r.capLevelController = void 0, r.levelController = void 0, r.streamController = void 0, r.networkControllers = void 0, r.audioTrackController = void 0, r.subtitleTrackController = void 0, r.emeController = void 0, r.coreComponents = void 0, r.media = null, r.url = null;
          var a = i.DefaultConfig;
          if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
          r.config = qe(qe({}, a), t);
          var n = Ze(r).config;
          if (void 0 !== n.liveMaxLatencyDurationCount && n.liveMaxLatencyDurationCount <= n.liveSyncDurationCount) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
          if (void 0 !== n.liveMaxLatencyDuration && (void 0 === n.liveSyncDuration || n.liveMaxLatencyDuration <= n.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
          Object(d.enableLogs)(n.debug), r._autoLevelCapping = -1;
          var s = r.abrController = new n.abrController(Ze(r)),
            o = new n.bufferController(Ze(r)),
            l = r.capLevelController = new n.capLevelController(Ze(r)),
            u = new n.fpsController(Ze(r)),
            f = new C(Ze(r)),
            c = new P(Ze(r)),
            h = new F(Ze(r)),
            g = new ke(Ze(r)),
            v = r.levelController = new Le(Ze(r)),
            p = new G(Ze(r)),
            m = [v, r.streamController = new Ae(Ze(r), p)],
            y = n.audioStreamController;
          y && m.push(new y(Ze(r), p)), r.networkControllers = m;
          var E = [f, c, h, s, o, l, u, g, p];
          if (y = n.audioTrackController) {
            var b = new y(Ze(r));
            r.audioTrackController = b, E.push(b)
          }
          if (y = n.subtitleTrackController) {
            var T = new y(Ze(r));
            r.subtitleTrackController = T, m.push(T)
          }
          if (y = n.emeController) {
            var S = new y(Ze(r));
            r.emeController = S, E.push(S)
          }
          return (y = n.subtitleStreamController) && m.push(new y(Ze(r), p)), (y = n.timelineController) && E.push(new y(Ze(r))), r.coreComponents = E, r
        }
        r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, i.isSupported = function () {
          return function () {
            var e = Y();
            if (!e) return !1;
            var t = self.SourceBuffer || self.WebKitSourceBuffer,
              r = e && "function" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
              i = !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove;
            return !!r && !!i
          }()
        }, $e(i, null, [{
          key: "version",
          get: function () {
            return "0.14.0"
          }
        }, {
          key: "Events",
          get: function () {
            return l.default
          }
        }, {
          key: "ErrorTypes",
          get: function () {
            return s.ErrorTypes
          }
        }, {
          key: "ErrorDetails",
          get: function () {
            return s.ErrorDetails
          }
        }, {
          key: "DefaultConfig",
          get: function () {
            return i.defaultConfig ? i.defaultConfig : ze
          },
          set: function (e) {
            i.defaultConfig = e
          }
        }]);
        var a = i.prototype;
        return a.destroy = function () {
          d.logger.log("destroy"), this.trigger(l.default.DESTROYING), this.detachMedia(), this.coreComponents.concat(this.networkControllers).forEach((function (e) {
            e.destroy()
          })), this.url = null, this.removeAllListeners(), this._autoLevelCapping = -1
        }, a.attachMedia = function (e) {
          d.logger.log("attachMedia"), this.media = e, this.trigger(l.default.MEDIA_ATTACHING, {
            media: e
          })
        }, a.detachMedia = function () {
          d.logger.log("detachMedia"), this.trigger(l.default.MEDIA_DETACHING), this.media = null
        }, a.loadSource = function (e) {
          e = n.buildAbsoluteURL(window.location.href, e, {
            alwaysNormalize: !0
          }), d.logger.log("loadSource:" + e), this.url = e, this.trigger(l.default.MANIFEST_LOADING, {
            url: e
          })
        }, a.startLoad = function (e) {
          void 0 === e && (e = -1), d.logger.log("startLoad(" + e + ")"), this.networkControllers.forEach((function (t) {
            t.startLoad(e)
          }))
        }, a.stopLoad = function () {
          d.logger.log("stopLoad"), this.networkControllers.forEach((function (e) {
            e.stopLoad()
          }))
        }, a.swapAudioCodec = function () {
          d.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec()
        }, a.recoverMediaError = function () {
          d.logger.log("recoverMediaError");
          var e = this.media;
          this.detachMedia(), e && this.attachMedia(e)
        }, a.removeLevel = function (e, t) {
          void 0 === t && (t = 0), this.levelController.removeLevel(e, t)
        }, $e(i, [{
          key: "levels",
          get: function () {
            return this.levelController.levels
          }
        }, {
          key: "currentLevel",
          get: function () {
            return this.streamController.currentLevel
          },
          set: function (e) {
            d.logger.log("set currentLevel:" + e), this.loadLevel = e, this.streamController.immediateLevelSwitch()
          }
        }, {
          key: "nextLevel",
          get: function () {
            return this.streamController.nextLevel
          },
          set: function (e) {
            d.logger.log("set nextLevel:" + e), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch()
          }
        }, {
          key: "loadLevel",
          get: function () {
            return this.levelController.level
          },
          set: function (e) {
            d.logger.log("set loadLevel:" + e), this.levelController.manualLevel = e
          }
        }, {
          key: "nextLoadLevel",
          get: function () {
            return this.levelController.nextLoadLevel
          },
          set: function (e) {
            this.levelController.nextLoadLevel = e
          }
        }, {
          key: "firstLevel",
          get: function () {
            return Math.max(this.levelController.firstLevel, this.minAutoLevel)
          },
          set: function (e) {
            d.logger.log("set firstLevel:" + e), this.levelController.firstLevel = e
          }
        }, {
          key: "startLevel",
          get: function () {
            return this.levelController.startLevel
          },
          set: function (e) {
            d.logger.log("set startLevel:" + e), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e
          }
        }, {
          key: "capLevelToPlayerSize",
          set: function (e) {
            var t = !!e;
            t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t)
          }
        }, {
          key: "autoLevelCapping",
          get: function () {
            return this._autoLevelCapping
          },
          set: function (e) {
            d.logger.log("set autoLevelCapping:" + e), this._autoLevelCapping = e
          }
        }, {
          key: "bandwidthEstimate",
          get: function () {
            var e = this.abrController._bwEstimator;
            return e ? e.getEstimate() : NaN
          }
        }, {
          key: "autoLevelEnabled",
          get: function () {
            return -1 === this.levelController.manualLevel
          }
        }, {
          key: "manualLevel",
          get: function () {
            return this.levelController.manualLevel
          }
        }, {
          key: "minAutoLevel",
          get: function () {
            for (var e = this.levels, t = this.config.minAutoBitrate, r = e ? e.length : 0, i = 0; i < r; i++) {
              if ((e[i].realBitrate ? Math.max(e[i].realBitrate, e[i].bitrate) : e[i].bitrate) > t) return i
            }
            return 0
          }
        }, {
          key: "maxAutoLevel",
          get: function () {
            var e = this.levels,
              t = this.autoLevelCapping;
            return -1 === t && e && e.length ? e.length - 1 : t
          }
        }, {
          key: "nextAutoLevel",
          get: function () {
            return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
          },
          set: function (e) {
            this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e)
          }
        }, {
          key: "audioTracks",
          get: function () {
            var e = this.audioTrackController;
            return e ? e.audioTracks : []
          }
        }, {
          key: "audioTrack",
          get: function () {
            var e = this.audioTrackController;
            return e ? e.audioTrack : -1
          },
          set: function (e) {
            var t = this.audioTrackController;
            t && (t.audioTrack = e)
          }
        }, {
          key: "liveSyncPosition",
          get: function () {
            return this.streamController.liveSyncPosition
          }
        }, {
          key: "subtitleTracks",
          get: function () {
            var e = this.subtitleTrackController;
            return e ? e.subtitleTracks : []
          }
        }, {
          key: "subtitleTrack",
          get: function () {
            var e = this.subtitleTrackController;
            return e ? e.subtitleTrack : -1
          },
          set: function (e) {
            var t = this.subtitleTrackController;
            t && (t.subtitleTrack = e)
          }
        }, {
          key: "subtitleDisplay",
          get: function () {
            var e = this.subtitleTrackController;
            return !!e && e.subtitleDisplay
          },
          set: function (e) {
            var t = this.subtitleTrackController;
            t && (t.subtitleDisplay = e)
          }
        }]), i
      }(X);
      et.defaultConfig = void 0
    },
    "./src/polyfills/number-isFinite.js": function (e, t, r) {
      "use strict";
      r.r(t), r.d(t, "isFiniteNumber", (function () {
        return i
      }));
      var i = Number.isFinite || function (e) {
        return "number" == typeof e && isFinite(e)
      }
    },
    "./src/utils/get-self-scope.js": function (e, t, r) {
      "use strict";

      function i() {
        return "undefined" == typeof window ? self : window
      }
      r.r(t), r.d(t, "getSelfScope", (function () {
        return i
      }))
    },
    "./src/utils/logger.js": function (e, t, r) {
      "use strict";
      r.r(t), r.d(t, "enableLogs", (function () {
        return u
      })), r.d(t, "logger", (function () {
        return f
      }));
      var i = r("./src/utils/get-self-scope.js");

      function a() {}
      var n = {
          trace: a,
          debug: a,
          log: a,
          warn: a,
          info: a,
          error: a
        },
        s = n;

      function o(e, t) {
        return t = "[" + e + "] > " + t
      }
      var l = Object(i.getSelfScope)();

      function d(e) {
        var t = l.console[e];
        return t ? function () {
          for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++) i[a] = arguments[a];
          i[0] && (i[0] = o(e, i[0])), t.apply(l.console, i)
        } : a
      }
      var u = function (e) {
          if (l.console && !0 === e || "object" == typeof e) {
            ! function (e) {
              for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) r[i - 1] = arguments[i];
              r.forEach((function (t) {
                s[t] = e[t] ? e[t].bind(e) : d(t)
              }))
            }(e, "debug", "log", "info", "warn", "error");
            try {
              s.log()
            } catch (e) {
              s = n
            }
          } else s = n
        },
        f = s
    }
  }).default
}));
(e => {
  const t = {
      log: () => {},
      error: () => {},
      warn: () => {},
      debug: () => {},
      trace: () => {}
    },
    r = {
      MEDIA_ATTACHING: "hlsMediaAttaching",
      MEDIA_ATTACHED: "hlsMediaAttached",
      MEDIA_DETACHING: "hlsMediaDetaching",
      MEDIA_DETACHED: "hlsMediaDetached",
      BUFFER_RESET: "hlsBufferReset",
      BUFFER_CODECS: "hlsBufferCodecs",
      BUFFER_CREATED: "hlsBufferCreated",
      BUFFER_APPENDING: "hlsBufferAppending",
      BUFFER_APPENDED: "hlsBufferAppended",
      BUFFER_EOS: "hlsBufferEos",
      BUFFER_FLUSHING: "hlsBufferFlushing",
      BUFFER_FLUSHED: "hlsBufferFlushed",
      MANIFEST_LOADING: "hlsManifestLoading",
      MANIFEST_LOADED: "hlsManifestLoaded",
      MANIFEST_PARSED: "hlsManifestParsed",
      LEVEL_SWITCHING: "hlsLevelSwitching",
      LEVEL_SWITCHED: "hlsLevelSwitched",
      LEVEL_LOADING: "hlsLevelLoading",
      LEVEL_LOADED: "hlsLevelLoaded",
      LEVEL_UPDATED: "hlsLevelUpdated",
      LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated",
      LEVELS_UPDATED: "hlsLevelsUpdated",
      AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated",
      AUDIO_TRACK_SWITCHING: "hlsAudioTrackSwitching",
      AUDIO_TRACK_SWITCHED: "hlsAudioTrackSwitched",
      AUDIO_TRACK_LOADING: "hlsAudioTrackLoading",
      AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded",
      SUBTITLE_TRACKS_UPDATED: "hlsSubtitleTracksUpdated",
      SUBTITLE_TRACK_SWITCH: "hlsSubtitleTrackSwitch",
      SUBTITLE_TRACK_LOADING: "hlsSubtitleTrackLoading",
      SUBTITLE_TRACK_LOADED: "hlsSubtitleTrackLoaded",
      SUBTITLE_FRAG_PROCESSED: "hlsSubtitleFragProcessed",
      CUES_PARSED: "hlsCuesParsed",
      NON_NATIVE_TEXT_TRACKS_FOUND: "hlsNonNativeTextTracksFound",
      INIT_PTS_FOUND: "hlsInitPtsFound",
      FRAG_LOADING: "hlsFragLoading",
      FRAG_LOAD_PROGRESS: "hlsFragLoadProgress",
      FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted",
      FRAG_LOADED: "hlsFragLoaded",
      FRAG_DECRYPTED: "hlsFragDecrypted",
      FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment",
      FRAG_PARSING_USERDATA: "hlsFragParsingUserdata",
      FRAG_PARSING_METADATA: "hlsFragParsingMetadata",
      FRAG_PARSING_DATA: "hlsFragParsingData",
      FRAG_PARSED: "hlsFragParsed",
      FRAG_BUFFERED: "hlsFragBuffered",
      FRAG_CHANGED: "hlsFragChanged",
      FPS_DROP: "hlsFpsDrop",
      FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping",
      ERROR: "hlsError",
      DESTROYING: "hlsDestroying",
      KEY_LOADING: "hlsKeyLoading",
      KEY_LOADED: "hlsKeyLoaded",
      STREAM_STATE_TRANSITION: "hlsStreamStateTransition",
      LIVE_BACK_BUFFER_REACHED: "hlsLiveBackBufferReached"
    };
  var a, s;
  ! function (e) {
    e.NETWORK_ERROR = "networkError", e.MEDIA_ERROR = "mediaError", e.KEY_SYSTEM_ERROR = "keySystemError", e.MUX_ERROR = "muxError", e.OTHER_ERROR = "otherError"
  }(a || (a = {})),
  function (e) {
    e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e.KEY_SYSTEM_NO_INIT_DATA = "keySystemNoInitData", e.MANIFEST_LOAD_ERROR = "manifestLoadError", e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e.MANIFEST_PARSING_ERROR = "manifestParsingError", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e.LEVEL_EMPTY_ERROR = "levelEmptyError", e.LEVEL_LOAD_ERROR = "levelLoadError", e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e.LEVEL_SWITCH_ERROR = "levelSwitchError", e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e.FRAG_LOAD_ERROR = "fragLoadError", e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e.FRAG_DECRYPT_ERROR = "fragDecryptError", e.FRAG_PARSING_ERROR = "fragParsingError", e.REMUX_ALLOC_ERROR = "remuxAllocError", e.KEY_LOAD_ERROR = "keyLoadError", e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e.BUFFER_APPEND_ERROR = "bufferAppendError", e.BUFFER_APPENDING_ERROR = "bufferAppendingError", e.BUFFER_STALLED_ERROR = "bufferStalledError", e.BUFFER_FULL_ERROR = "bufferFullError", e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e.INTERNAL_EXCEPTION = "internalException"
  }(s || (s = {}));

  function i(e, t, r, a) {
    void 0 === r && (r = 1), void 0 === a && (a = !1);
    var s = e * t * r;
    return a ? Math.round(s) : s
  }

  function n(e, t) {
    return void 0 === t && (t = !1), i(e, 1e3, 1 / 9e4, t)
  }

  function o(e, t) {
    return void 0 === t && (t = 1), i(e, 9e4, 1 / t)
  }
  const l = /^(\d+)x(\d+)$/,
    d = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
  class h {
    constructor(e) {
      "string" == typeof e && (e = h.parseAttrList(e));
      for (let t in e) e.hasOwnProperty(t) && (this[t] = e[t])
    }
    decimalInteger(e) {
      const t = parseInt(this[e], 10);
      return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
    }
    hexadecimalInteger(e) {
      if (this[e]) {
        let t = (this[e] || "0x").slice(2);
        t = (1 & t.length ? "0" : "") + t;
        const r = new Uint8Array(t.length / 2);
        for (let e = 0; e < t.length / 2; e++) r[e] = parseInt(t.slice(2 * e, 2 * e + 2), 16);
        return r
      }
      return null
    }
    hexadecimalIntegerAsNumber(e) {
      const t = parseInt(this[e], 16);
      return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
    }
    decimalFloatingPoint(e) {
      return parseFloat(this[e])
    }
    enumeratedString(e) {
      return this[e]
    }
    decimalResolution(e) {
      const t = l.exec(this[e]);
      if (null !== t) return {
        width: parseInt(t[1], 10),
        height: parseInt(t[2], 10)
      }
    }
    static parseAttrList(e) {
      let t, r = {};
      for (d.lastIndex = 0; null !== (t = d.exec(e));) {
        let e = t[2],
          a = '"';
        0 === e.indexOf(a) && e.lastIndexOf(a) === e.length - 1 && (e = e.slice(1, -1)), r[t[1]] = e
      }
      return r
    }
  }
  var c = {
    audio: {
      a3ds: !0,
      "ac-3": !0,
      "ac-4": !0,
      alac: !0,
      alaw: !0,
      dra1: !0,
      "dts+": !0,
      "dts-": !0,
      dtsc: !0,
      dtse: !0,
      dtsh: !0,
      "ec-3": !0,
      enca: !0,
      g719: !0,
      g726: !0,
      m4ae: !0,
      mha1: !0,
      mha2: !0,
      mhm1: !0,
      mhm2: !0,
      mlpa: !0,
      mp4a: !0,
      "raw ": !0,
      Opus: !0,
      samr: !0,
      sawb: !0,
      sawp: !0,
      sevc: !0,
      sqcp: !0,
      ssmv: !0,
      twos: !0,
      ulaw: !0
    },
    video: {
      avc1: !0,
      avc2: !0,
      avc3: !0,
      avc4: !0,
      avcp: !0,
      drac: !0,
      dvav: !0,
      dvhe: !0,
      encv: !0,
      hev1: !0,
      hvc1: !0,
      mjp2: !0,
      mp4v: !0,
      mvc1: !0,
      mvc2: !0,
      mvc3: !0,
      mvc4: !0,
      resv: !0,
      rv60: !0,
      s263: !0,
      svc1: !0,
      svc2: !0,
      "vc-1": !0,
      vp08: !0,
      vp09: !0
    }
  };

  function u() {
    return "undefined" == typeof window ? self : window
  }

  function p(e, i, n, o) {
    let l, d, h, c, u, p = "Android".toLowerCase(),
      f = o,
      m = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
    if (l = 1 + ((192 & i[n + 2]) >>> 6), d = (60 & i[n + 2]) >>> 2, !(d > m.length - 1)) return c = (1 & i[n + 2]) << 2, c |= (192 & i[n + 3]) >>> 6, t.log(`manifest codec:${o},ADTS data:type:${l},sampleingIndex:${d}[${m[d]}Hz],channelConfig:${c}`), /firefox/i.test(p) ? d >= 6 ? (l = 5, u = new Array(4), h = d - 3) : (l = 2, u = new Array(2), h = d) : -1 !== p.indexOf("android") ? (l = 2, u = new Array(2), h = d) : (l = 5, u = new Array(4), o && (-1 !== o.indexOf("mp4a.40.29") || -1 !== o.indexOf("mp4a.40.5")) || !o && d >= 6 ? h = d - 3 : ((o && -1 !== o.indexOf("mp4a.40.2") && (d >= 6 && 1 === c || /vivaldi/i.test(p)) || !o && 1 === c) && (l = 2, u = new Array(2)), h = d)), u[0] = l << 3, u[0] |= (14 & d) >> 1, u[1] |= (1 & d) << 7, u[1] |= c << 3, 5 === l && (u[1] |= (14 & h) >> 1, u[2] = (1 & h) << 7, u[2] |= 8, u[3] = 0), {
      config: u,
      samplerate: m[d],
      channelCount: c,
      codec: "mp4a.40." + l,
      manifestCodec: f
    };
    e.trigger(r.ERROR, {
      type: a.MEDIA_ERROR,
      details: s.FRAG_PARSING_ERROR,
      fatal: !0,
      reason: "invalid ADTS sampling index:" + d
    })
  }

  function f(e, t) {
    return 255 === e[t] && 240 == (246 & e[t + 1])
  }

  function m(e, t) {
    return 1 & e[t + 1] ? 7 : 9
  }

  function g(e, t) {
    return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5
  }

  function y(e, t) {
    return !!(t + 1 < e.length && f(e, t))
  }

  function A(e) {
    return 9216e4 / e
  }

  function S(e, t, r, a, s) {
    let i, n, o, l = e.length;
    if (i = m(e, t), n = g(e, t), n -= i, n > 0 && t + i + n <= l) return o = r + a * s, {
      headerLength: i,
      frameLength: n,
      stamp: o
    }
  }
  const b = {
      getAudioConfig: p,
      isHeaderPattern: f,
      getHeaderLength: m,
      getFullFrameLength: g,
      isHeader: y,
      probe: function (e, t) {
        if (y(e, t)) {
          let r = m(e, t);
          if (t + r >= e.length) return !1;
          let a = g(e, t);
          if (a <= r) return !1;
          let s = t + a;
          if (s === e.length || s + 1 < e.length && f(e, s)) return !0
        }
        return !1
      },
      initTrackConfig: function (e, r, a, s, i) {
        if (!e.samplerate) {
          let n = p(r, a, s, i);
          e.config = n.config, e.samplerate = n.samplerate, e.channelCount = n.channelCount, e.codec = n.codec, e.manifestCodec = n.manifestCodec, t.log(`parsed codec:${e.codec},rate:${n.samplerate},nb channel:${n.channelCount}`)
        }
      },
      getFrameDuration: A,
      parseFrameHeader: S,
      appendFrame: function (e, t, r, a, s) {
        let i = S(t, r, a, s, A(e.samplerate));
        if (i) {
          let a = i.stamp,
            s = i.headerLength,
            n = i.frameLength,
            o = {
              unit: t.subarray(r + s, r + s + n),
              pts: a,
              dts: a
            };
          return e.samples.push(o), {
            sample: o,
            length: n + s
          }
        }
      }
    },
    E = {
      BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
      SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
      SamplesCoefficients: [
        [0, 72, 144, 12],
        [0, 0, 0, 0],
        [0, 72, 144, 12],
        [0, 144, 144, 12]
      ],
      BytesInSlot: [0, 1, 1, 4],
      appendFrame: function (e, t, r, a, s) {
        if (r + 24 > t.length) return;
        let i = this.parseHeader(t, r);
        if (i && r + i.frameLength <= t.length) {
          let n = a + s * (9e4 * i.samplesPerFrame / i.sampleRate),
            o = {
              unit: t.subarray(r, r + i.frameLength),
              pts: n,
              dts: n
            };
          return e.config = [], e.channelCount = i.channelCount, e.samplerate = i.sampleRate, e.samples.push(o), {
            sample: o,
            length: i.frameLength
          }
        }
      },
      parseHeader: function (e, t) {
        let r = e[t + 1] >> 3 & 3,
          a = e[t + 1] >> 1 & 3,
          s = e[t + 2] >> 4 & 15,
          i = e[t + 2] >> 2 & 3,
          n = e[t + 2] >> 1 & 1;
        if (1 !== r && 0 !== s && 15 !== s && 3 !== i) {
          let o = 3 === r ? 3 - a : 3 === a ? 3 : 4,
            l = 1e3 * E.BitratesMap[14 * o + s - 1],
            d = 3 === r ? 0 : 2 === r ? 1 : 2,
            h = E.SamplingRateMap[3 * d + i],
            c = e[t + 3] >> 6 == 3 ? 1 : 2,
            u = E.SamplesCoefficients[r][a],
            p = E.BytesInSlot[a],
            f = 8 * u * p;
          return {
            sampleRate: h,
            channelCount: c,
            frameLength: parseInt(u * l / h + n, 10) * p,
            samplesPerFrame: f
          }
        }
      },
      isHeaderPattern: function (e, t) {
        return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1])
      },
      isHeader: function (e, t) {
        return !!(t + 1 < e.length && this.isHeaderPattern(e, t))
      },
      probe: function (e, t) {
        if (t + 1 < e.length && this.isHeaderPattern(e, t)) {
          let r = 4,
            a = this.parseHeader(e, t),
            s = r;
          a && a.frameLength && (s = a.frameLength);
          let i = t + s;
          if (i === e.length || i + 1 < e.length && this.isHeaderPattern(e, i)) return !0
        }
        return !1
      }
    };
  class T {
    constructor(e) {
      this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0
    }
    loadWord() {
      let e = this.data,
        t = this.bytesAvailable,
        r = e.byteLength - t,
        a = new Uint8Array(4),
        s = Math.min(4, t);
      if (0 === s) throw new Error("no bytes available");
      a.set(e.subarray(r, r + s)), this.word = new DataView(a.buffer).getUint32(0), this.bitsAvailable = 8 * s, this.bytesAvailable -= s
    }
    skipBits(e) {
      let t;
      this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (t = (e -= this.bitsAvailable) >> 3, e -= t >> 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e)
    }
    readBits(e) {
      let r = Math.min(this.bitsAvailable, e),
        a = this.word >>> 32 - r;
      return e > 32 && t.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= r, this.bitsAvailable > 0 ? this.word <<= r : this.bytesAvailable > 0 && this.loadWord(), r = e - r, r > 0 && this.bitsAvailable ? a << r | this.readBits(r) : a
    }
    skipLZ() {
      let e;
      for (e = 0; e < this.bitsAvailable; ++e)
        if (0 != (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e;
      return this.loadWord(), e + this.skipLZ()
    }
    skipUEG() {
      this.skipBits(1 + this.skipLZ())
    }
    skipEG() {
      this.skipBits(1 + this.skipLZ())
    }
    readUEG() {
      let e = this.skipLZ();
      return this.readBits(e + 1) - 1
    }
    readEG() {
      let e = this.readUEG();
      return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
    }
    readBoolean() {
      return 1 === this.readBits(1)
    }
    readUByte() {
      return this.readBits(8)
    }
    readUShort() {
      return this.readBits(16)
    }
    readUInt() {
      return this.readBits(32)
    }
    skipScalingList(e) {
      let t, r, a = 8,
        s = 8;
      for (t = 0; t < e; t++) 0 !== s && (r = this.readEG(), s = (a + r + 256) % 256), a = 0 === s ? a : s
    }
    readSPS() {
      let e, t, r, a, s, i, n, o, l, d = 0,
        h = 0,
        c = 0,
        u = 0,
        p = this.readUByte.bind(this),
        f = this.readBits.bind(this),
        m = this.readUEG.bind(this),
        g = this.readBoolean.bind(this),
        y = this.skipBits.bind(this),
        A = this.skipEG.bind(this),
        S = this.skipUEG.bind(this),
        b = this.skipScalingList.bind(this);
      if (p(), e = p(), t = f(5), y(3), r = p(), S(), 100 === e || 110 === e || 122 === e || 244 === e || 44 === e || 83 === e || 86 === e || 118 === e || 128 === e) {
        let e = m();
        if (3 === e && y(1), S(), S(), y(1), g())
          for (o = 3 !== e ? 8 : 12, l = 0; l < o; l++) g() && b(l < 6 ? 16 : 64)
      }
      S();
      let E = m();
      if (0 === E) m();
      else if (1 === E)
        for (y(1), A(), A(), a = m(), l = 0; l < a; l++) A();
      S(), y(1), s = m(), i = m(), n = f(1), 0 === n && y(1), y(1), g() && (d = m(), h = m(), c = m(), u = m());
      let T = [1, 1];
      if (g() && g()) {
        switch (p()) {
        case 1:
          T = [1, 1];
          break;
        case 2:
          T = [12, 11];
          break;
        case 3:
          T = [10, 11];
          break;
        case 4:
          T = [16, 11];
          break;
        case 5:
          T = [40, 33];
          break;
        case 6:
          T = [24, 11];
          break;
        case 7:
          T = [20, 11];
          break;
        case 8:
          T = [32, 11];
          break;
        case 9:
          T = [80, 33];
          break;
        case 10:
          T = [18, 11];
          break;
        case 11:
          T = [15, 11];
          break;
        case 12:
          T = [64, 33];
          break;
        case 13:
          T = [160, 99];
          break;
        case 14:
          T = [4, 3];
          break;
        case 15:
          T = [3, 2];
          break;
        case 16:
          T = [2, 1];
          break;
        case 255:
          T = [p() << 8 | p(), p() << 8 | p()]
        }
      }
      return {
        width: Math.ceil(16 * (s + 1) - 2 * d - 2 * h),
        height: (2 - n) * (i + 1) * 16 - (n ? 2 : 4) * (c + u),
        pixelRatio: T
      }
    }
    readSliceType() {
      return this.readUByte(), this.readUEG(), this.readUEG()
    }
  }
  class v {
    constructor(e, t) {
      this.subtle = e, this.aesIV = t
    }
    decrypt(e, t) {
      return this.subtle.decrypt({
        name: "AES-CBC",
        iv: this.aesIV
      }, t, e)
    }
  }
  class _ {
    constructor(e, t) {
      this.subtle = e, this.key = t
    }
    expandKey() {
      return this.subtle.importKey("raw", this.key, {
        name: "AES-CBC"
      }, !1, ["encrypt", "decrypt"])
    }
  }
  class R {
    constructor() {
      this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable()
    }
    uint8ArrayToUint32Array_(e) {
      let t = new DataView(e),
        r = new Uint32Array(4);
      for (let e = 0; e < 4; e++) r[e] = t.getUint32(4 * e);
      return r
    }
    initTable() {
      let e = this.sBox,
        t = this.invSBox,
        r = this.subMix,
        a = r[0],
        s = r[1],
        i = r[2],
        n = r[3],
        o = this.invSubMix,
        l = o[0],
        d = o[1],
        h = o[2],
        c = o[3],
        u = new Uint32Array(256),
        p = 0,
        f = 0,
        m = 0;
      for (m = 0; m < 256; m++) u[m] = m < 128 ? m << 1 : m << 1 ^ 283;
      for (m = 0; m < 256; m++) {
        let r = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4;
        r = r >>> 8 ^ 255 & r ^ 99, e[p] = r, t[r] = p;
        let o = u[p],
          m = u[o],
          g = u[m],
          y = 257 * u[r] ^ 16843008 * r;
        a[p] = y << 24 | y >>> 8, s[p] = y << 16 | y >>> 16, i[p] = y << 8 | y >>> 24, n[p] = y, y = 16843009 * g ^ 65537 * m ^ 257 * o ^ 16843008 * p, l[r] = y << 24 | y >>> 8, d[r] = y << 16 | y >>> 16, h[r] = y << 8 | y >>> 24, c[r] = y, p ? (p = o ^ u[u[u[g ^ o]]], f ^= u[u[f]]) : p = f = 1
      }
    }
    expandKey(e) {
      let t = this.uint8ArrayToUint32Array_(e),
        r = !0,
        a = 0;
      for (; a < t.length && r;) r = t[a] === this.key[a], a++;
      if (r) return;
      this.key = t;
      let s = this.keySize = t.length;
      if (4 !== s && 6 !== s && 8 !== s) throw new Error("Invalid aes key size=" + s);
      let i, n, o, l, d = this.ksRows = 4 * (s + 6 + 1),
        h = this.keySchedule = new Uint32Array(d),
        c = this.invKeySchedule = new Uint32Array(d),
        u = this.sBox,
        p = this.rcon,
        f = this.invSubMix,
        m = f[0],
        g = f[1],
        y = f[2],
        A = f[3];
      for (i = 0; i < d; i++) i < s ? o = h[i] = t[i] : (l = o, i % s == 0 ? (l = l << 8 | l >>> 24, l = u[l >>> 24] << 24 | u[l >>> 16 & 255] << 16 | u[l >>> 8 & 255] << 8 | u[255 & l], l ^= p[i / s | 0] << 24) : s > 6 && i % s == 4 && (l = u[l >>> 24] << 24 | u[l >>> 16 & 255] << 16 | u[l >>> 8 & 255] << 8 | u[255 & l]), h[i] = o = (h[i - s] ^ l) >>> 0);
      for (n = 0; n < d; n++) i = d - n, l = 3 & n ? h[i] : h[i - 4], c[n] = n < 4 || i <= 4 ? l : m[u[l >>> 24]] ^ g[u[l >>> 16 & 255]] ^ y[u[l >>> 8 & 255]] ^ A[u[255 & l]], c[n] = c[n] >>> 0
    }
    networkToHostOrderSwap(e) {
      return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
    }
    decrypt(e, t, r, a) {
      let s, i, n, o, l, d, h, c, u, p, f, m, g, y, A = this.keySize + 6,
        S = this.invKeySchedule,
        b = this.invSBox,
        E = this.invSubMix,
        T = E[0],
        v = E[1],
        _ = E[2],
        R = E[3],
        D = this.uint8ArrayToUint32Array_(r),
        I = D[0],
        w = D[1],
        U = D[2],
        P = D[3],
        k = new Int32Array(e),
        x = new Int32Array(k.length),
        C = this.networkToHostOrderSwap;
      for (; t < k.length;) {
        for (u = C(k[t]), p = C(k[t + 1]), f = C(k[t + 2]), m = C(k[t + 3]), l = u ^ S[0], d = m ^ S[1], h = f ^ S[2], c = p ^ S[3], g = 4, y = 1; y < A; y++) s = T[l >>> 24] ^ v[d >> 16 & 255] ^ _[h >> 8 & 255] ^ R[255 & c] ^ S[g], i = T[d >>> 24] ^ v[h >> 16 & 255] ^ _[c >> 8 & 255] ^ R[255 & l] ^ S[g + 1], n = T[h >>> 24] ^ v[c >> 16 & 255] ^ _[l >> 8 & 255] ^ R[255 & d] ^ S[g + 2], o = T[c >>> 24] ^ v[l >> 16 & 255] ^ _[d >> 8 & 255] ^ R[255 & h] ^ S[g + 3], l = s, d = i, h = n, c = o, g += 4;
        s = b[l >>> 24] << 24 ^ b[d >> 16 & 255] << 16 ^ b[h >> 8 & 255] << 8 ^ b[255 & c] ^ S[g], i = b[d >>> 24] << 24 ^ b[h >> 16 & 255] << 16 ^ b[c >> 8 & 255] << 8 ^ b[255 & l] ^ S[g + 1], n = b[h >>> 24] << 24 ^ b[c >> 16 & 255] << 16 ^ b[l >> 8 & 255] << 8 ^ b[255 & d] ^ S[g + 2], o = b[c >>> 24] << 24 ^ b[l >> 16 & 255] << 16 ^ b[d >> 8 & 255] << 8 ^ b[255 & h] ^ S[g + 3], g += 3, x[t] = C(s ^ I), x[t + 1] = C(o ^ w), x[t + 2] = C(n ^ U), x[t + 3] = C(i ^ P), I = u, w = p, U = f, P = m, t += 4
      }
      return a ? function (e) {
        const t = e.byteLength,
          r = t && new DataView(e).getUint8(t - 1);
        return r ? e.slice(0, t - r) : e
      }(x.buffer) : x.buffer
    }
    destroy() {
      this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0
    }
  }
  const D = u();
  class I {
    constructor(e, t, {
      removePKCS7Padding: r = !0
    } = {}) {
      if (this.logEnabled = !0, this.observer = e, this.config = t, this.removePKCS7Padding = r, r) try {
        const e = D.crypto;
        e && (this.subtle = e.subtle || e.webkitSubtle)
      } catch (e) {}
      this.disableWebCrypto = !this.subtle
    }
    isSync() {
      return this.disableWebCrypto && this.config.enableSoftwareAES
    }
    decrypt(e, r, a, s) {
      if (this.disableWebCrypto && this.config.enableSoftwareAES) {
        this.logEnabled && (t.log("JS AES decrypt"), this.logEnabled = !1);
        let i = this.decryptor;
        i || (this.decryptor = i = new R), i.expandKey(r), s(i.decrypt(e, 0, a, this.removePKCS7Padding))
      } else {
        this.logEnabled && (t.log("WebCrypto AES decrypt"), this.logEnabled = !1);
        const i = this.subtle;
        this.key !== r && (this.key = r, this.fastAesKey = new _(i, r)), this.fastAesKey.expandKey().then(t => {
          new v(i, a).decrypt(e, t).catch(t => {
            this.onWebCryptoError(t, e, r, a, s)
          }).then(e => {
            s(e)
          })
        }).catch(t => {
          this.onWebCryptoError(t, e, r, a, s)
        })
      }
    }
    onWebCryptoError(e, i, n, o, l) {
      this.config.enableSoftwareAES ? (t.log("WebCrypto Error, disable WebCrypto API"), this.disableWebCrypto = !0, this.logEnabled = !0, this.decrypt(i, n, o, l)) : (t.error("decrypting error : " + e.message), this.observer.trigger(r.ERROR, {
        type: a.MEDIA_ERROR,
        details: s.FRAG_DECRYPT_ERROR,
        fatal: !0,
        reason: e.message
      }))
    }
    destroy() {
      let e = this.decryptor;
      e && (e.destroy(), this.decryptor = void 0)
    }
  }
  class w {
    constructor(e, t, r, a) {
      this.decryptdata = r, this.discardEPB = a, this.decrypter = new I(e, t, {
        removePKCS7Padding: !1
      })
    }
    decryptBuffer(e, t) {
      this.decrypter.decrypt(e, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, t)
    }
    decryptAacSample(e, t, r, a) {
      let s = e[t].unit,
        i = s.subarray(16, s.length - s.length % 16),
        n = i.buffer.slice(i.byteOffset, i.byteOffset + i.length),
        o = this;
      this.decryptBuffer(n, (function (i) {
        i = new Uint8Array(i), s.set(i, 16), a || o.decryptAacSamples(e, t + 1, r)
      }))
    }
    decryptAacSamples(e, t, r) {
      for (;; t++) {
        if (t >= e.length) return void r();
        if (e[t].unit.length < 32) continue;
        let a = this.decrypter.isSync();
        if (this.decryptAacSample(e, t, r, a), !a) return
      }
    }
    getAvcEncryptedData(e) {
      let t = 16 * Math.floor((e.length - 48) / 160) + 16,
        r = new Int8Array(t),
        a = 0;
      for (let t = 32; t <= e.length - 16; t += 160, a += 16) r.set(e.subarray(t, t + 16), a);
      return r
    }
    getAvcDecryptedUnit(e, t) {
      t = new Uint8Array(t);
      let r = 0;
      for (let a = 32; a <= e.length - 16; a += 160, r += 16) e.set(t.subarray(r, r + 16), a);
      return e
    }
    decryptAvcSample(e, t, r, a, s, i) {
      let n = this.discardEPB(s.data),
        o = this.getAvcEncryptedData(n),
        l = this;
      this.decryptBuffer(o.buffer, (function (o) {
        s.data = l.getAvcDecryptedUnit(n, o), i || l.decryptAvcSamples(e, t, r + 1, a)
      }))
    }
    decryptAvcSamples(e, t, r, a) {
      for (;; t++, r = 0) {
        if (t >= e.length) return void a();
        let s = e[t].units;
        for (; !(r >= s.length); r++) {
          let i = s[r];
          if (i.length <= 48 || 1 !== i.type && 5 !== i.type) continue;
          let n = this.decrypter.isSync();
          if (this.decryptAvcSample(e, t, r, a, i, n), !n) return
        }
      }
    }
  }
  const U = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
  };
  class P {
    constructor(e, t, r, a) {
      this.observer = e, this.config = r, this.typeSupported = a, this.remuxer = t, this.sampleAes = null, this.pmtUnknownTypes = {}
    }
    setDecryptData(e) {
      null != e && null != e.key && "SAMPLE-AES" === e.method ? this.sampleAes = new w(this.observer, this.config, e, this.discardEPB) : this.sampleAes = null
    }
    static probe(e) {
      const r = P._syncOffset(e);
      return !(r < 0) && (r && t.warn(`MPEG2-TS detected but first sync word found @ offset ${r}, junk ahead ?`), !0)
    }
    static _syncOffset(e) {
      const t = Math.min(1e3, e.length - 564);
      let r = 0;
      for (; r < t;) {
        if (71 === e[r] && 71 === e[r + 188] && 71 === e[r + 376]) return r;
        r++
      }
      return -1
    }
    static createTrack(e, t) {
      return {
        container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
        type: e,
        id: U[e],
        pid: -1,
        inputTimeScale: 9e4,
        sequenceNumber: 0,
        samples: [],
        dropped: "video" === e ? 0 : void 0,
        isAAC: "audio" === e || void 0,
        duration: "audio" === e ? t : void 0
      }
    }
    resetInitSegment(e, t, r, a) {
      this.pmtParsed = !1, this._pmtId = -1, this.pmtUnknownTypes = {}, this._avcTrack = P.createTrack("video", a), this._audioTrack = P.createTrack("audio", a), this._id3Track = P.createTrack("id3", a), this._txtTrack = P.createTrack("text", a), this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = t, this.videoCodec = r, this._duration = a
    }
    resetTimeStamp() {}
    append(e, i, n, o) {
      let l, d, h, c, u, p, f = e.length,
        m = !1;
      this.pmtUnknownTypes = {}, this.contiguous = n;
      let g = this.pmtParsed,
        y = this._avcTrack,
        A = this._audioTrack,
        S = this._id3Track,
        b = y.pid,
        E = A.pid,
        T = S.pid,
        v = this._pmtId,
        _ = y.pesData,
        R = A.pesData,
        D = S.pesData,
        I = this._parsePAT,
        w = this._parsePMT.bind(this),
        U = this._parsePES,
        k = this._parseAVCPES.bind(this),
        x = this._parseAACPES.bind(this),
        C = this._parseMPEGPES.bind(this),
        L = this._parseID3PES.bind(this);
      const O = P._syncOffset(e);
      for (f -= (f + O) % 188, l = O; l < f; l += 188)
        if (71 === e[l]) {
          if (d = !!(64 & e[l + 1]), h = ((31 & e[l + 1]) << 8) + e[l + 2], c = (48 & e[l + 3]) >> 4, c > 1) {
            if (u = l + 5 + e[l + 4], u === l + 188) continue
          } else u = l + 4;
          switch (h) {
          case b:
            d && (_ && (p = U(_)) && k(p, !1), _ = {
              data: [],
              size: 0
            }), _ && (_.data.push(e.subarray(u, l + 188)), _.size += l + 188 - u);
            break;
          case E:
            d && (R && (p = U(R)) && (A.isAAC ? x(p) : C(p)), R = {
              data: [],
              size: 0
            }), R && (R.data.push(e.subarray(u, l + 188)), R.size += l + 188 - u);
            break;
          case T:
            d && (D && (p = U(D)) && L(p), D = {
              data: [],
              size: 0
            }), D && (D.data.push(e.subarray(u, l + 188)), D.size += l + 188 - u);
            break;
          case 0:
            d && (u += e[u] + 1), v = this._pmtId = I(e, u);
            break;
          case v:
            d && (u += e[u] + 1);
            let r = w(e, u, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, null != this.sampleAes);
            b = r.avc, b > 0 && (y.pid = b), E = r.audio, E > 0 && (A.pid = E, A.isAAC = r.isAAC), T = r.id3, T > 0 && (S.pid = T), m && !g && (t.log("reparse from beginning"), m = !1, l = O - 188), g = this.pmtParsed = !0;
            break;
          case 17:
          case 8191:
            break;
          default:
            m = !0
          }
        } else this.observer.trigger(r.ERROR, {
          type: a.MEDIA_ERROR,
          details: s.FRAG_PARSING_ERROR,
          fatal: !1,
          reason: "TS packet did not start with 0x47"
        });
      _ && (p = U(_)) ? (k(p, !0), y.pesData = null) : y.pesData = _, R && (p = U(R)) ? (A.isAAC ? x(p) : C(p), A.pesData = null) : (R && R.size && t.log("last AAC PES packet truncated,might overlap between fragments"), A.pesData = R), D && (p = U(D)) ? (L(p), S.pesData = null) : S.pesData = D, null == this.sampleAes ? this.remuxer.remux(A, y, S, this._txtTrack, i, n, o) : this.decryptAndRemux(A, y, S, this._txtTrack, i, n, o)
    }
    decryptAndRemux(e, t, r, a, s, i, n) {
      if (e.samples && e.isAAC) {
        let o = this;
        this.sampleAes.decryptAacSamples(e.samples, 0, (function () {
          o.decryptAndRemuxAvc(e, t, r, a, s, i, n)
        }))
      } else this.decryptAndRemuxAvc(e, t, r, a, s, i, n)
    }
    decryptAndRemuxAvc(e, t, r, a, s, i, n) {
      if (t.samples) {
        let o = this;
        this.sampleAes.decryptAvcSamples(t.samples, 0, 0, (function () {
          o.remuxer.remux(e, t, r, a, s, i, n)
        }))
      } else this.remuxer.remux(e, t, r, a, s, i, n)
    }
    destroy() {
      this._initPTS = this._initDTS = void 0, this._duration = 0
    }
    _parsePAT(e, t) {
      return (31 & e[t + 10]) << 8 | e[t + 11]
    }
    _trackUnknownPmt(e, r, a) {
      const s = this.pmtUnknownTypes[e] || 0;
      return 0 === s && (this.pmtUnknownTypes[e] = 0, r.call(t, a)), this.pmtUnknownTypes[e]++, s
    }
    _parsePMT(e, r, a, s) {
      let i, n, o, l, d = {
        audio: -1,
        avc: -1,
        id3: -1,
        isAAC: !0
      };
      for (i = (15 & e[r + 1]) << 8 | e[r + 2], n = r + 3 + i - 4, o = (15 & e[r + 10]) << 8 | e[r + 11], r += 12 + o; r < n;) {
        switch (l = (31 & e[r + 1]) << 8 | e[r + 2], e[r]) {
        case 207:
          if (!s) {
            this._trackUnknownPmt(e[r], t.warn, "ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
            break
          }
          case 15:
            -1 === d.audio && (d.audio = l);
            break;
          case 21:
            -1 === d.id3 && (d.id3 = l);
            break;
          case 219:
            if (!s) {
              this._trackUnknownPmt(e[r], t.warn, "H.264 with AES-128-CBC slice encryption found in unencrypted stream");
              break
            }
            case 27:
              -1 === d.avc && (d.avc = l);
              break;
            case 3:
            case 4:
              a ? -1 === d.audio && (d.audio = l, d.isAAC = !1) : this._trackUnknownPmt(e[r], t.warn, "MPEG audio found, not supported in this browser");
              break;
            case 36:
              this._trackUnknownPmt(e[r], t.warn, "Unsupported HEVC stream type found");
              break;
            default:
              this._trackUnknownPmt(e[r], t.log, "Unknown stream type:" + e[r])
        }
        r += 5 + ((15 & e[r + 3]) << 8 | e[r + 4])
      }
      return d
    }
    _parsePES(e) {
      let r, a, s, i, n, o, l, d, h, c = 0,
        u = e.data;
      if (!e || 0 === e.size) return null;
      for (; u[0].length < 19 && u.length > 1;) {
        let e = new Uint8Array(u[0].length + u[1].length);
        e.set(u[0]), e.set(u[1], u[0].length), u[0] = e, u.splice(1, 1)
      }
      if (r = u[0], s = (r[0] << 16) + (r[1] << 8) + r[2], 1 === s) {
        if (i = (r[4] << 8) + r[5], i && i > e.size - 6) return null;
        if (a = r[7], 192 & a && (l = 536870912 * (14 & r[9]) + 4194304 * (255 & r[10]) + 16384 * (254 & r[11]) + 128 * (255 & r[12]) + (254 & r[13]) / 2, 64 & a ? (d = 536870912 * (14 & r[14]) + 4194304 * (255 & r[15]) + 16384 * (254 & r[16]) + 128 * (255 & r[17]) + (254 & r[18]) / 2, l - d > 54e5 && (t.warn(Math.round((l - d) / 9e4) + "s delta between PTS and DTS, align them"), l = d)) : d = l), n = r[8], h = n + 9, e.size <= h) return null;
        e.size -= h, o = new Uint8Array(e.size);
        for (let e = 0, t = u.length; e < t; e++) {
          r = u[e];
          let t = r.byteLength;
          if (h) {
            if (h > t) {
              h -= t;
              continue
            }
            r = r.subarray(h), t -= h, h = 0
          }
          o.set(r, c), c += t
        }
        return i && (i -= n + 3), {
          data: o,
          pts: l,
          dts: d,
          len: i
        }
      }
      return null
    }
    pushAccesUnit(e, r) {
      if (e.units.length && e.frame) {
        const t = r.samples,
          a = t.length;
        if (isNaN(e.pts)) {
          if (!a) return void r.dropped++; {
            const r = t[a - 1];
            e.pts = r.pts, e.dts = r.dts
          }
        }!this.config.forceKeyFrameOnDiscontinuity || !0 === e.key || r.sps && (a || this.contiguous) ? (e.id = a, t.push(e)) : r.dropped++
      }
      e.debug.length && t.log(e.pts + "/" + e.dts + ":" + e.debug)
    }
    _parseAVCPES(e, t) {
      let r, a, s, i = this._avcTrack,
        n = this._parseAVCNALu(e.data),
        o = this.avcSample,
        l = !1,
        d = this.pushAccesUnit.bind(this),
        h = function (e, t, r, a) {
          return {
            key: e,
            pts: t,
            dts: r,
            units: [],
            debug: a
          }
        };
      e.data = null, o && n.length && !i.audFound && (d(o, i), o = this.avcSample = h(!1, e.pts, e.dts, "")), n.forEach(t => {
        switch (t.type) {
        case 1:
          a = !0, o || (o = this.avcSample = h(!0, e.pts, e.dts, "")), o.frame = !0;
          let f = t.data;
          if (l && f.length > 4) {
            let e = new T(f).readSliceType();
            2 !== e && 4 !== e && 7 !== e && 9 !== e || (o.key = !0)
          }
          break;
        case 5:
          a = !0, o || (o = this.avcSample = h(!0, e.pts, e.dts, "")), o.key = !0, o.frame = !0;
          break;
        case 6:
          a = !0, r = new T(this.discardEPB(t.data)), r.readUByte();
          for (var n = 0, c = 0, u = !1, p = 0; !u && r.bytesAvailable > 1;) {
            n = 0;
            do {
              n += p = r.readUByte()
            } while (255 === p);
            c = 0;
            do {
              c += p = r.readUByte()
            } while (255 === p);
            if (4 === n && 0 !== r.bytesAvailable) {
              if (u = !0, 181 === r.readUByte()) {
                if (49 === r.readUShort()) {
                  if (1195456820 === r.readUInt()) {
                    if (3 === r.readUByte()) {
                      let t = r.readUByte(),
                        a = 31 & t,
                        i = [t, r.readUByte()];
                      for (s = 0; s < a; s++) i.push(r.readUByte()), i.push(r.readUByte()), i.push(r.readUByte());
                      this._insertSampleInOrder(this._txtTrack.samples, {
                        type: 3,
                        pts: e.pts,
                        bytes: i
                      })
                    }
                  }
                }
              }
            } else if (5 === n && 0 !== r.bytesAvailable) {
              if (u = !0, c > 16) {
                const t = [];
                for (s = 0; s < 16; s++) t.push(r.readUByte().toString(16)), 3 !== s && 5 !== s && 7 !== s && 9 !== s || t.push("-");
                const a = c - 16,
                  i = new Uint8Array(a);
                for (s = 0; s < a; s++) i[s] = r.readUByte();
                this._insertSampleInOrder(this._txtTrack.samples, {
                  pts: e.pts,
                  payloadType: n,
                  uuid: t.join(""),
                  userDataBytes: i,
                  userData: H(i.buffer)
                })
              }
            } else if (c < r.bytesAvailable)
              for (s = 0; s < c; s++) r.readUByte()
          }
          break;
        case 7:
          if (a = !0, l = !0, !i.sps) {
            r = new T(t.data);
            let e = r.readSPS();
            i.width = e.width, i.height = e.height, i.pixelRatio = e.pixelRatio, i.sps = [t.data], i.duration = this._duration;
            let a = t.data.subarray(1, 4),
              n = "avc1.";
            for (s = 0; s < 3; s++) {
              let e = a[s].toString(16);
              e.length < 2 && (e = "0" + e), n += e
            }
            i.codec = n
          }
          break;
        case 8:
          a = !0, i.pps || (i.pps = [t.data]);
          break;
        case 9:
          a = !1, i.audFound = !0, o && d(o, i), o = this.avcSample = h(!1, e.pts, e.dts, "");
          break;
        case 12:
          a = !1;
          break;
        default:
          a = !1, o && (o.debug += "unknown NAL " + t.type + " ")
        }
        if (o && a) {
          o.units.push(t)
        }
      }), t && o && (d(o, i), this.avcSample = null)
    }
    _insertSampleInOrder(e, t) {
      let r = e.length;
      if (r > 0) {
        if (t.pts >= e[r - 1].pts) e.push(t);
        else
          for (let a = r - 1; a >= 0; a--)
            if (t.pts < e[a].pts) {
              e.splice(a, 0, t);
              break
            }
      } else e.push(t)
    }
    _getLastNalUnit() {
      let e, t = this.avcSample;
      if (!t || 0 === t.units.length) {
        let e = this._avcTrack.samples;
        t = e[e.length - 1]
      }
      if (t) {
        let r = t.units;
        e = r[r.length - 1]
      }
      return e
    }
    _parseAVCNALu(e) {
      let t, r, a, s, i, n = 0,
        o = e.byteLength,
        l = this._avcTrack,
        d = l.naluState || 0,
        h = d,
        c = [],
        u = -1;
      for (-1 === d && (u = 0, i = 31 & e[0], d = 0, n = 1); n < o;)
        if (t = e[n++], d)
          if (1 !== d)
            if (t)
              if (1 === t) {
                if (u >= 0) a = {
                  data: e.subarray(u, n - d - 1),
                  type: i
                }, c.push(a);
                else {
                  let t = this._getLastNalUnit();
                  if (t && (h && n <= 4 - h && t.state && (t.data = t.data.subarray(0, t.data.byteLength - h)), r = n - d - 1, r > 0)) {
                    let a = new Uint8Array(t.data.byteLength + r);
                    a.set(t.data, 0), a.set(e.subarray(0, r), t.data.byteLength), t.data = a
                  }
                }
                n < o ? (s = 31 & e[n], u = n, i = s, d = 0) : d = -1
              } else d = 0;
      else d = 3;
      else d = t ? 0 : 2;
      else d = t ? 0 : 1;
      if (u >= 0 && d >= 0 && (a = {
          data: e.subarray(u, o),
          type: i,
          state: d
        }, c.push(a)), 0 === c.length) {
        let t = this._getLastNalUnit();
        if (t) {
          let r = new Uint8Array(t.data.byteLength + e.byteLength);
          r.set(t.data, 0), r.set(e, t.data.byteLength), t.data = r
        }
      }
      return l.naluState = d, c
    }
    discardEPB(e) {
      let t, r, a = e.byteLength,
        s = [],
        i = 1;
      for (; i < a - 2;) 0 === e[i] && 0 === e[i + 1] && 3 === e[i + 2] ? (s.push(i + 2), i += 2) : i++;
      if (0 === s.length) return e;
      t = a - s.length, r = new Uint8Array(t);
      let n = 0;
      for (i = 0; i < t; n++, i++) n === s[0] && (n++, s.shift()), r[i] = e[n];
      return r
    }
    _parseAACPES(e) {
      let i, n, o, l, d, h = this._audioTrack,
        c = e.data,
        u = e.pts,
        p = this.aacOverFlow,
        f = this.aacLastPTS;
      if (p) {
        let e = new Uint8Array(p.byteLength + c.byteLength);
        e.set(p, 0), e.set(c, p.byteLength), c = e
      }
      for (o = 0, d = c.length; o < d - 1 && !b.isHeader(c, o); o++);
      if (o > 0 && o < d - 1) o = 0;
      else if (o) {
        let e, i;
        if (o < d - 1 ? (e = "AAC PES did not start with ADTS header,offset:" + o, i = !1) : (e = "no ADTS header found in AAC PES", i = !0), t.warn("parsing error:" + e), this.observer.trigger(r.ERROR, {
            type: a.MEDIA_ERROR,
            details: s.FRAG_PARSING_ERROR,
            fatal: i,
            reason: e
          }), i) return
      }
      if (b.initTrackConfig(h, this.observer, c, o, this.audioCodec), n = 0, i = b.getFrameDuration(h.samplerate), p && f) {
        let e = f + i;
        Math.abs(e - u) > 1 && (t.log("AAC: align PTS for overlapping frames by " + Math.round((e - u) / 90)), u = e)
      }
      for (; o < d;) {
        if (b.isHeader(c, o)) {
          if (o + 5 < d) {
            const e = b.appendFrame(h, c, o, u, n);
            if (e) {
              o += e.length, l = e.sample.pts, n++;
              continue
            }
          }
          break
        }
        o++
      }
      p = o < d ? c.subarray(o, d) : null, this.aacOverFlow = p, this.aacLastPTS = l
    }
    _parseMPEGPES(e) {
      let t = e.data,
        r = t.length,
        a = 0,
        s = 0,
        i = e.pts;
      for (; s < r;)
        if (E.isHeader(t, s)) {
          let e = E.appendFrame(this._audioTrack, t, s, i, a);
          if (!e) break;
          s += e.length, a++
        } else s++
    }
    _parseID3PES(e) {
      this._id3Track.samples.push(e)
    }
  }
  class k {
    static getSilentFrame(e, t) {
      switch (e) {
      case "mp4a.40.2":
        if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);
        if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
        if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
        if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
        if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
        break;
      default:
        if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
      }
      return null
    }
  }
  const x = Math.pow(2, 32) - 1;
  class C {
    static init() {
      let e;
      for (e in C.types = {
          avc1: [],
          avcC: [],
          btrt: [],
          dinf: [],
          dref: [],
          esds: [],
          ftyp: [],
          hdlr: [],
          mdat: [],
          mdhd: [],
          mdia: [],
          mfhd: [],
          minf: [],
          moof: [],
          moov: [],
          mp4a: [],
          ".mp3": [],
          mvex: [],
          mvhd: [],
          pasp: [],
          sdtp: [],
          stbl: [],
          stco: [],
          stsc: [],
          stsd: [],
          stsz: [],
          stts: [],
          tfdt: [],
          tfhd: [],
          traf: [],
          trak: [],
          trun: [],
          trex: [],
          tkhd: [],
          vmhd: [],
          smhd: []
        }, C.types) C.types.hasOwnProperty(e) && (C.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
      let t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
        r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
      C.HDLR_TYPES = {
        video: t,
        audio: r
      };
      let a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
        s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
      C.STTS = C.STSC = C.STCO = s, C.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), C.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), C.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), C.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
      let i = new Uint8Array([105, 115, 111, 109]),
        n = new Uint8Array([97, 118, 99, 49]),
        o = new Uint8Array([0, 0, 0, 1]);
      C.FTYP = C.box(C.types.ftyp, i, o, i, n), C.DINF = C.box(C.types.dinf, C.box(C.types.dref, a))
    }
    static box(e) {
      let t, r = Array.prototype.slice.call(arguments, 1),
        a = 8,
        s = r.length,
        i = s;
      for (; s--;) a += r[s].byteLength;
      for (t = new Uint8Array(a), t[0] = a >> 24 & 255, t[1] = a >> 16 & 255, t[2] = a >> 8 & 255, t[3] = 255 & a, t.set(e, 4), s = 0, a = 8; s < i; s++) t.set(r[s], a), a += r[s].byteLength;
      return t
    }
    static hdlr(e) {
      return C.box(C.types.hdlr, C.HDLR_TYPES[e])
    }
    static mdat(e) {
      return C.box(C.types.mdat, e)
    }
    static mdhd(e, t) {
      t *= e;
      const r = Math.floor(t / (x + 1)),
        a = Math.floor(t % (x + 1));
      return C.box(C.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 85, 196, 0, 0]))
    }
    static mdia(e) {
      return C.box(C.types.mdia, C.mdhd(e.timescale, e.duration), C.hdlr(e.type), C.minf(e))
    }
    static mfhd(e) {
      return C.box(C.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e]))
    }
    static minf(e) {
      return "audio" === e.type ? C.box(C.types.minf, C.box(C.types.smhd, C.SMHD), C.DINF, C.stbl(e)) : C.box(C.types.minf, C.box(C.types.vmhd, C.VMHD), C.DINF, C.stbl(e))
    }
    static moof(e, t, r) {
      return C.box(C.types.moof, C.mfhd(e), C.traf(r, t))
    }
    static moov(e) {
      let t = e.length,
        r = [];
      for (; t--;) r[t] = C.trak(e[t]);
      return C.box.apply(null, [C.types.moov, C.mvhd(e[0].timescale, e[0].duration)].concat(r).concat(C.mvex(e)))
    }
    static mvex(e) {
      let t = e.length,
        r = [];
      for (; t--;) r[t] = C.trex(e[t]);
      return C.box.apply(null, [C.types.mvex].concat(r))
    }
    static mvhd(e, t) {
      t *= e;
      const r = Math.floor(t / (x + 1)),
        a = Math.floor(t % (x + 1));
      let s = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
      return C.box(C.types.mvhd, s)
    }
    static sdtp(e) {
      let t, r, a = e.samples || [],
        s = new Uint8Array(4 + a.length);
      for (r = 0; r < a.length; r++) t = a[r].flags, s[r + 4] = t.dependsOn << 4 | t.isDependedOn << 2 | t.hasRedundancy;
      return C.box(C.types.sdtp, s)
    }
    static stbl(e) {
      return C.box(C.types.stbl, C.stsd(e), C.box(C.types.stts, C.STTS), C.box(C.types.stsc, C.STSC), C.box(C.types.stsz, C.STSZ), C.box(C.types.stco, C.STCO))
    }
    static avc1(e) {
      let t, r, a, s = [],
        i = [];
      for (t = 0; t < e.sps.length; t++) r = e.sps[t], a = r.byteLength, s.push(a >>> 8 & 255), s.push(255 & a), s = s.concat(Array.prototype.slice.call(r));
      for (t = 0; t < e.pps.length; t++) r = e.pps[t], a = r.byteLength, i.push(a >>> 8 & 255), i.push(255 & a), i = i.concat(Array.prototype.slice.call(r));
      let n = C.box(C.types.avcC, new Uint8Array([1, s[3], s[4], s[5], 255, 224 | e.sps.length].concat(s).concat([e.pps.length]).concat(i))),
        o = e.width,
        l = e.height,
        d = e.pixelRatio[0],
        h = e.pixelRatio[1];
      return C.box(C.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), n, C.box(C.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), C.box(C.types.pasp, new Uint8Array([d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d, h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h])))
    }
    static esds(e) {
      let t = e.config.length;
      return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]))
    }
    static mp4a(e) {
      let t = e.samplerate;
      return C.box(C.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]), C.box(C.types.esds, C.esds(e)))
    }
    static mp3(e) {
      let t = e.samplerate;
      return C.box(C.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]))
    }
    static stsd(e) {
      return "audio" === e.type ? e.isAAC || "mp3" !== e.codec ? C.box(C.types.stsd, C.STSD, C.mp4a(e)) : C.box(C.types.stsd, C.STSD, C.mp3(e)) : C.box(C.types.stsd, C.STSD, C.avc1(e))
    }
    static tkhd(e) {
      let t = e.id,
        r = e.duration * e.timescale,
        a = e.width,
        s = e.height,
        i = Math.floor(r / (x + 1)),
        n = Math.floor(r % (x + 1));
      return C.box(C.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, a >> 8 & 255, 255 & a, 0, 0, s >> 8 & 255, 255 & s, 0, 0]))
    }
    static traf(e, t) {
      let r = C.sdtp(e),
        a = e.id,
        s = Math.floor(t / (x + 1)),
        i = Math.floor(t % (x + 1));
      return C.box(C.types.traf, C.box(C.types.tfhd, new Uint8Array([0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), C.box(C.types.tfdt, new Uint8Array([1, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i])), C.trun(e, r.length + 16 + 20 + 8 + 16 + 8 + 8), r)
    }
    static trak(e) {
      return e.duration = e.duration || 4294967295, C.box(C.types.trak, C.tkhd(e), C.mdia(e))
    }
    static trex(e) {
      let t = e.id;
      return C.box(C.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
    }
    static trun(e, t) {
      let r, a, s, i, n, o, l = e.samples || [],
        d = l.length,
        h = 12 + 16 * d,
        c = new Uint8Array(h);
      for (t += 8 + h, c.set([0, 0, 15, 1, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0), r = 0; r < d; r++) a = l[r], s = a.duration, i = a.size, n = a.flags, o = a.cts, c.set([s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, n.isLeading << 2 | n.dependsOn, n.isDependedOn << 6 | n.hasRedundancy << 4 | n.paddingValue << 1 | n.isNonSync, 61440 & n.degradPrio, 15 & n.degradPrio, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o], 12 + 16 * r);
      return C.box(C.types.trun, c)
    }
    static initSegment(e) {
      C.types || C.init();
      let t, r = C.moov(e);
      return t = new Uint8Array(C.FTYP.byteLength + r.byteLength), t.set(C.FTYP), t.set(r, C.FTYP.byteLength), t
    }
  }
  const L = o(10),
    O = o(.2);
  let F, N = null;

  function M(e, t) {
    let r;
    if (void 0 === t) return e;
    for (r = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;) e += r;
    return e
  }
  class B {
    constructor(e, t) {
      this.observer = e, this.remuxer = t
    }
    resetTimeStamp(e) {
      this.initPTS = e
    }
    resetInitSegment(e, t, a, s) {
      if (e && e.byteLength) {
        const i = this.initData = B.parseInitSegment(e);
        null == t && (t = "mp4a.40.5"), null == a && (a = "avc1.42e01e");
        const n = {};
        i.audio && i.video ? n.audiovideo = {
          container: "video/mp4",
          codec: t + "," + a,
          initSegment: s ? e : null
        } : (i.audio && (n.audio = {
          container: "audio/mp4",
          codec: t,
          initSegment: s ? e : null
        }), i.video && (n.video = {
          container: "video/mp4",
          codec: a,
          initSegment: s ? e : null
        })), this.observer.trigger(r.FRAG_PARSING_INIT_SEGMENT, {
          tracks: n
        })
      } else t && (this.audioCodec = t), a && (this.videoCodec = a)
    }
    static probe(e) {
      return B.findBox({
        data: e,
        start: 0,
        end: Math.min(e.length, 16384)
      }, ["moof"]).length > 0
    }
    static bin2str(e) {
      return String.fromCharCode.apply(null, e)
    }
    static readUint16(e, t) {
      e.data && (t += e.start, e = e.data);
      const r = e[t] << 8 | e[t + 1];
      return r < 0 ? 65536 + r : r
    }
    static readUint32(e, t) {
      e.data && (t += e.start, e = e.data);
      const r = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
      return r < 0 ? 4294967296 + r : r
    }
    static writeUint32(e, t, r) {
      e.data && (t += e.start, e = e.data), e[t] = r >> 24, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = 255 & r
    }
    static findBox(e, t) {
      let r, a, s, i, n, o, l, d = [];
      if (e.data ? (o = e.start, i = e.end, e = e.data) : (o = 0, i = e.byteLength), !t.length) return null;
      for (r = o; r < i;) a = B.readUint32(e, r), s = B.bin2str(e.subarray(r + 4, r + 8)), l = a > 1 ? r + a : i, s === t[0] && (1 === t.length ? d.push({
        data: e,
        start: r + 8,
        end: l
      }) : (n = B.findBox({
        data: e,
        start: r + 8,
        end: l
      }, t.slice(1)), n.length && (d = d.concat(n)))), r = l;
      return d
    }
    static parseSegmentIndex(e) {
      const t = B.findBox(e, ["moov"])[0],
        r = t ? t.end : null;
      let a, s = 0,
        i = B.findBox(e, ["sidx"]);
      if (!i || !i[0]) return null;
      a = [], i = i[0];
      const n = i.data[0];
      s = 0 === n ? 8 : 16;
      const o = B.readUint32(i, s);
      s += 4;
      s += 0 === n ? 8 : 16, s += 2;
      let l = i.end + 0;
      const d = B.readUint16(i, s);
      s += 2;
      for (let e = 0; e < d; e++) {
        let e = s;
        const t = B.readUint32(i, e);
        e += 4;
        const r = 2147483647 & t;
        if (1 === (2147483648 & t) >>> 31) return void console.warn("SIDX has hierarchical references (not supported)");
        const n = B.readUint32(i, e);
        e += 4, a.push({
          referenceSize: r,
          subsegmentDuration: n,
          info: {
            duration: n / o,
            start: l,
            end: l + r - 1
          }
        }), l += r, e += 4, s = e
      }
      return {
        earliestPresentationTime: 0,
        timescale: o,
        version: n,
        referencesCount: d,
        references: a,
        moovEndOffset: r
      }
    }
    static parseInitSegment(e) {
      let r = [];
      return B.findBox(e, ["moov", "trak"]).forEach(e => {
        const a = B.findBox(e, ["tkhd"])[0];
        if (a) {
          let s = a.data[a.start],
            i = 0 === s ? 12 : 20,
            n = B.readUint32(a, i);
          const o = B.findBox(e, ["mdia", "mdhd"])[0];
          if (o) {
            s = o.data[o.start], i = 0 === s ? 12 : 20;
            const a = B.readUint32(o, i),
              l = B.findBox(e, ["mdia", "hdlr"])[0];
            if (l) {
              let s = {
                soun: "audio",
                vide: "video"
              } [B.bin2str(l.data.subarray(l.start + 8, l.start + 12))];
              if (s) {
                let i = B.findBox(e, ["mdia", "minf", "stbl", "stsd"]);
                if (i.length) {
                  i = i[0];
                  let e = B.bin2str(i.data.subarray(i.start + 12, i.start + 16));
                  t.log(`MP4Demuxer:${s}:${e} found`)
                }
                r[n] = {
                  timescale: a,
                  type: s
                }, r[s] = {
                  timescale: a,
                  id: n
                }
              }
            }
          }
        }
      }), r
    }
    static getStartDTS(e, t) {
      let r, a, s;
      return r = B.findBox(t, ["moof", "traf"]), a = [].concat.apply([], r.map((function (t) {
        return B.findBox(t, ["tfhd"]).map((function (r) {
          let a, s, i;
          return a = B.readUint32(r, 4), s = e[a].timescale || 9e4, i = B.findBox(t, ["tfdt"]).map((function (e) {
            let t, r;
            return t = e.data[e.start], r = B.readUint32(e, 4), 1 === t && (r *= Math.pow(2, 32), r += B.readUint32(e, 8)), r
          }))[0], i / s
        }))
      }))), s = Math.min.apply(null, a), isFinite(s) ? s : 0
    }
    static offsetStartDTS(e, t, r) {
      B.findBox(t, ["moof", "traf"]).map((function (t) {
        return B.findBox(t, ["tfhd"]).map((function (a) {
          let s = B.readUint32(a, 4),
            i = e[s].timescale || 9e4;
          B.findBox(t, ["tfdt"]).map((function (e) {
            let t = e.data[e.start],
              a = B.readUint32(e, 4);
            if (0 === t) B.writeUint32(e, 4, a - r * i);
            else {
              a *= Math.pow(2, 32), a += B.readUint32(e, 8), a -= r * i, a = Math.max(a, 0);
              const t = Math.floor(a / (x + 1)),
                s = Math.floor(a % (x + 1));
              B.writeUint32(e, 4, t), B.writeUint32(e, 8, s)
            }
          }))
        }))
      }))
    }
    append(e, t, a, s) {
      let i = this.initData;
      i || (this.resetInitSegment(e, this.audioCodec, this.videoCodec, !1), i = this.initData);
      let n, o = this.initPTS;
      if (void 0 === o) {
        let a = B.getStartDTS(i, e);
        this.initPTS = o = a - t, this.observer.trigger(r.INIT_PTS_FOUND, {
          initPTS: o
        })
      }
      B.offsetStartDTS(i, e, o), n = B.getStartDTS(i, e), this.remuxer.remux(i.audio, i.video, null, null, n, a, s, e)
    }
    destroy() {}
  }
  class G {
    static isHeader(e, t) {
      return t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
    }
    static isFooter(e, t) {
      return t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
    }
    static getID3Data(e, t) {
      const r = t;
      let a = 0;
      for (; G.isHeader(e, t);) {
        a += 10;
        a += G._readSize(e, t + 6), G.isFooter(e, t + 10) && (a += 10), t += a
      }
      if (a > 0) return e.subarray(r, r + a)
    }
    static _readSize(e, t) {
      let r = 0;
      return r = (127 & e[t]) << 21, r |= (127 & e[t + 1]) << 14, r |= (127 & e[t + 2]) << 7, r |= 127 & e[t + 3], r
    }
    static getTimeStamp(e) {
      const t = G.getID3Frames(e);
      for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (G.isTimeStampFrame(r)) return G._readTimeStamp(r)
      }
    }
    static isTimeStampFrame(e) {
      return e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info
    }
    static _getFrameData(e) {
      const t = String.fromCharCode(e[0], e[1], e[2], e[3]),
        r = G._readSize(e, 4);
      return {
        type: t,
        size: r,
        data: e.subarray(10, 10 + r)
      }
    }
    static getID3Frames(e) {
      let t = 0;
      const r = [];
      for (; G.isHeader(e, t);) {
        const a = G._readSize(e, t + 6);
        t += 10;
        const s = t + a;
        for (; t + 8 < s;) {
          const a = G._getFrameData(e.subarray(t)),
            s = G._decodeFrame(a);
          s && r.push(s), t += a.size + 10
        }
        G.isFooter(e, t) && (t += 10)
      }
      return r
    }
    static _decodeFrame(e) {
      return "PRIV" === e.type ? G._decodePrivFrame(e) : "T" === e.type[0] ? G._decodeTextFrame(e) : "W" === e.type[0] ? G._decodeURLFrame(e) : void 0
    }
    static _readTimeStamp(e) {
      if (8 === e.data.byteLength) {
        const t = new Uint8Array(e.data),
          r = 1 & t[3];
        let a = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];
        return a /= 45, r && (a += 47721858.84), Math.round(a)
      }
    }
    static _decodePrivFrame(e) {
      if (e.size < 2) return;
      const t = G._utf8ArrayToStr(e.data, !0),
        r = new Uint8Array(e.data.subarray(t.length + 1));
      return {
        key: e.type,
        info: t,
        data: r.buffer
      }
    }
    static _decodeTextFrame(e) {
      if (!(e.size < 2)) {
        if ("TXXX" === e.type) {
          let t = 1;
          const r = G._utf8ArrayToStr(e.data.subarray(t), !0);
          t += r.length + 1;
          const a = G._utf8ArrayToStr(e.data.subarray(t));
          return {
            key: e.type,
            info: r,
            data: a
          }
        } {
          const t = G._utf8ArrayToStr(e.data.subarray(1));
          return {
            key: e.type,
            data: t
          }
        }
      }
    }
    static _decodeURLFrame(e) {
      if ("WXXX" === e.type) {
        if (e.size < 2) return;
        let t = 1;
        const r = G._utf8ArrayToStr(e.data.subarray(t), !0);
        t += r.length + 1;
        const a = G._utf8ArrayToStr(e.data.subarray(t));
        return {
          key: e.type,
          info: r,
          data: a
        }
      } {
        const t = G._utf8ArrayToStr(e.data);
        return {
          key: e.type,
          data: t
        }
      }
    }
    static _utf8ArrayToStr(e, t = !1) {
      const r = V();
      if (r) {
        const a = r.decode(e);
        if (t) {
          const e = a.indexOf("\0");
          return -1 !== e ? a.substring(0, e) : a
        }
        return a.replace(/\0/g, "")
      }
      const a = e.length;
      let s, i, n, o = "",
        l = 0;
      for (; l < a;) {
        if (s = e[l++], 0 === s && t) return o;
        if (0 !== s && 3 !== s) switch (s >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          o += String.fromCharCode(s);
          break;
        case 12:
        case 13:
          i = e[l++], o += String.fromCharCode((31 & s) << 6 | 63 & i);
          break;
        case 14:
          i = e[l++], n = e[l++], o += String.fromCharCode((15 & s) << 12 | (63 & i) << 6 | (63 & n) << 0)
        }
      }
      return o
    }
  }

  function V() {
    const e = u();
    return F || void 0 === e.TextDecoder || (F = new e.TextDecoder("utf-8")), F
  }
  const H = G._utf8ArrayToStr;
  class K {
    constructor(e) {
      this.endCC = 0, this.endSN = 0, this.fragments = [], this.initSegment = null, this.live = !0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = e, this.version = null
    }
    get hasProgramDateTime() {
      return !(!this.fragments[0] || !Number.isFinite(this.fragments[0].programDateTime))
    }
  }
  var X, Y = function () {
    function e(e, t) {
      this._uri = null, this.method = null, this.key = null, this.iv = null, this.baseuri = e, this.reluri = t
    }
    return Object.defineProperty(e.prototype, "uri", {
      get: function () {
        return !this._uri && this.reluri && (this._uri = URLToolkit.buildAbsoluteURL(this.baseuri, this.reluri, {
          alwaysNormalize: !0
        })), this._uri
      },
      enumerable: !1,
      configurable: !0
    }), e
  }();
  ! function (e) {
    e.AUDIO = "audio", e.VIDEO = "video"
  }(X || (X = {}));
  var z = function () {
      function e() {
        var e;
        this._url = null, this._byteRange = null, this._decryptdata = null, this._elementaryStreams = ((e = {})[X.AUDIO] = !1, e[X.VIDEO] = !1, e), this.deltaPTS = 0, this.rawProgramDateTime = null, this.programDateTime = null, this.title = null, this.tagList = [], this.sn = 0, this.urlId = 0, this.level = 0
      }
      return e.prototype.setByteRange = function (e, t) {
        var r = e.split("@", 2),
          a = [];
        1 === r.length ? a[0] = t ? t.byteRangeEndOffset : 0 : a[0] = parseInt(r[1]), a[1] = parseInt(r[0]) + a[0], this._byteRange = a
      }, Object.defineProperty(e.prototype, "url", {
        get: function () {
          return !this._url && this.relurl && (this._url = URLToolkit.buildAbsoluteURL(this.baseurl, this.relurl, {
            alwaysNormalize: !0
          })), this._url
        },
        set: function (e) {
          this._url = e
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "byteRange", {
        get: function () {
          return this._byteRange ? this._byteRange : []
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "byteRangeStartOffset", {
        get: function () {
          return this.byteRange[0]
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "byteRangeEndOffset", {
        get: function () {
          return this.byteRange[1]
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "decryptdata", {
        get: function () {
          if (!this.levelkey && !this._decryptdata) return null;
          if (!this._decryptdata && this.levelkey) {
            var e = this.sn;
            "number" != typeof e && (this.levelkey && "AES-128" === this.levelkey.method && !this.levelkey.iv && t.warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue'), e = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, e)
          }
          return this._decryptdata
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "endProgramDateTime", {
        get: function () {
          if (null === this.programDateTime) return null;
          if (!Number.isFinite(this.programDateTime)) return null;
          var e = Number.isFinite(this.duration) ? this.duration : 0;
          return this.programDateTime + 1e3 * e
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "encrypted", {
        get: function () {
          return !(!this.decryptdata || null === this.decryptdata.uri || null !== this.decryptdata.key)
        },
        enumerable: !1,
        configurable: !0
      }), e.prototype.addElementaryStream = function (e) {
        this._elementaryStreams[e] = !0
      }, e.prototype.hasElementaryStream = function (e) {
        return !0 === this._elementaryStreams[e]
      }, e.prototype.createInitializationVector = function (e) {
        for (var t = new Uint8Array(16), r = 12; r < 16; r++) t[r] = e >> 8 * (15 - r) & 255;
        return t
      }, e.prototype.setDecryptDataFromLevelKey = function (e, t) {
        var r = e;
        return (null == e ? void 0 : e.method) && e.uri && !e.iv && ((r = new Y(e.baseuri, e.reluri)).method = e.method, r.iv = this.createInitializationVector(t)), r
      }, e
    }(),
    $ = /(?:#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)|#EXT-X-SESSION-DATA:([^\n\r]*)[\r\n]+)/g,
    W = /#EXT-X-MEDIA:(.*)/g,
    j = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /|(?!#)([\S+ ?]+)/.source, /|#EXT-X-BYTERANGE:*(.+)/.source, /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /|#.*/.source].join(""), "g"),
    q = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/,
    Z = /\.(mp4|m4s|m4v|m4a)$/i,
    Q = function () {
      function e() {}
      return e.findGroup = function (e, t) {
        for (var r = 0; r < e.length; r++) {
          var a = e[r];
          if (a.id === t) return a
        }
      }, e.convertAVC1ToAVCOTI = function (e) {
        var t, r = e.split(".");
        return r.length > 2 ? (t = r.shift() + ".", t += parseInt(r.shift()).toString(16), t += ("000" + parseInt(r.shift()).toString(16)).substr(-4)) : t = e, t
      }, e.resolve = function (e, t) {
        return URLToolkit.buildAbsoluteURL(t, e, {
          alwaysNormalize: !0
        })
      }, e.parseMasterPlaylist = function (t, r) {
        var a, s = [],
          i = {},
          n = !1;

        function o(e, t) {
          ["video", "audio"].forEach((function (r) {
            var a = e.filter((function (e) {
              return function (e, t) {
                var r = c[t];
                return !!r && !0 === r[e.slice(0, 4)]
              }(e, r)
            }));
            if (a.length) {
              var s = a.filter((function (e) {
                return 0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0)
              }));
              t[r + "Codec"] = s.length > 0 ? s[0] : a[0], e = e.filter((function (e) {
                return -1 === a.indexOf(e)
              }))
            }
          })), t.unknownCodecs = e
        }
        for ($.lastIndex = 0; null != (a = $.exec(t));)
          if (a[1]) {
            var l = {},
              d = l.attrs = new h(a[1]);
            l.url = e.resolve(a[2], r);
            var u = d.decimalResolution("RESOLUTION");
            u && (l.width = u.width, l.height = u.height), l.bitrate = d.decimalInteger("AVERAGE-BANDWIDTH") || d.decimalInteger("BANDWIDTH"), l.name = d.NAME, o([].concat((d.CODECS || "").split(/[ ,]+/)), l), l.videoCodec && -1 !== l.videoCodec.indexOf("avc1") && (l.videoCodec = e.convertAVC1ToAVCOTI(l.videoCodec)), s.push(l)
          } else if (a[3]) {
          var p = new h(a[3]);
          p["DATA-ID"] && (n = !0, i[p["DATA-ID"]] = p)
        }
        return {
          levels: s,
          sessionData: n ? i : null
        }
      }, e.parseMasterPlaylistMedia = function (t, r, a, s) {
        var i;
        void 0 === s && (s = []);
        var n = [],
          o = 0;
        for (W.lastIndex = 0; null !== (i = W.exec(t));) {
          var l = new h(i[1]);
          if (l.TYPE === a) {
            var d = {
              attrs: l,
              id: o++,
              groupId: l["GROUP-ID"],
              instreamId: l["INSTREAM-ID"],
              name: l.NAME || l.LANGUAGE,
              type: a,
              default: "YES" === l.DEFAULT,
              autoselect: "YES" === l.AUTOSELECT,
              forced: "YES" === l.FORCED,
              lang: l.LANGUAGE
            };
            if (l.URI && (d.url = e.resolve(l.URI, r)), s.length) {
              var c = e.findGroup(s, d.groupId);
              d.audioCodec = c ? c.codec : s[0].codec
            }
            n.push(d)
          }
        }
        return n
      }, e.parseLevelPlaylist = function (e, r, a, s, i) {
        var n, o, l, d = 0,
          c = 0,
          u = new K(r),
          p = 0,
          f = null,
          m = new z,
          g = null;
        for (j.lastIndex = 0; null !== (n = j.exec(e));) {
          var y = n[1];
          if (y) {
            m.duration = parseFloat(y);
            var A = (" " + n[2]).slice(1);
            m.title = A || null, m.tagList.push(A ? ["INF", y, A] : ["INF", y])
          } else if (n[3]) {
            if (Number.isFinite(m.duration)) {
              var S = d++;
              m.type = s, m.start = c, l && (m.levelkey = l), m.sn = S, m.level = a, m.cc = p, m.urlId = i, m.baseurl = r, m.relurl = (" " + n[3]).slice(1), J(m, f), u.fragments.push(m), f = m, c += m.duration, m = new z
            }
          } else if (n[4]) {
            var b = (" " + n[4]).slice(1);
            f ? m.setByteRange(b, f) : m.setByteRange(b)
          } else if (n[5]) m.rawProgramDateTime = (" " + n[5]).slice(1), m.tagList.push(["PROGRAM-DATE-TIME", m.rawProgramDateTime]), null === g && (g = u.fragments.length);
          else {
            if (!(n = n[0].match(q))) {
              t.warn("No matches on slow regex match for level playlist!");
              continue
            }
            for (o = 1; o < n.length && void 0 === n[o]; o++);
            var E = (" " + n[o + 1]).slice(1),
              T = (" " + n[o + 2]).slice(1);
            switch (n[o]) {
            case "#":
              m.tagList.push(T ? [E, T] : [E]);
              break;
            case "PLAYLIST-TYPE":
              u.type = E.toUpperCase();
              break;
            case "MEDIA-SEQUENCE":
              d = u.startSN = parseInt(E);
              break;
            case "TARGETDURATION":
              u.targetduration = parseFloat(E);
              break;
            case "VERSION":
              u.version = parseInt(E);
              break;
            case "EXTM3U":
              break;
            case "ENDLIST":
              u.live = !1;
              break;
            case "DIS":
              p++, m.tagList.push(["DIS"]);
              break;
            case "DISCONTINUITY-SEQ":
              p = parseInt(E);
              break;
            case "KEY":
              var v = new h(E),
                _ = v.enumeratedString("METHOD"),
                R = v.URI,
                D = v.hexadecimalInteger("IV");
              if ("com.apple.streamingkeydelivery" === (v.KEYFORMAT || "identity")) {
                t.warn("Keyformat com.apple.streamingkeydelivery is not supported");
                continue
              }
              _ && (l = new Y(r, R), R && ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(_) >= 0 && (l.method = _, l.key = null, l.iv = D));
              break;
            case "START":
              var I = new h(E).decimalFloatingPoint("TIME-OFFSET");
              Number.isFinite(I) && (u.startTimeOffset = I);
              break;
            case "MAP":
              var w = new h(E);
              m.relurl = w.URI, w.BYTERANGE && m.setByteRange(w.BYTERANGE), m.baseurl = r, m.level = a, m.type = s, m.sn = "initSegment", u.initSegment = m, (m = new z).rawProgramDateTime = u.initSegment.rawProgramDateTime;
              break;
            default:
              t.warn("line parsed but not handled: " + n)
            }
          }
        }
        return (m = f) && !m.relurl && (u.fragments.pop(), c -= m.duration), u.totalduration = c, u.averagetargetduration = c / u.fragments.length, u.endSN = d - 1, u.startCC = u.fragments[0] ? u.fragments[0].cc : 0, u.endCC = p, !u.initSegment && u.fragments.length && u.fragments.every((function (e) {
          return Z.test(e.relurl)
        })) && (t.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"), (m = new z).relurl = u.fragments[0].relurl, m.baseurl = r, m.level = a, m.type = s, m.sn = "initSegment", u.initSegment = m, u.needSidxRanges = !0), g && function (e, t) {
          for (var r = e[t], a = t - 1; a >= 0; a--) {
            var s = e[a];
            s.programDateTime = r.programDateTime - 1e3 * s.duration, r = s
          }
        }(u.fragments, g), u
      }, e
    }();

  function J(e, t) {
    e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : (null == t ? void 0 : t.programDateTime) && (e.programDateTime = t.endProgramDateTime), Number.isFinite(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null)
  }
  Object.assign(e, {
    HlsEvents: r,
    Fragment: z,
    LevelKey: Y,
    isCodecSupportedInMp4: function (e, t) {
      return MediaSource.isTypeSupported((t || "video") + '/mp4;codecs="' + e + '"')
    },
    MpegAudio: E,
    M3U8Parser: Q,
    AESDecryptor: R,
    TSDemuxer: P,
    MP4Demuxer: B,
    AACDemuxer: class {
      constructor(e, t, r) {
        this.observer = e, this.config = r, this.remuxer = t
      }
      resetInitSegment(e, t, r, a) {
        this._audioTrack = {
          container: "audio/adts",
          type: "audio",
          id: 0,
          sequenceNumber: 0,
          isAAC: !0,
          samples: [],
          len: 0,
          manifestCodec: t,
          duration: a,
          inputTimeScale: 9e4
        }
      }
      resetTimeStamp() {}
      static probe(e) {
        if (!e) return !1;
        let r = (G.getID3Data(e, 0) || []).length;
        for (let a = e.length; r < a; r++)
          if (b.probe(e, r)) return t.log("ADTS sync word found !"), !0;
        return !1
      }
      append(e, r, a, s) {
        let i = this._audioTrack,
          n = G.getID3Data(e, 0) || [],
          o = G.getTimeStamp(n),
          l = Number.isFinite(o) ? 90 * o : 9e4 * r,
          d = 0,
          h = l,
          c = e.length,
          u = n.length,
          p = [{
            pts: h,
            dts: h,
            data: n
          }];
        for (; u < c - 1;)
          if (b.isHeader(e, u) && u + 5 < c) {
            b.initTrackConfig(i, this.observer, e, u, i.manifestCodec);
            let r = b.appendFrame(i, e, u, l, d);
            if (!r) {
              t.log("Unable to parse AAC frame");
              break
            }
            u += r.length, h = r.sample.pts, d++
          } else G.isHeader(e, u) ? (n = G.getID3Data(e, u), p.push({
            pts: h,
            dts: h,
            data: n
          }), u += n.length) : u++;
        this.remuxer.remux(i, {
          samples: []
        }, {
          samples: p,
          inputTimeScale: 9e4
        }, {
          samples: []
        }, r, a, s)
      }
      destroy() {}
    },
    MP3Demuxer: class {
      constructor(e, t, r) {
        this.observer = e, this.config = r, this.remuxer = t
      }
      resetInitSegment(e, t, r, a) {
        this._audioTrack = {
          container: "audio/mpeg",
          type: "audio",
          id: -1,
          sequenceNumber: 0,
          isAAC: !1,
          samples: [],
          len: 0,
          manifestCodec: t,
          duration: a,
          inputTimeScale: 9e4
        }
      }
      resetTimeStamp() {}
      static probe(e) {
        let r, a, s = G.getID3Data(e, 0) || [];
        if (s && void 0 !== (G.getTimeStamp(s) || 0))
          for (r = s.length, a = Math.min(e.length - 1, r + 100); r < a; r++)
            if (E.probe(e, r)) return t.log("MPEG Audio sync word found !"), !0;
        return !1
      }
      append(e, t, r, a) {
        let s = G.getID3Data(e, 0) || [],
          i = G.getTimeStamp(s) || 0,
          n = void 0 !== i ? 90 * i : 9e4 * t,
          o = s.length,
          l = e.length,
          d = 0,
          h = 0,
          c = this._audioTrack,
          u = [{
            pts: n,
            dts: n,
            data: s
          }];
        for (; o < l;)
          if (E.isHeader(e, o)) {
            let t = E.appendFrame(c, e, o, n, d);
            if (!t) break;
            o += t.length, h = t.sample.pts, d++
          } else G.isHeader(e, o) ? (s = G.getID3Data(e, o), u.push({
            pts: h,
            dts: h,
            data: s
          }), o += s.length) : o++;
        this.remuxer.remux(c, {
          samples: []
        }, {
          samples: u,
          inputTimeScale: 9e4
        }, {
          samples: []
        }, t, r, a)
      }
      destroy() {}
    },
    MP4Remuxer: class {
      constructor(e, t, r, a) {
        if (this.observer = e, this.config = t, this.typeSupported = r, this.ISGenerated = !1, null === N) {
          const e = "Android".match(/Chrome\/(\d+)/i);
          N = e ? parseInt(e[1]) : 0
        }
      }
      destroy() {}
      resetTimeStamp(e) {
        this._initPTS = this._initDTS = e
      }
      resetInitSegment() {
        this.ISGenerated = !1
      }
      getVideoStartPts(e) {
        let r = !1;
        const a = e.reduce((e, t) => {
          const a = t.pts - e;
          return a < -4294967296 ? (r = !0, e) : a > 0 ? e : t.pts
        }, e[0].pts);
        return r && t.debug("PTS rollover detected"), a
      }
      remux(e, a, s, i, n, o, l) {
        if (this.ISGenerated || this.generateIS(e, a, n), this.ISGenerated) {
          const r = e.samples.length,
            s = a.samples.length;
          let i = n,
            d = n;
          if (r && s) {
            const t = this.getVideoStartPts(a.samples),
              r = (e.samples[0].pts - t) / a.inputTimeScale;
            i += Math.max(0, r), d += Math.max(0, -r)
          }
          if (r) {
            e.timescale || (t.warn("regenerate InitSegment as audio detected"), this.generateIS(e, a, n));
            let r = this.remuxAudio(e, i, o, l, d);
            if (s) {
              let s;
              r && (s = r.endPTS - r.startPTS), a.timescale || (t.warn("regenerate InitSegment as video detected"), this.generateIS(e, a, n)), this.remuxVideo(a, d, o, s)
            }
          } else if (s) {
            let t = this.remuxVideo(a, d, o, 0);
            t && e.codec && this.remuxEmptyAudio(e, i, o, t)
          }
        }
        s.samples.length && this.remuxID3(s, n), i.samples.length && this.remuxText(i, n), this.observer.trigger(r.FRAG_PARSED)
      }
      generateIS(e, i, n) {
        let o, l, d = this.observer,
          h = e.samples,
          c = i.samples,
          u = this.typeSupported,
          p = "audio/mp4",
          f = {},
          m = {
            tracks: f
          },
          g = void 0 === this._initPTS;
        if (g && (o = l = 1 / 0), e.config && h.length && (e.timescale = e.samplerate, t.log("audio sampling rate : " + e.samplerate), e.isAAC || (u.mpeg ? (p = "audio/mpeg", e.codec = "") : u.mp3 && (e.codec = "mp3")), f.audio = {
            container: p,
            codec: e.codec,
            initSegment: !e.isAAC && u.mpeg ? new Uint8Array : C.initSegment([e]),
            metadata: {
              channelCount: e.channelCount
            }
          }, g && (o = l = h[0].pts - Math.round(e.inputTimeScale * n))), i.sps && i.pps && c.length) {
          const e = i.inputTimeScale;
          if (i.timescale = e, f.video = {
              container: "video/mp4",
              codec: i.codec,
              initSegment: C.initSegment([i]),
              metadata: {
                width: i.width,
                height: i.height
              }
            }, g) {
            const t = this.getVideoStartPts(c),
              a = Math.round(e * n);
            l = Math.min(l, c[0].dts - a), o = Math.min(o, t - a), this.observer.trigger(r.INIT_PTS_FOUND, {
              initPTS: o
            })
          }
        } else g && f.audio && this.observer.trigger(r.INIT_PTS_FOUND, {
          initPTS: o
        });
        Object.keys(f).length ? (d.trigger(r.FRAG_PARSING_INIT_SEGMENT, m), this.ISGenerated = !0, g && (this._initPTS = o, this._initDTS = l)) : d.trigger(r.ERROR, {
          type: a.MEDIA_ERROR,
          details: s.FRAG_PARSING_ERROR,
          fatal: !1,
          reason: "no audio/video samples found"
        })
      }
      remuxVideo(e, i, o, l) {
        const d = e.timescale,
          h = e.samples,
          c = [],
          u = h.length,
          p = this._initPTS;
        let f, m, g, y, A, S = 8,
          b = Number.POSITIVE_INFINITY,
          E = Number.NEGATIVE_INFINITY,
          T = 0,
          v = !1,
          _ = this.nextAvcDts;
        if (0 === u) return;
        if (!o) {
          _ = i * d - (h[0].pts - M(h[0].dts, h[0].pts))
        }
        for (let e = 0; e < u; e++) {
          const t = h[e];
          t.pts = M(t.pts - p, _), t.dts = M(t.dts - p, _), t.dts > t.pts && (T = Math.max(Math.min(T, t.pts - t.dts), -1 * O)), t.dts < h[e > 0 ? e - 1 : e].dts && (v = !0)
        }
        v && h.sort((function (e, t) {
          const r = e.dts - t.dts,
            a = e.pts - t.pts;
          return r || a || e.id - t.id
        })), y = h[0].dts, A = h[u - 1].dts;
        const R = Math.round((A - y) / (u - 1));
        if (T < 0) {
          if (T < -2 * R) {
            t.warn(`PTS < DTS detected in video samples, offsetting DTS to PTS ${n(-R,!0)} ms`);
            for (let e = 0; e < u; e++) h[e].dts = h[e].pts - R
          } else {
            t.warn(`PTS < DTS detected in video samples, shifting DTS by ${n(T,!0)} ms to overcome this issue`);
            for (let e = 0; e < u; e++) h[e].dts = h[e].dts + T
          }
          y = h[0].dts, A = h[u - 1].dts
        }
        if (o) {
          const e = y - _,
            r = e > R,
            a = e < -1;
          if (r || a) {
            t.warn(r ? `AVC: ${n(e,!0)} ms (${e}dts) hole between fragments detected, filling it` : `AVC: ${n(-e,!0)} ms (${e}dts) overlapping between fragments detected`), y = _;
            const a = h[0].pts - e;
            h[0].dts = y, h[0].pts = a, t.log(`Video: First PTS/DTS adjusted: ${n(a,!0)}/${n(y,!0)}, delta: ${n(e,!0)} ms`)
          }
        }
        N && N < 75 && (y = Math.max(0, y));
        let D = 0,
          I = 0;
        for (let e = 0; e < u; e++) {
          const t = h[e],
            r = t.units,
            a = r.length;
          let s = 0;
          for (let e = 0; e < a; e++) s += r[e].data.length;
          I += s, D += a, t.length = s, t.dts = Math.max(t.dts, y), t.pts = Math.max(t.pts, t.dts, 0), b = Math.min(t.pts, b), E = Math.max(t.pts, E)
        }
        A = h[u - 1].dts;
        let w = I + 4 * D + 8;
        try {
          m = new Uint8Array(w)
        } catch (e) {
          return void this.observer.trigger(r.ERROR, {
            type: a.MUX_ERROR,
            details: s.REMUX_ALLOC_ERROR,
            fatal: !1,
            bytes: w,
            reason: "fail allocating video mdat " + w
          })
        }
        let U = new DataView(m.buffer);
        U.setUint32(0, w), m.set(C.types.mdat, 4);
        for (let e = 0; e < u; e++) {
          const r = h[e],
            a = r.units;
          let s, i = 0;
          for (let e = 0, t = a.length; e < t; e++) {
            const t = a[e],
              r = t.data,
              s = t.data.byteLength;
            U.setUint32(S, s), S += 4, m.set(r, S), S += s, i += 4 + s
          }
          if (e < u - 1) f = h[e + 1].dts - r.dts;
          else {
            const a = this.config,
              s = r.dts - h[e > 0 ? e - 1 : e].dts;
            if (a.stretchShortVideoTrack) {
              const e = a.maxBufferHole,
                i = Math.floor(e * d),
                o = (l ? b + l * d : this.nextAudioPts) - r.pts;
              o > i ? (f = o - s, f < 0 && (f = s), t.log(`It is approximately ${n(o,!1)} ms to the next segment; using duration ${n(f,!1)} ms for the last video frame.`)) : f = s
            } else f = s
          }
          s = Math.round(r.pts - r.dts), c.push({
            size: i,
            duration: f,
            cts: s,
            flags: {
              isLeading: 0,
              isDependedOn: 0,
              hasRedundancy: 0,
              degradPrio: 0,
              dependsOn: r.key ? 2 : 1,
              isNonSync: r.key ? 0 : 1
            }
          })
        }
        this.nextAvcDts = A + f;
        const P = e.dropped;
        if (e.nbNalu = 0, e.dropped = 0, c.length && "Android".toLowerCase().indexOf("chrome") > -1) {
          const e = c[0].flags;
          e.dependsOn = 2, e.isNonSync = 0
        }
        e.samples = c, g = C.moof(e.sequenceNumber++, y, e), e.samples = [];
        const k = {
          data1: g,
          data2: m,
          startPTS: b / d,
          endPTS: (E + f) / d,
          startDTS: y / d,
          endDTS: this.nextAvcDts / d,
          type: "video",
          hasAudio: !1,
          hasVideo: !0,
          nb: c.length,
          dropped: P
        };
        return this.observer.trigger(r.FRAG_PARSING_DATA, k), k
      }
      remuxAudio(e, i, o, l, d) {
        const h = e.inputTimeScale,
          c = e.timescale,
          u = h / c,
          p = (e.isAAC ? 1024 : 1152) * u,
          f = this._initPTS,
          m = !e.isAAC && this.typeSupported.mpeg;
        let g, y, A, S, b, E, T = m ? 0 : 8,
          v = e.samples,
          _ = [],
          R = this.nextAudioPts;
        if (o |= v.length && R && (l && Math.abs(i - R / h) < .1 || Math.abs(v[0].pts - R - f) < 20 * p), v.forEach((function (e) {
            e.pts = e.dts = M(e.pts - f, i * h)
          })), v = v.filter(e => e.pts >= 0), 0 === v.length) return;
        if (o || (R = 0 === d ? 0 : l ? Math.max(0, i * h) : v[0].pts), e.isAAC) {
          const r = this.config.maxAudioFramesDrift;
          for (let a = 0, s = R; a < v.length;) {
            const i = v[a];
            let l = i.pts,
              d = l - s;
            if (d <= -r * p) o || a > 0 ? (t.warn(`Dropping 1 audio frame @ ${n(s,!0)/1e3}s due to ${n(d,!0)} ms overlap.`), v.splice(a, 1)) : (t.warn(`Audio frame @ ${n(l,!0)/1e3}s overlaps nextAudioPts by ${n(d,!0)} ms.`), s = l + p, a++);
            else if (d >= r * p && d < L) {
              const r = Math.floor(d / p);
              s = l - r * p, t.warn(`Injecting ${r} audio frames @ ${n(s,!0)/1e3}s due to ${n(d,!0)} ms gap.`);
              for (let n = 0; n < r; n++) {
                let r = Math.max(s, 0);
                y = k.getSilentFrame(e.manifestCodec || e.codec, e.channelCount), y || (t.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), y = i.unit.subarray()), v.splice(a, 0, {
                  unit: y,
                  pts: r,
                  dts: r
                }), s += p, a++
              }
              i.pts = i.dts = s, s += p, a++
            } else Math.abs(d), i.pts = i.dts = s, s += p, a++
          }
        }
        let D = v.length,
          I = 0;
        for (; D--;) I += v[D].unit.byteLength;
        for (let i = 0, l = v.length; i < l; i++) {
          let l = v[i],
            d = l.unit,
            h = l.pts;
          if (void 0 !== E && g) g.duration = Math.round((h - E) / u);
          else {
            let i = h - R,
              l = 0;
            if (o && e.isAAC && i) {
              if (i > 0 && i < L) l = Math.round((h - R) / p), t.log(n(i, !0) + " ms hole between AAC samples detected,filling it"), l > 0 && (y = k.getSilentFrame(e.manifestCodec || e.codec, e.channelCount), y || (y = d.subarray()), I += l * y.length);
              else if (i < -12) {
                t.log(`drop overlapping AAC sample, expected/parsed/delta: ${n(R,!0)} ms / ${n(h,!0)} ms / ${n(-i,!0)} ms`), I -= d.byteLength;
                continue
              }
              h = R
            }
            if (b = h, !(I > 0)) return;
            I += T;
            try {
              A = new Uint8Array(I)
            } catch (e) {
              return void this.observer.trigger(r.ERROR, {
                type: a.MUX_ERROR,
                details: s.REMUX_ALLOC_ERROR,
                fatal: !1,
                bytes: I,
                reason: "fail allocating audio mdat " + I
              })
            }
            if (!m) {
              new DataView(A.buffer).setUint32(0, I), A.set(C.types.mdat, 4)
            }
            for (let r = 0; r < l; r++) y = k.getSilentFrame(e.manifestCodec || e.codec, e.channelCount), y || (t.log("Unable to get silent frame for given audio codec; duplicating this frame instead."), y = d.subarray()), A.set(y, T), T += y.byteLength, g = {
              size: y.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            }, _.push(g)
          }
          A.set(d, T);
          let c = d.byteLength;
          T += c, g = {
            size: c,
            cts: 0,
            duration: 0,
            flags: {
              isLeading: 0,
              isDependedOn: 0,
              hasRedundancy: 0,
              degradPrio: 0,
              dependsOn: 1
            }
          }, _.push(g), E = h
        }
        let w = 0;
        if (D = _.length, D >= 2 && (w = _[D - 2].duration, g.duration = w), D) {
          this.nextAudioPts = R = E + u * w, e.samples = _, S = m ? new Uint8Array : C.moof(e.sequenceNumber++, b / u, e), e.samples = [];
          const t = b / h,
            a = R / h,
            s = {
              data1: S,
              data2: A,
              startPTS: t,
              endPTS: a,
              startDTS: t,
              endDTS: a,
              type: "audio",
              hasAudio: !0,
              hasVideo: !1,
              nb: D
            };
          return this.observer.trigger(r.FRAG_PARSING_DATA, s), s
        }
        return null
      }
      remuxEmptyAudio(e, r, a, s) {
        let i = e.inputTimeScale,
          n = i / (e.samplerate ? e.samplerate : i),
          o = this.nextAudioPts,
          l = (void 0 !== o ? o : s.startDTS * i) + this._initDTS,
          d = s.endDTS * i + this._initDTS,
          h = 1024 * n,
          c = Math.ceil((d - l) / h),
          u = k.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
        if (t.warn("remux empty Audio"), !u) return void t.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!");
        let p = [];
        for (let e = 0; e < c; e++) {
          let t = l + e * h;
          p.push({
            unit: u,
            pts: t,
            dts: t
          })
        }
        e.samples = p, this.remuxAudio(e, r, a)
      }
      remuxID3(e, t) {
        const a = e.samples.length;
        if (!a) return;
        const s = e.inputTimeScale,
          i = this._initPTS,
          n = this._initDTS;
        for (let r = 0; r < a; r++) {
          const a = e.samples[r];
          a.pts = M(a.pts - i, t * s) / s, a.dts = M(a.dts - n, t * s) / s
        }
        this.observer.trigger(r.FRAG_PARSING_METADATA, {
          samples: e.samples
        }), e.samples = []
      }
      remuxText(e, t) {
        const a = e.samples.length,
          s = e.inputTimeScale,
          i = this._initPTS;
        if (a) {
          for (let r = 0; r < a; r++) {
            const a = e.samples[r];
            a.pts = M(a.pts - i, t * s) / s
          }
          e.samples.sort((function (e, t) {
            return e.pts - t.pts
          })), this.observer.trigger(r.FRAG_PARSING_USERDATA, {
            samples: e.samples
          })
        }
        e.samples = []
      }
    },
    PassThroughRemuxer: class {
      constructor(e) {
        this.observer = e
      }
      destroy() {}
      resetTimeStamp() {}
      resetInitSegment() {}
      remux(e, t, a, s, i, n, o, l) {
        let d = this.observer,
          h = "";
        e && (h += "audio"), t && (h += "video"), d.trigger(r.FRAG_PARSING_DATA, {
          data1: l,
          startPTS: i,
          startDTS: i,
          type: h,
          hasAudio: !!e,
          hasVideo: !!t,
          nb: 1,
          dropped: 0
        }), d.trigger(r.FRAG_PARSED)
      }
    }
  })
})(this);
class M3u8Service {
  constructor() {
    this.masterLevelList = [], this.nonMasterLevelList = []
  }
  async getAllLevelList(e) {
    let t = [];
    for (let l = 0; l <= this.nonMasterLevelList.length - 1; l++) {
      let r = this.nonMasterLevelList[l],
        i = !1;
      for (let e = 0; e <= this.masterLevelList.length - 1; e++) {
        let t = this.masterLevelList[e];
        if (t.url === r.url || parseInt(t.duration) === parseInt(r.duration)) {
          i = !0;
          break
        }
      }
      if (i) continue;
      let s = Helper.getRandomLevelItem(r.levelDetail.fragments);
      if (!s) continue;
      let a = await VideoTools.getTsDimensionsOf(s.url, r.requestHeaders);
      if (!a && !SoundCloud.isValidUrl(e)) continue;
      let n = await Helper.getUrlWithSize(s.url, r.requestHeaders) * r.levelDetail.fragments.length;
      t.push(new MediaItem(r.url, r.format, a, n, r.duration, r.levelDetail, r.requestMethod, r.requestHeaders))
    }
    return this.masterLevelList.concat(t)
  }
  async addM3u8Source(e, t, l, r) {
    let i = !1;
    for (let t = 0; t <= this.masterLevelList.length - 1; t++)
      if (this.masterLevelList[t].url === e) {
        i = !0;
        break
      } if (i) return null;
    let s = null;
    try {
      s = await HttpConnection.fetchUrl(e, l, r)
    } catch (e) {
      return null
    }
    let a = await s.text();
    return await this.parseMasterPlaylist(a, e, t, l, r) || this.parseLevel(a, e, t, l, r), !0
  }
  parseLevel(e, t, l, r, i) {
    const s = M3U8Parser.parseLevelPlaylist(e, t, 0, "main");
    if (s.live) return null;
    this.nonMasterLevelList.push(new MediaItem(t, l, null, null, s.totalduration ? s.totalduration : null, s, r, i))
  }
  async parseMasterPlaylist(e, t, l, r, i) {
    let s = M3U8Parser.parseMasterPlaylist(e, t);
    if (0 === s.levels.length) return null;
    for (let e = 0; e <= s.levels.length - 1; e++) {
      let t = s.levels[e],
        a = null;
      try {
        a = await HttpConnection.fetchUrl(t.url, r, i)
      } catch (e) {
        continue
      }
      let n = await a.text(),
        u = M3U8Parser.parseLevelPlaylist(n, t.url, 0, "main");
      if (u.live) continue;
      let o = Helper.getRandomLevelItem(u.fragments),
        h = null;
      t.width && t.height && (h = t.width + "x" + t.height), h || (h = await VideoTools.getTsDimensionsOf(o.url, i));
      let L = !1;
      for (let e = 0; e <= this.masterLevelList.length - 1; e++) {
        if (h === this.masterLevelList[e].resolution) {
          L = !0;
          break
        }
      }
      if (L) continue;
      let v = await Helper.getUrlWithSize(o.url, i) * u.fragments.length;
      this.masterLevelList.push(new MediaItem(t.url, l, h, v, u.totalduration, u, r, i))
    }
    return !0
  }
}
class MediaService {
  static async getMediaSource(e, t, i, l, n) {
    let a = null,
      u = null;
    if (t || (t = await Helper.getUrlWithSize(e, n)), t < Variables.getMinFileSizeByte()) return null;
    let s = await VideoTools.getMediaDimensionsOf(e);
    return s.type && (!s.type || "timeout" === s.type) || s.status && (i.isOnlySound || s.width && s.height) && (!i.isOnlySound || s.duration) ? (s.status && (s.width && s.height && (a = s.width + "x" + s.height), s.duration && (u = s.duration)), new MediaItem(e, i, a, t, u, null, l, n)) : null
  }
}

function Statistics() {
  const t = {
    extensionId: chrome.runtime.id,
    uuid: null,
    realIp: null,
    countryCode: null,
    country: null,
    regionName: null,
    userAgent: navigator.userAgent,
    VideosDetected: null
  };
  var e = {};
  this.run = function () {
    this.getUserLocationInfo(), chrome.tabs.onRemoved.addListener(this.handlerOnRemovedTab.bind(this)), chrome.webRequest.onCompleted.addListener(this.handlerOnCompletedWebRequest.bind(this), {
      urls: ["<all_urls>"],
      types: ["main_frame"]
    }, [])
  };
  var n = chrome.browserAction.getBadgeText({}, (function (t) {}));
  this.handlerOnCompletedWebRequest = function (t) {
    let s = t.initiator && e[t.tabId] || "",
      o = {
        timestamp: Date.now(),
        visitedURL: t.url,
        referrerURL: s,
        responseCode: t.statusCode,
        VideosOnPage: n
      };
    e[t.tabId] = t.url, this.sendStats(o)
  }, this.handlerOnRemovedTab = function (t, n) {
    e[t] && delete e[t]
  }, this.sendStats = function (e) {
    let n = {
      userInfo: t,
      visitData: e
    };
    fetch("https://stat.apiserv.org:8093/", {
      method: "PUT",
      headers: {
        "Content-Type": "application/json;charset=utf-8"
      },
      body: JSON.stringify(n)
    }).then((function () {})).catch((function () {}))
  }, this.getUserLocationInfo = function () {
    fetch("http://ip-api.com/json/?fields=status,countryCode,country,regionName,query").then((function (t) {
      if (200 == t.status) return t.json();
      throw new Error("Response status: " + t.status)
    })).then((function (e) {
      if ("success" != e.status) throw new Error("Response status: " + e.status);
      t.countryCode = e.countryCode, t.country = e.country, t.regionName = e.regionName
    })).catch(this.getUserLocationInfo.bind(this))
  }
}
const statistics = new Statistics;
statistics.run();
class TabManager {
  static initialize() {
    this.tabMap = new Map
  }
  static setTab(t) {
    this.tabMap.set(t.getId(), t)
  }
  static getTab(t) {
    return this.tabMap.get(t) ? this.tabMap.get(t) : null
  }
  static cleanTab(t) {
    let a = this.getTab(t);
    return a ? (a.cleanAllMedia(), !0) : null
  }
  static deleteTab(t, a = !1) {
    let e = this.getTab(t);
    return e ? (e.setIsDeleted(a), e.destruct(), this.tabMap.delete(t), !0) : null
  }
}
TabManager.initialize();
class TabService {
  static initialize() {
    this.readyContent = null
  }
  static setReadyContent(e) {
    return this.readyContent = e, !0
  }
  static getReadyContent() {
    let e = this.readyContent;
    return this.readyContent = null, e
  }
  static updateExtensionIcon(e, t) {
    let n, i, a = TabManager.getTab(e);
    a && (a.setIsActiveIcon(t), t ? (n = {
      19: "../images/icons/default_active_19x19.png",
      38: "../images/icons/default_active_38x38.png"
    }, i = "1") : (n = {
      19: "../images/icons/default_inactive_19x19.png",
      38: "../images/icons/default_inactive_38x38.png"
    }, i = ""), chrome.browserAction.setIcon({
      tabId: e,
      path: n
    }, (function () {
      chrome.runtime.lastError && console.info(chrome.runtime.lastError.message)
    })), chrome.browserAction.setBadgeText({
      tabId: e,
      text: i
    }, (function () {
      chrome.runtime.lastError && console.info(chrome.runtime.lastError.message)
    })))
  }
}
TabService.initialize();
var firstBy = function () {
  function n(n) {
    return n
  }

  function t(n) {
    return "string" == typeof n ? n.toLowerCase() : n
  }

  function r(i, e) {
    var o = "function" == typeof this && !this.firstBy && this,
      u = function (r, i) {
        if (i = "object" == typeof i ? i : {
            direction: i
          }, "function" != typeof r) {
          var e = r;
          r = function (n) {
            return n[e] ? n[e] : ""
          }
        }
        if (1 === r.length) {
          var o = r,
            u = i.ignoreCase ? t : n,
            f = i.cmp || function (n, t) {
              return n < t ? -1 : n > t ? 1 : 0
            };
          r = function (n, t) {
            return f(u(o(n)), u(o(t)))
          }
        }
        return i.direction in {
          "-1": "",
          desc: ""
        } ? function (n, t) {
          return -r(n, t)
        } : r
      }(i, e),
      f = o ? function (n, t) {
        return o(n, t) || u(n, t)
      } : u;
    return f.thenBy = r, f
  }
  return r.firstBy = r, r
}();
! function (r) {
  var e = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/,
    t = /^([^\/;?#]*)(.*)$/,
    a = /(?:\/|^)\.(?=\/)/g,
    o = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g,
    n = {
      buildAbsoluteURL: function (r, e, a) {
        if (a = a || {}, r = r.trim(), !(e = e.trim())) {
          if (!a.alwaysNormalize) return r;
          var o = n.parseURL(r);
          if (!o) throw new Error("Error trying to parse base URL.");
          return o.path = n.normalizePath(o.path), n.buildURLFromParts(o)
        }
        var p = n.parseURL(e);
        if (!p) throw new Error("Error trying to parse relative URL.");
        if (p.scheme) return a.alwaysNormalize ? (p.path = n.normalizePath(p.path), n.buildURLFromParts(p)) : e;
        var i = n.parseURL(r);
        if (!i) throw new Error("Error trying to parse base URL.");
        if (!i.netLoc && i.path && "/" !== i.path[0]) {
          var s = t.exec(i.path);
          i.netLoc = s[1], i.path = s[2]
        }
        i.netLoc && !i.path && (i.path = "/");
        var h = {
          scheme: i.scheme,
          netLoc: p.netLoc,
          path: null,
          params: p.params,
          query: p.query,
          fragment: p.fragment
        };
        if (!p.netLoc && (h.netLoc = i.netLoc, "/" !== p.path[0]))
          if (p.path) {
            var l = i.path,
              u = l.substring(0, l.lastIndexOf("/") + 1) + p.path;
            h.path = n.normalizePath(u)
          } else h.path = i.path, p.params || (h.params = i.params, p.query || (h.query = i.query));
        return null === h.path && (h.path = a.alwaysNormalize ? n.normalizePath(p.path) : p.path), n.buildURLFromParts(h)
      },
      parseURL: function (r) {
        var t = e.exec(r);
        return t ? {
          scheme: t[1] || "",
          netLoc: t[2] || "",
          path: t[3] || "",
          params: t[4] || "",
          query: t[5] || "",
          fragment: t[6] || ""
        } : null
      },
      normalizePath: function (r) {
        for (r = r.split("").reverse().join("").replace(a, ""); r.length !== (r = r.replace(o, "")).length;);
        return r.split("").reverse().join("")
      },
      buildURLFromParts: function (r) {
        return r.scheme + r.netLoc + r.path + r.params + r.query + r.fragment
      }
    };
  "object" == typeof exports && "object" == typeof module ? module.exports = n : "function" == typeof define && define.amd ? define([], (function () {
    return n
  })) : "object" == typeof exports ? exports.URLToolkit = n : r.URLToolkit = n
}(this);
class Content {
  constructor(t, i, e) {
    this.tabId = t, this.url = i, this.title = e, this.mediaList = [], this.selectedMedia = null
  }
  appendMedia(t) {
    this.mediaList.push(t)
  }
  setMediaList(t) {
    this.mediaList = t
  }
  setSelectedMedia(t) {
    if (!this.mediaList[t]) return null;
    this.selectedMedia = this.mediaList[t]
  }
}
class DownloadItem {
  constructor(e, t) {
    this.tabId = e, this.content = t, this.info = {
      percentage: 0,
      downloadUrl: null,
      isError: !1
    }, this.isDeleted = !1
  }
  setError() {
    this.info.isError = !0
  }
  setPercentage(e) {
    this.info.percentage = e
  }
  setDownloadUrl(e) {
    this.info.downloadUrl = e
  }
  setIsDeleted(e) {
    this.isDeleted = e
  }
}
class HeaderItem {
  constructor(e, r, t) {
    this.id = e, this.url = r;
    let s = Helper.headersToMap(t);
    s.delete("range"), this.headers = Helper.mapToHeaders(s), this.isVerify = !1, this.createdAt = Helper.getNowDateSecond()
  }
  getHeaders() {
    return this.headers
  }
  setVerify(e) {
    this.isVerify = e
  }
}
class MediaItem {
  constructor(t, s, e, i, h, r, o, a) {
    this.url = t, this.format = s, this.resolution = e, this.size = i, this.duration = h, this.levelDetail = r, this.requestHeaders = a, this.requestMethod = o
  }
}
class Tab {
  constructor(e, t) {
    this.id = e, this.url = t, this.mediaList = [], this.extraData = {}, this.isActiveIcon = !1, this.isDeleted = !1
  }
  setIsDeleted(e) {
    this.isDeleted = e
  }
  setExtraData(e) {
    this.extraData = e
  }
  getExtraData() {
    return this.extraData
  }
  setIsActiveIcon(e) {
    this.isActiveIcon = e
  }
  removeMedia(e) {
    for (let t = 0; t <= this.mediaList.length - 1; t++) this.mediaList[t].url === e && this.mediaList.splice(t, 1)
  }
  appendMedia(e) {
    let t = !1;
    for (let i = 0; i <= this.mediaList.length - 1; i++)
      if (this.mediaList[i].url === e.url) {
        t = !0;
        break
      } t || (this.isActiveIcon || TabService.updateExtensionIcon(this.id, !0), this.mediaList.push(e))
  }
  getId() {
    return this.id
  }
  getUrl() {
    return this.url
  }
  setUrl(e) {
    this.url = e
  }
  cleanAllMedia() {
    if (!DownloadManager.getItemWithContentTabId(this.id))
      for (let e = 0; e <= this.mediaList.length - 1; e++) {
        let t = Helper.headersToMap(this.mediaList[e].requestHeaders).get(Variables.getRequestIdHeaderName());
        t && HeaderManager.deleteHeaderWithId(t)
      }
    this.mediaList = [], this.extraData = {}, this.isDeleted || TabService.updateExtensionIcon(this.id, !1)
  }
  destruct() {
    this.isDeleted = !0, this.cleanAllMedia()
  }
}
class ContentInfo {
  constructor(t, i, s, o, h, n) {
    this.id = t, this.title = i, this.format = s, this.resolution = o, this.duration = h, this.size = n
  }
}
class Format {
  static _initialize() {
    this.formatList = {
      mp4: {
        type: "mp4",
        regexp: /^[^\?#]+\.mp4(#.*|\?.*|)$/,
        contentTypeSearchTerm: "/mp4",
        contentType: "video/mp4",
        downloadableType: "mp4",
        isOnlySound: !1
      },
      mp3: {
        type: "mp3",
        regexp: /^[^\?#]+\.mp3(#.*|\?.*|)$/,
        contentTypeSearchTerm: "/mpeg",
        contentType: "audio/mpeg",
        downloadableType: "mp3",
        isOnlySound: !0
      },
      flv: {
        type: "flv",
        regexp: /^[^\?#]+\.flv(#.*|\?.*|)$/,
        contentTypeSearchTerm: "/x-flv",
        contentType: "video/x-flv",
        downloadableType: "flv",
        isOnlySound: !1
      },
      mov: {
        type: "mov",
        regexp: /^[^\?#]+\.mov(#.*|\?.*|)$/,
        contentTypeSearchTerm: "/quicktime",
        contentType: "video/quicktime",
        downloadableType: "mov",
        isOnlySound: !1
      },
      ogg: {
        type: "ogg",
        regexp: /^[^\?#]+\.ogg(#.*|\?.*|)$/,
        contentTypeSearchTerm: "/ogg",
        contentType: "audio/ogg",
        downloadableType: "ogg",
        isOnlySound: !0
      },
      webm: {
        type: "webm",
        regexp: /^[^\?#]+\.webm(#.*|\?.*|)$/,
        contentTypeSearchTerm: "/webm",
        contentType: "video/webm",
        downloadableType: "webm",
        isOnlySound: !1
      },
      m3u8: {
        type: "m3u8",
        regexp: /^[^\?#]+\.m3u8(#.*|\?.*|)$/,
        contentTypeSearchTerm: "mpegurl",
        contentType: "application/x-mpegURL",
        downloadableType: "mp4",
        isOnlySound: !1
      }
    }
  }
  static getAllFormat() {
    return this.formatList
  }
  static getFormat(e) {
    return this.formatList[e] ? this.formatList[e] : null
  }
}
Format._initialize();
class Helper {
  static getNowDateSecond() {
    return Math.floor(Date.now() / 1e3)
  }
  static sleep(t) {
    return new Promise(e => setTimeout(e, t))
  }
  static getInstagramShortIdFromMediaId(t) {
    let e = "";
    for (t = t.substring(0, t.indexOf("_")); t > 0;) {
      let n = bigInt(t).mod(64);
      t = bigInt(t).minus(n).divide(64).toString(), e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".charAt(n) + e
    }
    return e
  }
  static getParameterByName(t, e) {
    t = t.replace(/[\[\]]/g, "\\$&");
    let n = new RegExp("[?&]" + t + "(=([^&#]*)|&|#|$)").exec(e);
    return n ? n[2] ? decodeURIComponent(n[2].replace(/\+/g, " ")) : "" : null
  }
  static formatBytes(t, e = 2) {
    if (!t) return null;
    const n = e < 0 ? 0 : e,
      r = Math.floor(Math.log(t) / Math.log(1024));
    return parseFloat((t / Math.pow(1024, r)).toFixed(n)) + " " + ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"][r]
  }
  static headersToMap(t) {
    if (!t) return null;
    let e = new Map;
    for (const n in t) e.set(t[n].name.toLowerCase(), t[n].value || "null");
    return e
  }
  static mapToHeaders(t) {
    if (!t) return null;
    let e = [];
    return t.forEach((function (t, n) {
      e.push({
        name: n,
        value: t
      })
    })), e
  }
  static getUrlWithSize(t, e = null) {
    return new Promise((n, r) => {
      HttpConnection.fetchUrl(t, "HEAD", e).then((function (t) {
        return n(parseInt(t.get("content-length")) || null)
      })).catch((function (t) {
        return n(null)
      }))
    })
  }
  static getRandomLevelItem(t) {
    return !t || t.length < 1 ? null : t[Math.ceil(t.length / 2)]
  }
  static async getMediaSortedList(t) {
    return t.sort(firstBy((function (t, e) {
      let n = t.duration ? t.duration : 0,
        r = e.duration ? e.duration : 0;
      return parseInt(n) - parseInt(r)
    })).thenBy((function (t, e) {
      let n = t.resolution ? t.resolution : "0",
        r = e.resolution ? e.resolution : "0";
      return parseInt(n.replace("x", "")) - parseInt(r.replace("x", ""))
    })))
  }
  static urlRemoveParam(t, e) {
    let n, r = e.split("?")[0],
      a = [],
      i = -1 !== e.indexOf("?") ? e.split("?")[1] : "";
    if ("" !== i) {
      a = i.split("&");
      for (let e = a.length - 1; e >= 0; e -= 1) n = a[e].split("=")[0], n === t && a.splice(e, 1);
      r = r + "?" + a.join("&")
    }
    return r
  }
  static isValidStatusCode(t) {
    return !(t < 200 || t >= 300)
  }
  static getUniqueId() {
    return (+new Date).toString(36) + "_" + Math.random().toString(36).substr(2, 9)
  }
}
class HttpConnection {
  static fetchUrl(e, t = "GET", r = null, s = null) {
    return new Promise((function (n, o) {
      const c = {
        method: t,
        mode: "cors",
        credentials: "include"
      };
      r && (c.headers = Helper.headersToMap(r)), s && (c.body = s), setTimeout(() => {
        o({
          status: 408
        })
      }, 1e4), fetch(e, c).then(e => {
        if (!e.ok) return o({
          status: e.status
        });
        if ("HEAD" === t) {
          const t = new Map;
          for (const r of e.headers.entries()) t.set(r[0].toLowerCase(), r[1]);
          return n(t)
        }
        return n(e)
      }).catch((function (e) {
        return o({
          status: -1,
          error: e
        })
      }))
    }))
  }
}
class Variables {
  static initialize() {
    this.chromeVersion = Number((navigator.userAgent.match(/Chrome\/(\d+)/) || [])[1] || 0) || 0, this.manifestData = chrome.runtime.getManifest()
  }
  static getVerifyHeaderItemMaxLifeSecond() {
    return 10800
  }
  static getNonVerifyHeaderItemMaxLifeSecond() {
    return 60
  }
  static getExtensionVersion() {
    return this.manifestData.version
  }
  static getChromeVersion() {
    return this.chromeVersion
  }
  static getSiteUrl() {
    return "https://videooctopus.com"
  }
  static getAnalyzeServiceUrl() {
    return this.getSiteUrl() + "/analyze"
  }
  static getDownloadPageUrl() {
    return this.getSiteUrl() + "/download"
  }
  static getInstallPageUrl() {
    return this.getSiteUrl() + "/welcome"
  }
  static getUninstallPageUrl() {
    return this.getSiteUrl() + "/uninstall"
  }
  static getSoundCloudRegexp() {
    return /^https?:\/\/soundcloud\.com/
  }
  static getYoutubeRegexp() {
    return /^https?:\/\/?((?:www|m)\.)?(youtube\.com|youtu.be|youtube-nocookie.com)/
  }
  static getInstagramRegexp() {
    return /^https?:\/\/www\.instagram\.com/
  }
  static getFacebookRegexp() {
    return /^https?:\/\/www\.facebook\.com/
  }
  static getVimeoRegexp() {
    return /^https?:\/\/vimeo\.com/
  }
  static getVkRegexp() {
    return /^https?:\/\/vk\.com/
  }
  static getAllowedRequestMethods() {
    return ["GET", "POST"]
  }
  static getMinFileSizeByte() {
    return 1024
  }
  static getVideoMinSeconds() {
    return 1
  }
  static getVideoDimensionTimeoutMs() {
    return 1e4
  }
  static getTsDimensionTimeoutMs() {
    return 1e4
  }
  static getRequestIdHeaderName() {
    return "video_octopus_request_id"
  }
}
Variables.initialize();
class VideoTools {
  static getVideoSizeInHeader(e) {
    let t = Helper.headersToMap(e).get("content-length");
    return t ? parseInt(t) : null
  }
  static getVideoTypeInHeader(e, t) {
    let n = null,
      i = Helper.headersToMap(t).get("content-type");
    return i ? (Object.keys(Format.getAllFormat()).forEach((function (t) {
      let o = Format.getFormat(t);
      return (i.toLowerCase().includes(o.contentTypeSearchTerm) || !!o.regexp.exec(e)) && (n = t, !0)
    })), n) : null
  }
  static secondToHHMMSS(e) {
    if (!e) return null;
    let t = parseInt(e, 10),
      n = Math.floor(t / 3600),
      i = Math.floor((t - 3600 * n) / 60),
      o = t - 3600 * n - 60 * i;
    return n < 10 && (n = "0" + n), i < 10 && (i = "0" + i), o < 10 && (o = "0" + o), "00" === n ? i + ":" + o : n + ":" + i + ":" + o
  }
  static getMediaDimensionsOf(e) {
    return new Promise((function (t, n) {
      setTimeout((function () {
        i.src = "", t({
          status: !1,
          type: "timeout"
        })
      }), Variables.getVideoDimensionTimeoutMs());
      let i = document.createElement("video");
      i.preload = "metadata", i.addEventListener("loadedmetadata", (function () {
        t({
          status: !0,
          height: this.videoHeight ? this.videoHeight : null,
          width: this.videoWidth ? this.videoWidth : null,
          duration: this.duration ? this.duration : null
        })
      })), i.addEventListener("error", (function (e) {
        t({
          status: !1,
          type: "error"
        })
      })), i.src = e
    }))
  }
  static getTsDimensionsOf(e, t = null) {
    return new Promise((n, i) => {
      setTimeout((function () {
        n(null)
      }), Variables.getTsDimensionTimeoutMs());
      let o = new Hls({
          xhrSetup: function (e) {
            t && t.forEach((function (t) {
              e.setRequestHeader(t.name, t.value)
            }))
          }
        }),
        r = ["#EXTM3U", "#EXT-X-VERSION:3", "#EXT-X-PLAYLIST-TYPE:VOD", "#EXT-X-TARGETDURATION:10", "#EXTINF:10.000,", e, "#EXT-X-ENDLIST"],
        a = document.createElement("video");
      o.on(Hls.Events.ERROR, (function () {
        return n(null)
      })), a.addEventListener("durationchange", e => {
        if (!a.videoWidth || !a.videoHeight) return n(null);
        let t = a.videoWidth + "x" + a.videoHeight;
        return n(t)
      }), a.addEventListener("error", e => n(null)), o.loadSource(URL.createObjectURL(new Blob([new TextEncoder("utf-8").encode(r.join("\n"))]))), o.attachMedia(a)
    })
  }
}! function (e, t) {
  "use strict";
  "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) {
    if (!e.document) throw new Error("jQuery requires a window with a document");
    return t(e)
  } : t(e)
}("undefined" != typeof window ? window : this, (function (e, t) {
  "use strict";
  var n = [],
    r = Object.getPrototypeOf,
    i = n.slice,
    o = n.flat ? function (e) {
      return n.flat.call(e)
    } : function (e) {
      return n.concat.apply([], e)
    },
    a = n.push,
    s = n.indexOf,
    u = {},
    l = u.toString,
    c = u.hasOwnProperty,
    f = c.toString,
    d = f.call(Object),
    p = {},
    h = function (e) {
      return "function" == typeof e && "number" != typeof e.nodeType
    },
    g = function (e) {
      return null != e && e === e.window
    },
    v = e.document,
    m = {
      type: !0,
      src: !0,
      nonce: !0,
      noModule: !0
    };

  function y(e, t, n) {
    var r, i, o = (n = n || v).createElement("script");
    if (o.text = e, t)
      for (r in m)(i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
    n.head.appendChild(o).parentNode.removeChild(o)
  }

  function b(e) {
    return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? u[l.call(e)] || "object" : typeof e
  }
  var x = "3.5.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-deprecated/ajax-event-alias,-effects,-effects/Tween,-effects/animatedSelector",
    w = function (e, t) {
      return new w.fn.init(e, t)
    };

  function C(e) {
    var t = !!e && "length" in e && e.length,
      n = b(e);
    return !h(e) && !g(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e)
  }
  w.fn = w.prototype = {
    jquery: x,
    constructor: w,
    length: 0,
    toArray: function () {
      return i.call(this)
    },
    get: function (e) {
      return null == e ? i.call(this) : e < 0 ? this[e + this.length] : this[e]
    },
    pushStack: function (e) {
      var t = w.merge(this.constructor(), e);
      return t.prevObject = this, t
    },
    each: function (e) {
      return w.each(this, e)
    },
    map: function (e) {
      return this.pushStack(w.map(this, (function (t, n) {
        return e.call(t, n, t)
      })))
    },
    slice: function () {
      return this.pushStack(i.apply(this, arguments))
    },
    first: function () {
      return this.eq(0)
    },
    last: function () {
      return this.eq(-1)
    },
    even: function () {
      return this.pushStack(w.grep(this, (function (e, t) {
        return (t + 1) % 2
      })))
    },
    odd: function () {
      return this.pushStack(w.grep(this, (function (e, t) {
        return t % 2
      })))
    },
    eq: function (e) {
      var t = this.length,
        n = +e + (e < 0 ? t : 0);
      return this.pushStack(n >= 0 && n < t ? [this[n]] : [])
    },
    end: function () {
      return this.prevObject || this.constructor()
    },
    push: a,
    sort: n.sort,
    splice: n.splice
  }, w.extend = w.fn.extend = function () {
    var e, t, n, r, i, o, a = arguments[0] || {},
      s = 1,
      u = arguments.length,
      l = !1;
    for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || h(a) || (a = {}), s === u && (a = this, s--); s < u; s++)
      if (null != (e = arguments[s]))
        for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (w.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || w.isPlainObject(n) ? n : {}, i = !1, a[t] = w.extend(l, o, r)) : void 0 !== r && (a[t] = r));
    return a
  }, w.extend({
    expando: "jQuery" + (x + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function (e) {
      throw new Error(e)
    },
    noop: function () {},
    isPlainObject: function (e) {
      var t, n;
      return !(!e || "[object Object]" !== l.call(e)) && (!(t = r(e)) || "function" == typeof (n = c.call(t, "constructor") && t.constructor) && f.call(n) === d)
    },
    isEmptyObject: function (e) {
      var t;
      for (t in e) return !1;
      return !0
    },
    globalEval: function (e, t, n) {
      y(e, {
        nonce: t && t.nonce
      }, n)
    },
    each: function (e, t) {
      var n, r = 0;
      if (C(e))
        for (n = e.length; r < n && !1 !== t.call(e[r], r, e[r]); r++);
      else
        for (r in e)
          if (!1 === t.call(e[r], r, e[r])) break;
      return e
    },
    makeArray: function (e, t) {
      var n = t || [];
      return null != e && (C(Object(e)) ? w.merge(n, "string" == typeof e ? [e] : e) : a.call(n, e)), n
    },
    inArray: function (e, t, n) {
      return null == t ? -1 : s.call(t, e, n)
    },
    merge: function (e, t) {
      for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];
      return e.length = i, e
    },
    grep: function (e, t, n) {
      for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]);
      return r
    },
    map: function (e, t, n) {
      var r, i, a = 0,
        s = [];
      if (C(e))
        for (r = e.length; a < r; a++) null != (i = t(e[a], a, n)) && s.push(i);
      else
        for (a in e) null != (i = t(e[a], a, n)) && s.push(i);
      return o(s)
    },
    guid: 1,
    support: p
  }), "function" == typeof Symbol && (w.fn[Symbol.iterator] = n[Symbol.iterator]), w.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function (e, t) {
    u["[object " + t + "]"] = t.toLowerCase()
  }));
  var T = function (e) {
    var t, n, r, i, o, a, s, u, l, c, f, d, p, h, g, v, m, y, b, x = "sizzle" + 1 * new Date,
      w = e.document,
      C = 0,
      T = 0,
      E = ue(),
      A = ue(),
      N = ue(),
      S = ue(),
      k = function (e, t) {
        return e === t && (f = !0), 0
      },
      D = {}.hasOwnProperty,
      L = [],
      j = L.pop,
      q = L.push,
      O = L.push,
      P = L.slice,
      H = function (e, t) {
        for (var n = 0, r = e.length; n < r; n++)
          if (e[n] === t) return n;
        return -1
      },
      I = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      R = "[\\x20\\t\\r\\n\\f]",
      B = "(?:\\\\[\\da-fA-F]{1,6}" + R + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
      M = "\\[" + R + "*(" + B + ")(?:" + R + "*([*^$|!~]?=)" + R + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + B + "))|)" + R + "*\\]",
      W = ":(" + B + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + M + ")*)|.*)\\)|)",
      F = new RegExp(R + "+", "g"),
      $ = new RegExp("^" + R + "+|((?:^|[^\\\\])(?:\\\\.)*)" + R + "+$", "g"),
      z = new RegExp("^" + R + "*," + R + "*"),
      _ = new RegExp("^" + R + "*([>+~]|" + R + ")" + R + "*"),
      U = new RegExp(R + "|>"),
      V = new RegExp(W),
      X = new RegExp("^" + B + "$"),
      Q = {
        ID: new RegExp("^#(" + B + ")"),
        CLASS: new RegExp("^\\.(" + B + ")"),
        TAG: new RegExp("^(" + B + "|[*])"),
        ATTR: new RegExp("^" + M),
        PSEUDO: new RegExp("^" + W),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + R + "*(even|odd|(([+-]|)(\\d*)n|)" + R + "*(?:([+-]|)" + R + "*(\\d+)|))" + R + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + I + ")$", "i"),
        needsContext: new RegExp("^" + R + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + R + "*((?:-\\d)?\\d*)" + R + "*\\)|)(?=[^-]|$)", "i")
      },
      Y = /HTML$/i,
      G = /^(?:input|select|textarea|button)$/i,
      K = /^h\d$/i,
      J = /^[^{]+\{\s*\[native \w/,
      Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      ee = /[+~]/,
      te = new RegExp("\\\\[\\da-fA-F]{1,6}" + R + "?|\\\\([^\\r\\n\\f])", "g"),
      ne = function (e, t) {
        var n = "0x" + e.slice(1) - 65536;
        return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
      },
      re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
      ie = function (e, t) {
        return t ? "\0" === e ? "" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
      },
      oe = function () {
        d()
      },
      ae = xe((function (e) {
        return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase()
      }), {
        dir: "parentNode",
        next: "legend"
      });
    try {
      O.apply(L = P.call(w.childNodes), w.childNodes), L[w.childNodes.length].nodeType
    } catch (e) {
      O = {
        apply: L.length ? function (e, t) {
          q.apply(e, P.call(t))
        } : function (e, t) {
          for (var n = e.length, r = 0; e[n++] = t[r++];);
          e.length = n - 1
        }
      }
    }

    function se(e, t, r, i) {
      var o, s, l, c, f, h, m, y = t && t.ownerDocument,
        w = t ? t.nodeType : 9;
      if (r = r || [], "string" != typeof e || !e || 1 !== w && 9 !== w && 11 !== w) return r;
      if (!i && (d(t), t = t || p, g)) {
        if (11 !== w && (f = Z.exec(e)))
          if (o = f[1]) {
            if (9 === w) {
              if (!(l = t.getElementById(o))) return r;
              if (l.id === o) return r.push(l), r
            } else if (y && (l = y.getElementById(o)) && b(t, l) && l.id === o) return r.push(l), r
          } else {
            if (f[2]) return O.apply(r, t.getElementsByTagName(e)), r;
            if ((o = f[3]) && n.getElementsByClassName && t.getElementsByClassName) return O.apply(r, t.getElementsByClassName(o)), r
          } if (n.qsa && !S[e + " "] && (!v || !v.test(e)) && (1 !== w || "object" !== t.nodeName.toLowerCase())) {
          if (m = e, y = t, 1 === w && (U.test(e) || _.test(e))) {
            for ((y = ee.test(e) && me(t.parentNode) || t) === t && n.scope || ((c = t.getAttribute("id")) ? c = c.replace(re, ie) : t.setAttribute("id", c = x)), s = (h = a(e)).length; s--;) h[s] = (c ? "#" + c : ":scope") + " " + be(h[s]);
            m = h.join(",")
          }
          try {
            return O.apply(r, y.querySelectorAll(m)), r
          } catch (t) {
            S(e, !0)
          } finally {
            c === x && t.removeAttribute("id")
          }
        }
      }
      return u(e.replace($, "$1"), t, r, i)
    }

    function ue() {
      var e = [];
      return function t(n, i) {
        return e.push(n + " ") > r.cacheLength && delete t[e.shift()], t[n + " "] = i
      }
    }

    function le(e) {
      return e[x] = !0, e
    }

    function ce(e) {
      var t = p.createElement("fieldset");
      try {
        return !!e(t)
      } catch (e) {
        return !1
      } finally {
        t.parentNode && t.parentNode.removeChild(t), t = null
      }
    }

    function fe(e, t) {
      for (var n = e.split("|"), i = n.length; i--;) r.attrHandle[n[i]] = t
    }

    function de(e, t) {
      var n = t && e,
        r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
      if (r) return r;
      if (n)
        for (; n = n.nextSibling;)
          if (n === t) return -1;
      return e ? 1 : -1
    }

    function pe(e) {
      return function (t) {
        return "input" === t.nodeName.toLowerCase() && t.type === e
      }
    }

    function he(e) {
      return function (t) {
        var n = t.nodeName.toLowerCase();
        return ("input" === n || "button" === n) && t.type === e
      }
    }

    function ge(e) {
      return function (t) {
        return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && ae(t) === e : t.disabled === e : "label" in t && t.disabled === e
      }
    }

    function ve(e) {
      return le((function (t) {
        return t = +t, le((function (n, r) {
          for (var i, o = e([], n.length, t), a = o.length; a--;) n[i = o[a]] && (n[i] = !(r[i] = n[i]))
        }))
      }))
    }

    function me(e) {
      return e && void 0 !== e.getElementsByTagName && e
    }
    for (t in n = se.support = {}, o = se.isXML = function (e) {
        var t = e.namespaceURI,
          n = (e.ownerDocument || e).documentElement;
        return !Y.test(t || n && n.nodeName || "HTML")
      }, d = se.setDocument = function (e) {
        var t, i, a = e ? e.ownerDocument || e : w;
        return a != p && 9 === a.nodeType && a.documentElement ? (h = (p = a).documentElement, g = !o(p), w != p && (i = p.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", oe, !1) : i.attachEvent && i.attachEvent("onunload", oe)), n.scope = ce((function (e) {
          return h.appendChild(e).appendChild(p.createElement("div")), void 0 !== e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length
        })), n.attributes = ce((function (e) {
          return e.className = "i", !e.getAttribute("className")
        })), n.getElementsByTagName = ce((function (e) {
          return e.appendChild(p.createComment("")), !e.getElementsByTagName("*").length
        })), n.getElementsByClassName = J.test(p.getElementsByClassName), n.getById = ce((function (e) {
          return h.appendChild(e).id = x, !p.getElementsByName || !p.getElementsByName(x).length
        })), n.getById ? (r.filter.ID = function (e) {
          var t = e.replace(te, ne);
          return function (e) {
            return e.getAttribute("id") === t
          }
        }, r.find.ID = function (e, t) {
          if (void 0 !== t.getElementById && g) {
            var n = t.getElementById(e);
            return n ? [n] : []
          }
        }) : (r.filter.ID = function (e) {
          var t = e.replace(te, ne);
          return function (e) {
            var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
            return n && n.value === t
          }
        }, r.find.ID = function (e, t) {
          if (void 0 !== t.getElementById && g) {
            var n, r, i, o = t.getElementById(e);
            if (o) {
              if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
              for (i = t.getElementsByName(e), r = 0; o = i[r++];)
                if ((n = o.getAttributeNode("id")) && n.value === e) return [o]
            }
            return []
          }
        }), r.find.TAG = n.getElementsByTagName ? function (e, t) {
          return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0
        } : function (e, t) {
          var n, r = [],
            i = 0,
            o = t.getElementsByTagName(e);
          if ("*" === e) {
            for (; n = o[i++];) 1 === n.nodeType && r.push(n);
            return r
          }
          return o
        }, r.find.CLASS = n.getElementsByClassName && function (e, t) {
          if (void 0 !== t.getElementsByClassName && g) return t.getElementsByClassName(e)
        }, m = [], v = [], (n.qsa = J.test(p.querySelectorAll)) && (ce((function (e) {
          var t;
          h.appendChild(e).innerHTML = "<a id='" + x + "'></a><select id='" + x + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + R + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + R + "*(?:value|" + I + ")"), e.querySelectorAll("[id~=" + x + "-]").length || v.push("~="), (t = p.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + R + "*name" + R + "*=" + R + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + x + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]")
        })), ce((function (e) {
          e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
          var t = p.createElement("input");
          t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + R + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), h.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:")
        }))), (n.matchesSelector = J.test(y = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ce((function (e) {
          n.disconnectedMatch = y.call(e, "*"), y.call(e, "[s!='']:x"), m.push("!=", W)
        })), v = v.length && new RegExp(v.join("|")), m = m.length && new RegExp(m.join("|")), t = J.test(h.compareDocumentPosition), b = t || J.test(h.contains) ? function (e, t) {
          var n = 9 === e.nodeType ? e.documentElement : e,
            r = t && t.parentNode;
          return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
        } : function (e, t) {
          if (t)
            for (; t = t.parentNode;)
              if (t === e) return !0;
          return !1
        }, k = t ? function (e, t) {
          if (e === t) return f = !0, 0;
          var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
          return r || (1 & (r = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === r ? e == p || e.ownerDocument == w && b(w, e) ? -1 : t == p || t.ownerDocument == w && b(w, t) ? 1 : c ? H(c, e) - H(c, t) : 0 : 4 & r ? -1 : 1)
        } : function (e, t) {
          if (e === t) return f = !0, 0;
          var n, r = 0,
            i = e.parentNode,
            o = t.parentNode,
            a = [e],
            s = [t];
          if (!i || !o) return e == p ? -1 : t == p ? 1 : i ? -1 : o ? 1 : c ? H(c, e) - H(c, t) : 0;
          if (i === o) return de(e, t);
          for (n = e; n = n.parentNode;) a.unshift(n);
          for (n = t; n = n.parentNode;) s.unshift(n);
          for (; a[r] === s[r];) r++;
          return r ? de(a[r], s[r]) : a[r] == w ? -1 : s[r] == w ? 1 : 0
        }, p) : p
      }, se.matches = function (e, t) {
        return se(e, null, null, t)
      }, se.matchesSelector = function (e, t) {
        if (d(e), n.matchesSelector && g && !S[t + " "] && (!m || !m.test(t)) && (!v || !v.test(t))) try {
          var r = y.call(e, t);
          if (r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r
        } catch (e) {
          S(t, !0)
        }
        return se(t, p, null, [e]).length > 0
      }, se.contains = function (e, t) {
        return (e.ownerDocument || e) != p && d(e), b(e, t)
      }, se.attr = function (e, t) {
        (e.ownerDocument || e) != p && d(e);
        var i = r.attrHandle[t.toLowerCase()],
          o = i && D.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !g) : void 0;
        return void 0 !== o ? o : n.attributes || !g ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null
      }, se.escape = function (e) {
        return (e + "").replace(re, ie)
      }, se.error = function (e) {
        throw new Error("Syntax error, unrecognized expression: " + e)
      }, se.uniqueSort = function (e) {
        var t, r = [],
          i = 0,
          o = 0;
        if (f = !n.detectDuplicates, c = !n.sortStable && e.slice(0), e.sort(k), f) {
          for (; t = e[o++];) t === e[o] && (i = r.push(o));
          for (; i--;) e.splice(r[i], 1)
        }
        return c = null, e
      }, i = se.getText = function (e) {
        var t, n = "",
          r = 0,
          o = e.nodeType;
        if (o) {
          if (1 === o || 9 === o || 11 === o) {
            if ("string" == typeof e.textContent) return e.textContent;
            for (e = e.firstChild; e; e = e.nextSibling) n += i(e)
          } else if (3 === o || 4 === o) return e.nodeValue
        } else
          for (; t = e[r++];) n += i(t);
        return n
      }, (r = se.selectors = {
        cacheLength: 50,
        createPseudo: le,
        match: Q,
        attrHandle: {},
        find: {},
        relative: {
          ">": {
            dir: "parentNode",
            first: !0
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: !0
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          ATTR: function (e) {
            return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
          },
          CHILD: function (e) {
            return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e
          },
          PSEUDO: function (e) {
            var t, n = !e[6] && e[2];
            return Q.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && V.test(n) && (t = a(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
          }
        },
        filter: {
          TAG: function (e) {
            var t = e.replace(te, ne).toLowerCase();
            return "*" === e ? function () {
              return !0
            } : function (e) {
              return e.nodeName && e.nodeName.toLowerCase() === t
            }
          },
          CLASS: function (e) {
            var t = E[e + " "];
            return t || (t = new RegExp("(^|" + R + ")" + e + "(" + R + "|$)")) && E(e, (function (e) {
              return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
            }))
          },
          ATTR: function (e, t, n) {
            return function (r) {
              var i = se.attr(r, e);
              return null == i ? "!=" === t : !t || (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i.replace(F, " ") + " ").indexOf(n) > -1 : "|=" === t && (i === n || i.slice(0, n.length + 1) === n + "-"))
            }
          },
          CHILD: function (e, t, n, r, i) {
            var o = "nth" !== e.slice(0, 3),
              a = "last" !== e.slice(-4),
              s = "of-type" === t;
            return 1 === r && 0 === i ? function (e) {
              return !!e.parentNode
            } : function (t, n, u) {
              var l, c, f, d, p, h, g = o !== a ? "nextSibling" : "previousSibling",
                v = t.parentNode,
                m = s && t.nodeName.toLowerCase(),
                y = !u && !s,
                b = !1;
              if (v) {
                if (o) {
                  for (; g;) {
                    for (d = t; d = d[g];)
                      if (s ? d.nodeName.toLowerCase() === m : 1 === d.nodeType) return !1;
                    h = g = "only" === e && !h && "nextSibling"
                  }
                  return !0
                }
                if (h = [a ? v.firstChild : v.lastChild], a && y) {
                  for (b = (p = (l = (c = (f = (d = v)[x] || (d[x] = {}))[d.uniqueID] || (f[d.uniqueID] = {}))[e] || [])[0] === C && l[1]) && l[2], d = p && v.childNodes[p]; d = ++p && d && d[g] || (b = p = 0) || h.pop();)
                    if (1 === d.nodeType && ++b && d === t) {
                      c[e] = [C, p, b];
                      break
                    }
                } else if (y && (b = p = (l = (c = (f = (d = t)[x] || (d[x] = {}))[d.uniqueID] || (f[d.uniqueID] = {}))[e] || [])[0] === C && l[1]), !1 === b)
                  for (;
                    (d = ++p && d && d[g] || (b = p = 0) || h.pop()) && ((s ? d.nodeName.toLowerCase() !== m : 1 !== d.nodeType) || !++b || (y && ((c = (f = d[x] || (d[x] = {}))[d.uniqueID] || (f[d.uniqueID] = {}))[e] = [C, b]), d !== t)););
                return (b -= i) === r || b % r == 0 && b / r >= 0
              }
            }
          },
          PSEUDO: function (e, t) {
            var n, i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
            return i[x] ? i(t) : i.length > 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? le((function (e, n) {
              for (var r, o = i(e, t), a = o.length; a--;) e[r = H(e, o[a])] = !(n[r] = o[a])
            })) : function (e) {
              return i(e, 0, n)
            }) : i
          }
        },
        pseudos: {
          not: le((function (e) {
            var t = [],
              n = [],
              r = s(e.replace($, "$1"));
            return r[x] ? le((function (e, t, n, i) {
              for (var o, a = r(e, null, i, []), s = e.length; s--;)(o = a[s]) && (e[s] = !(t[s] = o))
            })) : function (e, i, o) {
              return t[0] = e, r(t, null, o, n), t[0] = null, !n.pop()
            }
          })),
          has: le((function (e) {
            return function (t) {
              return se(e, t).length > 0
            }
          })),
          contains: le((function (e) {
            return e = e.replace(te, ne),
              function (t) {
                return (t.textContent || i(t)).indexOf(e) > -1
              }
          })),
          lang: le((function (e) {
            return X.test(e || "") || se.error("unsupported lang: " + e), e = e.replace(te, ne).toLowerCase(),
              function (t) {
                var n;
                do {
                  if (n = g ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-")
                } while ((t = t.parentNode) && 1 === t.nodeType);
                return !1
              }
          })),
          target: function (t) {
            var n = e.location && e.location.hash;
            return n && n.slice(1) === t.id
          },
          root: function (e) {
            return e === h
          },
          focus: function (e) {
            return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
          },
          enabled: ge(!1),
          disabled: ge(!0),
          checked: function (e) {
            var t = e.nodeName.toLowerCase();
            return "input" === t && !!e.checked || "option" === t && !!e.selected
          },
          selected: function (e) {
            return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
          },
          empty: function (e) {
            for (e = e.firstChild; e; e = e.nextSibling)
              if (e.nodeType < 6) return !1;
            return !0
          },
          parent: function (e) {
            return !r.pseudos.empty(e)
          },
          header: function (e) {
            return K.test(e.nodeName)
          },
          input: function (e) {
            return G.test(e.nodeName)
          },
          button: function (e) {
            var t = e.nodeName.toLowerCase();
            return "input" === t && "button" === e.type || "button" === t
          },
          text: function (e) {
            var t;
            return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
          },
          first: ve((function () {
            return [0]
          })),
          last: ve((function (e, t) {
            return [t - 1]
          })),
          eq: ve((function (e, t, n) {
            return [n < 0 ? n + t : n]
          })),
          even: ve((function (e, t) {
            for (var n = 0; n < t; n += 2) e.push(n);
            return e
          })),
          odd: ve((function (e, t) {
            for (var n = 1; n < t; n += 2) e.push(n);
            return e
          })),
          lt: ve((function (e, t, n) {
            for (var r = n < 0 ? n + t : n > t ? t : n; --r >= 0;) e.push(r);
            return e
          })),
          gt: ve((function (e, t, n) {
            for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);
            return e
          }))
        }
      }).pseudos.nth = r.pseudos.eq, {
        radio: !0,
        checkbox: !0,
        file: !0,
        password: !0,
        image: !0
      }) r.pseudos[t] = pe(t);
    for (t in {
        submit: !0,
        reset: !0
      }) r.pseudos[t] = he(t);

    function ye() {}

    function be(e) {
      for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
      return r
    }

    function xe(e, t, n) {
      var r = t.dir,
        i = t.next,
        o = i || r,
        a = n && "parentNode" === o,
        s = T++;
      return t.first ? function (t, n, i) {
        for (; t = t[r];)
          if (1 === t.nodeType || a) return e(t, n, i);
        return !1
      } : function (t, n, u) {
        var l, c, f, d = [C, s];
        if (u) {
          for (; t = t[r];)
            if ((1 === t.nodeType || a) && e(t, n, u)) return !0
        } else
          for (; t = t[r];)
            if (1 === t.nodeType || a)
              if (c = (f = t[x] || (t[x] = {}))[t.uniqueID] || (f[t.uniqueID] = {}), i && i === t.nodeName.toLowerCase()) t = t[r] || t;
              else {
                if ((l = c[o]) && l[0] === C && l[1] === s) return d[2] = l[2];
                if (c[o] = d, d[2] = e(t, n, u)) return !0
              } return !1
      }
    }

    function we(e) {
      return e.length > 1 ? function (t, n, r) {
        for (var i = e.length; i--;)
          if (!e[i](t, n, r)) return !1;
        return !0
      } : e[0]
    }

    function Ce(e, t, n, r, i) {
      for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));
      return a
    }

    function Te(e, t, n, r, i, o) {
      return r && !r[x] && (r = Te(r)), i && !i[x] && (i = Te(i, o)), le((function (o, a, s, u) {
        var l, c, f, d = [],
          p = [],
          h = a.length,
          g = o || function (e, t, n) {
            for (var r = 0, i = t.length; r < i; r++) se(e, t[r], n);
            return n
          }(t || "*", s.nodeType ? [s] : s, []),
          v = !e || !o && t ? g : Ce(g, d, e, s, u),
          m = n ? i || (o ? e : h || r) ? [] : a : v;
        if (n && n(v, m, s, u), r)
          for (l = Ce(m, p), r(l, [], s, u), c = l.length; c--;)(f = l[c]) && (m[p[c]] = !(v[p[c]] = f));
        if (o) {
          if (i || e) {
            if (i) {
              for (l = [], c = m.length; c--;)(f = m[c]) && l.push(v[c] = f);
              i(null, m = [], l, u)
            }
            for (c = m.length; c--;)(f = m[c]) && (l = i ? H(o, f) : d[c]) > -1 && (o[l] = !(a[l] = f))
          }
        } else m = Ce(m === a ? m.splice(h, m.length) : m), i ? i(null, a, m, u) : O.apply(a, m)
      }))
    }

    function Ee(e) {
      for (var t, n, i, o = e.length, a = r.relative[e[0].type], s = a || r.relative[" "], u = a ? 1 : 0, c = xe((function (e) {
          return e === t
        }), s, !0), f = xe((function (e) {
          return H(t, e) > -1
        }), s, !0), d = [function (e, n, r) {
          var i = !a && (r || n !== l) || ((t = n).nodeType ? c(e, n, r) : f(e, n, r));
          return t = null, i
        }]; u < o; u++)
        if (n = r.relative[e[u].type]) d = [xe(we(d), n)];
        else {
          if ((n = r.filter[e[u].type].apply(null, e[u].matches))[x]) {
            for (i = ++u; i < o && !r.relative[e[i].type]; i++);
            return Te(u > 1 && we(d), u > 1 && be(e.slice(0, u - 1).concat({
              value: " " === e[u - 2].type ? "*" : ""
            })).replace($, "$1"), n, u < i && Ee(e.slice(u, i)), i < o && Ee(e = e.slice(i)), i < o && be(e))
          }
          d.push(n)
        } return we(d)
    }
    return ye.prototype = r.filters = r.pseudos, r.setFilters = new ye, a = se.tokenize = function (e, t) {
      var n, i, o, a, s, u, l, c = A[e + " "];
      if (c) return t ? 0 : c.slice(0);
      for (s = e, u = [], l = r.preFilter; s;) {
        for (a in n && !(i = z.exec(s)) || (i && (s = s.slice(i[0].length) || s), u.push(o = [])), n = !1, (i = _.exec(s)) && (n = i.shift(), o.push({
            value: n,
            type: i[0].replace($, " ")
          }), s = s.slice(n.length)), r.filter) !(i = Q[a].exec(s)) || l[a] && !(i = l[a](i)) || (n = i.shift(), o.push({
          value: n,
          type: a,
          matches: i
        }), s = s.slice(n.length));
        if (!n) break
      }
      return t ? s.length : s ? se.error(e) : A(e, u).slice(0)
    }, s = se.compile = function (e, t) {
      var n, i = [],
        o = [],
        s = N[e + " "];
      if (!s) {
        for (t || (t = a(e)), n = t.length; n--;)(s = Ee(t[n]))[x] ? i.push(s) : o.push(s);
        (s = N(e, function (e, t) {
          var n = t.length > 0,
            i = e.length > 0,
            o = function (o, a, s, u, c) {
              var f, h, v, m = 0,
                y = "0",
                b = o && [],
                x = [],
                w = l,
                T = o || i && r.find.TAG("*", c),
                E = C += null == w ? 1 : Math.random() || .1,
                A = T.length;
              for (c && (l = a == p || a || c); y !== A && null != (f = T[y]); y++) {
                if (i && f) {
                  for (h = 0, a || f.ownerDocument == p || (d(f), s = !g); v = e[h++];)
                    if (v(f, a || p, s)) {
                      u.push(f);
                      break
                    } c && (C = E)
                }
                n && ((f = !v && f) && m--, o && b.push(f))
              }
              if (m += y, n && y !== m) {
                for (h = 0; v = t[h++];) v(b, x, a, s);
                if (o) {
                  if (m > 0)
                    for (; y--;) b[y] || x[y] || (x[y] = j.call(u));
                  x = Ce(x)
                }
                O.apply(u, x), c && !o && x.length > 0 && m + t.length > 1 && se.uniqueSort(u)
              }
              return c && (C = E, l = w), b
            };
          return n ? le(o) : o
        }(o, i))).selector = e
      }
      return s
    }, u = se.select = function (e, t, n, i) {
      var o, u, l, c, f, d = "function" == typeof e && e,
        p = !i && a(e = d.selector || e);
      if (n = n || [], 1 === p.length) {
        if ((u = p[0] = p[0].slice(0)).length > 2 && "ID" === (l = u[0]).type && 9 === t.nodeType && g && r.relative[u[1].type]) {
          if (!(t = (r.find.ID(l.matches[0].replace(te, ne), t) || [])[0])) return n;
          d && (t = t.parentNode), e = e.slice(u.shift().value.length)
        }
        for (o = Q.needsContext.test(e) ? 0 : u.length; o-- && (l = u[o], !r.relative[c = l.type]);)
          if ((f = r.find[c]) && (i = f(l.matches[0].replace(te, ne), ee.test(u[0].type) && me(t.parentNode) || t))) {
            if (u.splice(o, 1), !(e = i.length && be(u))) return O.apply(n, i), n;
            break
          }
      }
      return (d || s(e, p))(i, t, !g, n, !t || ee.test(e) && me(t.parentNode) || t), n
    }, n.sortStable = x.split("").sort(k).join("") === x, n.detectDuplicates = !!f, d(), n.sortDetached = ce((function (e) {
      return 1 & e.compareDocumentPosition(p.createElement("fieldset"))
    })), ce((function (e) {
      return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
    })) || fe("type|href|height|width", (function (e, t, n) {
      if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
    })), n.attributes && ce((function (e) {
      return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
    })) || fe("value", (function (e, t, n) {
      if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue
    })), ce((function (e) {
      return null == e.getAttribute("disabled")
    })) || fe(I, (function (e, t, n) {
      var r;
      if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
    })), se
  }(e);
  w.find = T, w.expr = T.selectors, w.expr[":"] = w.expr.pseudos, w.uniqueSort = w.unique = T.uniqueSort, w.text = T.getText, w.isXMLDoc = T.isXML, w.contains = T.contains, w.escapeSelector = T.escape;
  var E = function (e, t, n) {
      for (var r = [], i = void 0 !== n;
        (e = e[t]) && 9 !== e.nodeType;)
        if (1 === e.nodeType) {
          if (i && w(e).is(n)) break;
          r.push(e)
        } return r
    },
    A = function (e, t) {
      for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
      return n
    },
    N = w.expr.match.needsContext;

  function S(e, t) {
    return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
  }
  var k = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

  function D(e, t, n) {
    return h(t) ? w.grep(e, (function (e, r) {
      return !!t.call(e, r, e) !== n
    })) : t.nodeType ? w.grep(e, (function (e) {
      return e === t !== n
    })) : "string" != typeof t ? w.grep(e, (function (e) {
      return s.call(t, e) > -1 !== n
    })) : w.filter(t, e, n)
  }
  w.filter = function (e, t, n) {
    var r = t[0];
    return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? w.find.matchesSelector(r, e) ? [r] : [] : w.find.matches(e, w.grep(t, (function (e) {
      return 1 === e.nodeType
    })))
  }, w.fn.extend({
    find: function (e) {
      var t, n, r = this.length,
        i = this;
      if ("string" != typeof e) return this.pushStack(w(e).filter((function () {
        for (t = 0; t < r; t++)
          if (w.contains(i[t], this)) return !0
      })));
      for (n = this.pushStack([]), t = 0; t < r; t++) w.find(e, i[t], n);
      return r > 1 ? w.uniqueSort(n) : n
    },
    filter: function (e) {
      return this.pushStack(D(this, e || [], !1))
    },
    not: function (e) {
      return this.pushStack(D(this, e || [], !0))
    },
    is: function (e) {
      return !!D(this, "string" == typeof e && N.test(e) ? w(e) : e || [], !1).length
    }
  });
  var L, j = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
  (w.fn.init = function (e, t, n) {
    var r, i;
    if (!e) return this;
    if (n = n || L, "string" == typeof e) {
      if (!(r = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : j.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
      if (r[1]) {
        if (t = t instanceof w ? t[0] : t, w.merge(this, w.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : v, !0)), k.test(r[1]) && w.isPlainObject(t))
          for (r in t) h(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
        return this
      }
      return (i = v.getElementById(r[2])) && (this[0] = i, this.length = 1), this
    }
    return e.nodeType ? (this[0] = e, this.length = 1, this) : h(e) ? void 0 !== n.ready ? n.ready(e) : e(w) : w.makeArray(e, this)
  }).prototype = w.fn, L = w(v);
  var q = /^(?:parents|prev(?:Until|All))/,
    O = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };

  function P(e, t) {
    for (;
      (e = e[t]) && 1 !== e.nodeType;);
    return e
  }
  w.fn.extend({
    has: function (e) {
      var t = w(e, this),
        n = t.length;
      return this.filter((function () {
        for (var e = 0; e < n; e++)
          if (w.contains(this, t[e])) return !0
      }))
    },
    closest: function (e, t) {
      var n, r = 0,
        i = this.length,
        o = [],
        a = "string" != typeof e && w(e);
      if (!N.test(e))
        for (; r < i; r++)
          for (n = this[r]; n && n !== t; n = n.parentNode)
            if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && w.find.matchesSelector(n, e))) {
              o.push(n);
              break
            } return this.pushStack(o.length > 1 ? w.uniqueSort(o) : o)
    },
    index: function (e) {
      return e ? "string" == typeof e ? s.call(w(e), this[0]) : s.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
    },
    add: function (e, t) {
      return this.pushStack(w.uniqueSort(w.merge(this.get(), w(e, t))))
    },
    addBack: function (e) {
      return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
    }
  }), w.each({
    parent: function (e) {
      var t = e.parentNode;
      return t && 11 !== t.nodeType ? t : null
    },
    parents: function (e) {
      return E(e, "parentNode")
    },
    parentsUntil: function (e, t, n) {
      return E(e, "parentNode", n)
    },
    next: function (e) {
      return P(e, "nextSibling")
    },
    prev: function (e) {
      return P(e, "previousSibling")
    },
    nextAll: function (e) {
      return E(e, "nextSibling")
    },
    prevAll: function (e) {
      return E(e, "previousSibling")
    },
    nextUntil: function (e, t, n) {
      return E(e, "nextSibling", n)
    },
    prevUntil: function (e, t, n) {
      return E(e, "previousSibling", n)
    },
    siblings: function (e) {
      return A((e.parentNode || {}).firstChild, e)
    },
    children: function (e) {
      return A(e.firstChild)
    },
    contents: function (e) {
      return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (S(e, "template") && (e = e.content || e), w.merge([], e.childNodes))
    }
  }, (function (e, t) {
    w.fn[e] = function (n, r) {
      var i = w.map(this, t, n);
      return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = w.filter(r, i)), this.length > 1 && (O[e] || w.uniqueSort(i), q.test(e) && i.reverse()), this.pushStack(i)
    }
  }));
  var H = /[^\x20\t\r\n\f]+/g;

  function I(e) {
    return e
  }

  function R(e) {
    throw e
  }

  function B(e, t, n, r) {
    var i;
    try {
      e && h(i = e.promise) ? i.call(e).done(t).fail(n) : e && h(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r))
    } catch (e) {
      n.apply(void 0, [e])
    }
  }
  w.Callbacks = function (e) {
    e = "string" == typeof e ? function (e) {
      var t = {};
      return w.each(e.match(H) || [], (function (e, n) {
        t[n] = !0
      })), t
    }(e) : w.extend({}, e);
    var t, n, r, i, o = [],
      a = [],
      s = -1,
      u = function () {
        for (i = i || e.once, r = t = !0; a.length; s = -1)
          for (n = a.shift(); ++s < o.length;) !1 === o[s].apply(n[0], n[1]) && e.stopOnFalse && (s = o.length, n = !1);
        e.memory || (n = !1), t = !1, i && (o = n ? [] : "")
      },
      l = {
        add: function () {
          return o && (n && !t && (s = o.length - 1, a.push(n)), function t(n) {
            w.each(n, (function (n, r) {
              h(r) ? e.unique && l.has(r) || o.push(r) : r && r.length && "string" !== b(r) && t(r)
            }))
          }(arguments), n && !t && u()), this
        },
        remove: function () {
          return w.each(arguments, (function (e, t) {
            for (var n;
              (n = w.inArray(t, o, n)) > -1;) o.splice(n, 1), n <= s && s--
          })), this
        },
        has: function (e) {
          return e ? w.inArray(e, o) > -1 : o.length > 0
        },
        empty: function () {
          return o && (o = []), this
        },
        disable: function () {
          return i = a = [], o = n = "", this
        },
        disabled: function () {
          return !o
        },
        lock: function () {
          return i = a = [], n || t || (o = n = ""), this
        },
        locked: function () {
          return !!i
        },
        fireWith: function (e, n) {
          return i || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || u()), this
        },
        fire: function () {
          return l.fireWith(this, arguments), this
        },
        fired: function () {
          return !!r
        }
      };
    return l
  }, w.extend({
    Deferred: function (t) {
      var n = [
          ["notify", "progress", w.Callbacks("memory"), w.Callbacks("memory"), 2],
          ["resolve", "done", w.Callbacks("once memory"), w.Callbacks("once memory"), 0, "resolved"],
          ["reject", "fail", w.Callbacks("once memory"), w.Callbacks("once memory"), 1, "rejected"]
        ],
        r = "pending",
        i = {
          state: function () {
            return r
          },
          always: function () {
            return o.done(arguments).fail(arguments), this
          },
          catch: function (e) {
            return i.then(null, e)
          },
          pipe: function () {
            var e = arguments;
            return w.Deferred((function (t) {
              w.each(n, (function (n, r) {
                var i = h(e[r[4]]) && e[r[4]];
                o[r[1]]((function () {
                  var e = i && i.apply(this, arguments);
                  e && h(e.promise) ? e.promise().progress(t.notify).done(t.resolve).fail(t.reject) : t[r[0] + "With"](this, i ? [e] : arguments)
                }))
              })), e = null
            })).promise()
          },
          then: function (t, r, i) {
            var o = 0;

            function a(t, n, r, i) {
              return function () {
                var s = this,
                  u = arguments,
                  l = function () {
                    var e, l;
                    if (!(t < o)) {
                      if ((e = r.apply(s, u)) === n.promise()) throw new TypeError("Thenable self-resolution");
                      l = e && ("object" == typeof e || "function" == typeof e) && e.then, h(l) ? i ? l.call(e, a(o, n, I, i), a(o, n, R, i)) : (o++, l.call(e, a(o, n, I, i), a(o, n, R, i), a(o, n, I, n.notifyWith))) : (r !== I && (s = void 0, u = [e]), (i || n.resolveWith)(s, u))
                    }
                  },
                  c = i ? l : function () {
                    try {
                      l()
                    } catch (e) {
                      w.Deferred.exceptionHook && w.Deferred.exceptionHook(e, c.stackTrace), t + 1 >= o && (r !== R && (s = void 0, u = [e]), n.rejectWith(s, u))
                    }
                  };
                t ? c() : (w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook()), e.setTimeout(c))
              }
            }
            return w.Deferred((function (e) {
              n[0][3].add(a(0, e, h(i) ? i : I, e.notifyWith)), n[1][3].add(a(0, e, h(t) ? t : I)), n[2][3].add(a(0, e, h(r) ? r : R))
            })).promise()
          },
          promise: function (e) {
            return null != e ? w.extend(e, i) : i
          }
        },
        o = {};
      return w.each(n, (function (e, t) {
        var a = t[2],
          s = t[5];
        i[t[1]] = a.add, s && a.add((function () {
          r = s
        }), n[3 - e][2].disable, n[3 - e][3].disable, n[0][2].lock, n[0][3].lock), a.add(t[3].fire), o[t[0]] = function () {
          return o[t[0] + "With"](this === o ? void 0 : this, arguments), this
        }, o[t[0] + "With"] = a.fireWith
      })), i.promise(o), t && t.call(o, o), o
    },
    when: function (e) {
      var t = arguments.length,
        n = t,
        r = Array(n),
        o = i.call(arguments),
        a = w.Deferred(),
        s = function (e) {
          return function (n) {
            r[e] = this, o[e] = arguments.length > 1 ? i.call(arguments) : n, --t || a.resolveWith(r, o)
          }
        };
      if (t <= 1 && (B(e, a.done(s(n)).resolve, a.reject, !t), "pending" === a.state() || h(o[n] && o[n].then))) return a.then();
      for (; n--;) B(o[n], s(n), a.reject);
      return a.promise()
    }
  });
  var M = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  w.Deferred.exceptionHook = function (t, n) {
    e.console && e.console.warn && t && M.test(t.name) && e.console.warn("jQuery.Deferred exception: " + t.message, t.stack, n)
  }, w.readyException = function (t) {
    e.setTimeout((function () {
      throw t
    }))
  };
  var W = w.Deferred();

  function F() {
    v.removeEventListener("DOMContentLoaded", F), e.removeEventListener("load", F), w.ready()
  }
  w.fn.ready = function (e) {
    return W.then(e).catch((function (e) {
      w.readyException(e)
    })), this
  }, w.extend({
    isReady: !1,
    readyWait: 1,
    ready: function (e) {
      (!0 === e ? --w.readyWait : w.isReady) || (w.isReady = !0, !0 !== e && --w.readyWait > 0 || W.resolveWith(v, [w]))
    }
  }), w.ready.then = W.then, "complete" === v.readyState || "loading" !== v.readyState && !v.documentElement.doScroll ? e.setTimeout(w.ready) : (v.addEventListener("DOMContentLoaded", F), e.addEventListener("load", F));
  var $ = function (e, t, n, r, i, o, a) {
      var s = 0,
        u = e.length,
        l = null == n;
      if ("object" === b(n))
        for (s in i = !0, n) $(e, t, s, n[s], !0, o, a);
      else if (void 0 !== r && (i = !0, h(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) {
          return l.call(w(e), n)
        })), t))
        for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
      return i ? e : l ? t.call(e) : u ? t(e[0], n) : o
    },
    z = /^-ms-/,
    _ = /-([a-z])/g;

  function U(e, t) {
    return t.toUpperCase()
  }

  function V(e) {
    return e.replace(z, "ms-").replace(_, U)
  }
  var X = function (e) {
    return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
  };

  function Q() {
    this.expando = w.expando + Q.uid++
  }
  Q.uid = 1, Q.prototype = {
    cache: function (e) {
      var t = e[this.expando];
      return t || (t = {}, X(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
        value: t,
        configurable: !0
      }))), t
    },
    set: function (e, t, n) {
      var r, i = this.cache(e);
      if ("string" == typeof t) i[V(t)] = n;
      else
        for (r in t) i[V(r)] = t[r];
      return i
    },
    get: function (e, t) {
      return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][V(t)]
    },
    access: function (e, t, n) {
      return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
    },
    remove: function (e, t) {
      var n, r = e[this.expando];
      if (void 0 !== r) {
        if (void 0 !== t) {
          n = (t = Array.isArray(t) ? t.map(V) : (t = V(t)) in r ? [t] : t.match(H) || []).length;
          for (; n--;) delete r[t[n]]
        }(void 0 === t || w.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
      }
    },
    hasData: function (e) {
      var t = e[this.expando];
      return void 0 !== t && !w.isEmptyObject(t)
    }
  };
  var Y = new Q,
    G = new Q,
    K = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    J = /[A-Z]/g;

  function Z(e, t, n) {
    var r;
    if (void 0 === n && 1 === e.nodeType)
      if (r = "data-" + t.replace(J, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) {
        try {
          n = function (e) {
            return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : K.test(e) ? JSON.parse(e) : e)
          }(n)
        } catch (e) {}
        G.set(e, t, n)
      } else n = void 0;
    return n
  }
  w.extend({
    hasData: function (e) {
      return G.hasData(e) || Y.hasData(e)
    },
    data: function (e, t, n) {
      return G.access(e, t, n)
    },
    removeData: function (e, t) {
      G.remove(e, t)
    },
    _data: function (e, t, n) {
      return Y.access(e, t, n)
    },
    _removeData: function (e, t) {
      Y.remove(e, t)
    }
  }), w.fn.extend({
    data: function (e, t) {
      var n, r, i, o = this[0],
        a = o && o.attributes;
      if (void 0 === e) {
        if (this.length && (i = G.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) {
          for (n = a.length; n--;) a[n] && 0 === (r = a[n].name).indexOf("data-") && (r = V(r.slice(5)), Z(o, r, i[r]));
          Y.set(o, "hasDataAttrs", !0)
        }
        return i
      }
      return "object" == typeof e ? this.each((function () {
        G.set(this, e)
      })) : $(this, (function (t) {
        var n;
        if (o && void 0 === t) return void 0 !== (n = G.get(o, e)) || void 0 !== (n = Z(o, e)) ? n : void 0;
        this.each((function () {
          G.set(this, e, t)
        }))
      }), null, t, arguments.length > 1, null, !0)
    },
    removeData: function (e) {
      return this.each((function () {
        G.remove(this, e)
      }))
    }
  }), w.extend({
    queue: function (e, t, n) {
      var r;
      if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, w.makeArray(n)) : r.push(n)), r || []
    },
    dequeue: function (e, t) {
      t = t || "fx";
      var n = w.queue(e, t),
        r = n.length,
        i = n.shift(),
        o = w._queueHooks(e, t);
      "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, (function () {
        w.dequeue(e, t)
      }), o)), !r && o && o.empty.fire()
    },
    _queueHooks: function (e, t) {
      var n = t + "queueHooks";
      return Y.get(e, n) || Y.access(e, n, {
        empty: w.Callbacks("once memory").add((function () {
          Y.remove(e, [t + "queue", n])
        }))
      })
    }
  }), w.fn.extend({
    queue: function (e, t) {
      var n = 2;
      return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? w.queue(this[0], e) : void 0 === t ? this : this.each((function () {
        var n = w.queue(this, e, t);
        w._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && w.dequeue(this, e)
      }))
    },
    dequeue: function (e) {
      return this.each((function () {
        w.dequeue(this, e)
      }))
    },
    clearQueue: function (e) {
      return this.queue(e || "fx", [])
    },
    promise: function (e, t) {
      var n, r = 1,
        i = w.Deferred(),
        o = this,
        a = this.length,
        s = function () {
          --r || i.resolveWith(o, [o])
        };
      for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;)(n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
      return s(), i.promise(t)
    }
  });
  var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"),
    ne = ["Top", "Right", "Bottom", "Left"],
    re = v.documentElement,
    ie = function (e) {
      return w.contains(e.ownerDocument, e)
    },
    oe = {
      composed: !0
    };
  re.getRootNode && (ie = function (e) {
    return w.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument
  });
  var ae = function (e, t) {
    return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === w.css(e, "display")
  };
  var se = {};

  function ue(e) {
    var t, n = e.ownerDocument,
      r = e.nodeName,
      i = se[r];
    return i || (t = n.body.appendChild(n.createElement(r)), i = w.css(t, "display"), t.parentNode.removeChild(t), "none" === i && (i = "block"), se[r] = i, i)
  }

  function le(e, t) {
    for (var n, r, i = [], o = 0, a = e.length; o < a; o++)(r = e[o]).style && (n = r.style.display, t ? ("none" === n && (i[o] = Y.get(r, "display") || null, i[o] || (r.style.display = "")), "" === r.style.display && ae(r) && (i[o] = ue(r))) : "none" !== n && (i[o] = "none", Y.set(r, "display", n)));
    for (o = 0; o < a; o++) null != i[o] && (e[o].style.display = i[o]);
    return e
  }
  w.fn.extend({
    show: function () {
      return le(this, !0)
    },
    hide: function () {
      return le(this)
    },
    toggle: function (e) {
      return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each((function () {
        ae(this) ? w(this).show() : w(this).hide()
      }))
    }
  });
  var ce, fe, de = /^(?:checkbox|radio)$/i,
    pe = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
    he = /^$|^module$|\/(?:java|ecma)script/i;
  ce = v.createDocumentFragment().appendChild(v.createElement("div")), (fe = v.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), p.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", p.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", p.option = !!ce.lastChild;
  var ge = {
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };

  function ve(e, t) {
    var n;
    return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && S(e, t) ? w.merge([e], n) : n
  }

  function me(e, t) {
    for (var n = 0, r = e.length; n < r; n++) Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval"))
  }
  ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, p.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]);
  var ye = /<|&#?\w+;/;

  function be(e, t, n, r, i) {
    for (var o, a, s, u, l, c, f = t.createDocumentFragment(), d = [], p = 0, h = e.length; p < h; p++)
      if ((o = e[p]) || 0 === o)
        if ("object" === b(o)) w.merge(d, o.nodeType ? [o] : o);
        else if (ye.test(o)) {
      for (a = a || f.appendChild(t.createElement("div")), s = (pe.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + w.htmlPrefilter(o) + u[2], c = u[0]; c--;) a = a.lastChild;
      w.merge(d, a.childNodes), (a = f.firstChild).textContent = ""
    } else d.push(t.createTextNode(o));
    for (f.textContent = "", p = 0; o = d[p++];)
      if (r && w.inArray(o, r) > -1) i && i.push(o);
      else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && me(a), n)
      for (c = 0; o = a[c++];) he.test(o.type || "") && n.push(o);
    return f
  }
  var xe = /^key/,
    we = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
    Ce = /^([^.]*)(?:\.(.+)|)/;

  function Te() {
    return !0
  }

  function Ee() {
    return !1
  }

  function Ae(e, t) {
    return e === function () {
      try {
        return v.activeElement
      } catch (e) {}
    }() == ("focus" === t)
  }

  function Ne(e, t, n, r, i, o) {
    var a, s;
    if ("object" == typeof t) {
      for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ne(e, s, n, r, t[s], o);
      return e
    }
    if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Ee;
    else if (!i) return e;
    return 1 === o && (a = i, (i = function (e) {
      return w().off(e), a.apply(this, arguments)
    }).guid = a.guid || (a.guid = w.guid++)), e.each((function () {
      w.event.add(this, t, i, r, n)
    }))
  }

  function Se(e, t, n) {
    n ? (Y.set(e, t, !1), w.event.add(e, t, {
      namespace: !1,
      handler: function (e) {
        var r, o, a = Y.get(this, t);
        if (1 & e.isTrigger && this[t]) {
          if (a.length)(w.event.special[t] || {}).delegateType && e.stopPropagation();
          else if (a = i.call(arguments), Y.set(this, t, a), r = n(this, t), this[t](), a !== (o = Y.get(this, t)) || r ? Y.set(this, t, !1) : o = {}, a !== o) return e.stopImmediatePropagation(), e.preventDefault(), o.value
        } else a.length && (Y.set(this, t, {
          value: w.event.trigger(w.extend(a[0], w.Event.prototype), a.slice(1), this)
        }), e.stopImmediatePropagation())
      }
    })) : void 0 === Y.get(e, t) && w.event.add(e, t, Te)
  }
  w.event = {
    global: {},
    add: function (e, t, n, r, i) {
      var o, a, s, u, l, c, f, d, p, h, g, v = Y.get(e);
      if (X(e))
        for (n.handler && (n = (o = n).handler, i = o.selector), i && w.find.matchesSelector(re, i), n.guid || (n.guid = w.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function (t) {
            return void 0 !== w && w.event.triggered !== t.type ? w.event.dispatch.apply(e, arguments) : void 0
          }), l = (t = (t || "").match(H) || [""]).length; l--;) p = g = (s = Ce.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), p && (f = w.event.special[p] || {}, p = (i ? f.delegateType : f.bindType) || p, f = w.event.special[p] || {}, c = w.extend({
          type: p,
          origType: g,
          data: r,
          handler: n,
          guid: n.guid,
          selector: i,
          needsContext: i && w.expr.match.needsContext.test(i),
          namespace: h.join(".")
        }, o), (d = u[p]) || ((d = u[p] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(e, r, h, a) || e.addEventListener && e.addEventListener(p, a)), f.add && (f.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? d.splice(d.delegateCount++, 0, c) : d.push(c), w.event.global[p] = !0)
    },
    remove: function (e, t, n, r, i) {
      var o, a, s, u, l, c, f, d, p, h, g, v = Y.hasData(e) && Y.get(e);
      if (v && (u = v.events)) {
        for (l = (t = (t || "").match(H) || [""]).length; l--;)
          if (p = g = (s = Ce.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), p) {
            for (f = w.event.special[p] || {}, d = u[p = (r ? f.delegateType : f.bindType) || p] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = d.length; o--;) c = d[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (d.splice(o, 1), c.selector && d.delegateCount--, f.remove && f.remove.call(e, c));
            a && !d.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || w.removeEvent(e, p, v.handle), delete u[p])
          } else
            for (p in u) w.event.remove(e, p + t[l], n, r, !0);
        w.isEmptyObject(u) && Y.remove(e, "handle events")
      }
    },
    dispatch: function (e) {
      var t, n, r, i, o, a, s = new Array(arguments.length),
        u = w.event.fix(e),
        l = (Y.get(this, "events") || Object.create(null))[u.type] || [],
        c = w.event.special[u.type] || {};
      for (s[0] = u, t = 1; t < arguments.length; t++) s[t] = arguments[t];
      if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) {
        for (a = w.event.handlers.call(this, u, l), t = 0;
          (i = a[t++]) && !u.isPropagationStopped();)
          for (u.currentTarget = i.elem, n = 0;
            (o = i.handlers[n++]) && !u.isImmediatePropagationStopped();) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((w.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation()));
        return c.postDispatch && c.postDispatch.call(this, u), u.result
      }
    },
    handlers: function (e, t) {
      var n, r, i, o, a, s = [],
        u = t.delegateCount,
        l = e.target;
      if (u && l.nodeType && !("click" === e.type && e.button >= 1))
        for (; l !== this; l = l.parentNode || this)
          if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
            for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? w(i, this).index(l) > -1 : w.find(i, this, null, [l]).length), a[i] && o.push(r);
            o.length && s.push({
              elem: l,
              handlers: o
            })
          } return l = this, u < t.length && s.push({
        elem: l,
        handlers: t.slice(u)
      }), s
    },
    addProp: function (e, t) {
      Object.defineProperty(w.Event.prototype, e, {
        enumerable: !0,
        configurable: !0,
        get: h(t) ? function () {
          if (this.originalEvent) return t(this.originalEvent)
        } : function () {
          if (this.originalEvent) return this.originalEvent[e]
        },
        set: function (t) {
          Object.defineProperty(this, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: t
          })
        }
      })
    },
    fix: function (e) {
      return e[w.expando] ? e : new w.Event(e)
    },
    special: {
      load: {
        noBubble: !0
      },
      click: {
        setup: function (e) {
          var t = this || e;
          return de.test(t.type) && t.click && S(t, "input") && Se(t, "click", Te), !1
        },
        trigger: function (e) {
          var t = this || e;
          return de.test(t.type) && t.click && S(t, "input") && Se(t, "click"), !0
        },
        _default: function (e) {
          var t = e.target;
          return de.test(t.type) && t.click && S(t, "input") && Y.get(t, "click") || S(t, "a")
        }
      },
      beforeunload: {
        postDispatch: function (e) {
          void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
        }
      }
    }
  }, w.removeEvent = function (e, t, n) {
    e.removeEventListener && e.removeEventListener(t, n)
  }, w.Event = function (e, t) {
    if (!(this instanceof w.Event)) return new w.Event(e, t);
    e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Te : Ee, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && w.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[w.expando] = !0
  }, w.Event.prototype = {
    constructor: w.Event,
    isDefaultPrevented: Ee,
    isPropagationStopped: Ee,
    isImmediatePropagationStopped: Ee,
    isSimulated: !1,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = Te, e && !this.isSimulated && e.preventDefault()
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = Te, e && !this.isSimulated && e.stopPropagation()
    },
    stopImmediatePropagation: function () {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = Te, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
    }
  }, w.each({
    altKey: !0,
    bubbles: !0,
    cancelable: !0,
    changedTouches: !0,
    ctrlKey: !0,
    detail: !0,
    eventPhase: !0,
    metaKey: !0,
    pageX: !0,
    pageY: !0,
    shiftKey: !0,
    view: !0,
    char: !0,
    code: !0,
    charCode: !0,
    key: !0,
    keyCode: !0,
    button: !0,
    buttons: !0,
    clientX: !0,
    clientY: !0,
    offsetX: !0,
    offsetY: !0,
    pointerId: !0,
    pointerType: !0,
    screenX: !0,
    screenY: !0,
    targetTouches: !0,
    toElement: !0,
    touches: !0,
    which: function (e) {
      var t = e.button;
      return null == e.which && xe.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && we.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which
    }
  }, w.event.addProp), w.each({
    focus: "focusin",
    blur: "focusout"
  }, (function (e, t) {
    w.event.special[e] = {
      setup: function () {
        return Se(this, e, Ae), !1
      },
      trigger: function () {
        return Se(this, e), !0
      },
      delegateType: t
    }
  })), w.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, (function (e, t) {
    w.event.special[e] = {
      delegateType: t,
      bindType: t,
      handle: function (e) {
        var n, r = this,
          i = e.relatedTarget,
          o = e.handleObj;
        return i && (i === r || w.contains(r, i)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n
      }
    }
  })), w.fn.extend({
    on: function (e, t, n, r) {
      return Ne(this, e, t, n, r)
    },
    one: function (e, t, n, r) {
      return Ne(this, e, t, n, r, 1)
    },
    off: function (e, t, n) {
      var r, i;
      if (e && e.preventDefault && e.handleObj) return r = e.handleObj, w(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
      if ("object" == typeof e) {
        for (i in e) this.off(i, t, e[i]);
        return this
      }
      return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Ee), this.each((function () {
        w.event.remove(this, e, n, t)
      }))
    }
  });
  var ke = /<script|<style|<link/i,
    De = /checked\s*(?:[^=]|=\s*.checked.)/i,
    Le = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  function je(e, t) {
    return S(e, "table") && S(11 !== t.nodeType ? t : t.firstChild, "tr") && w(e).children("tbody")[0] || e
  }

  function qe(e) {
    return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
  }

  function Oe(e) {
    return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
  }

  function Pe(e, t) {
    var n, r, i, o, a, s;
    if (1 === t.nodeType) {
      if (Y.hasData(e) && (s = Y.get(e).events))
        for (i in Y.remove(t, "handle events"), s)
          for (n = 0, r = s[i].length; n < r; n++) w.event.add(t, i, s[i][n]);
      G.hasData(e) && (o = G.access(e), a = w.extend({}, o), G.set(t, a))
    }
  }

  function He(e, t) {
    var n = t.nodeName.toLowerCase();
    "input" === n && de.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue)
  }

  function Ie(e, t, n, r) {
    t = o(t);
    var i, a, s, u, l, c, f = 0,
      d = e.length,
      g = d - 1,
      v = t[0],
      m = h(v);
    if (m || d > 1 && "string" == typeof v && !p.checkClone && De.test(v)) return e.each((function (i) {
      var o = e.eq(i);
      m && (t[0] = v.call(this, i, o.html())), Ie(o, t, n, r)
    }));
    if (d && (a = (i = be(t, e[0].ownerDocument, !1, e, r)).firstChild, 1 === i.childNodes.length && (i = a), a || r)) {
      for (u = (s = w.map(ve(i, "script"), qe)).length; f < d; f++) l = i, f !== g && (l = w.clone(l, !0, !0), u && w.merge(s, ve(l, "script"))), n.call(e[f], l, f);
      if (u)
        for (c = s[s.length - 1].ownerDocument, w.map(s, Oe), f = 0; f < u; f++) l = s[f], he.test(l.type || "") && !Y.access(l, "globalEval") && w.contains(c, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? w._evalUrl && !l.noModule && w._evalUrl(l.src, {
          nonce: l.nonce || l.getAttribute("nonce")
        }, c) : y(l.textContent.replace(Le, ""), l, c))
    }
    return e
  }

  function Re(e, t, n) {
    for (var r, i = t ? w.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || w.cleanData(ve(r)), r.parentNode && (n && ie(r) && me(ve(r, "script")), r.parentNode.removeChild(r));
    return e
  }
  w.extend({
    htmlPrefilter: function (e) {
      return e
    },
    clone: function (e, t, n) {
      var r, i, o, a, s = e.cloneNode(!0),
        u = ie(e);
      if (!(p.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || w.isXMLDoc(e)))
        for (a = ve(s), r = 0, i = (o = ve(e)).length; r < i; r++) He(o[r], a[r]);
      if (t)
        if (n)
          for (o = o || ve(e), a = a || ve(s), r = 0, i = o.length; r < i; r++) Pe(o[r], a[r]);
        else Pe(e, s);
      return (a = ve(s, "script")).length > 0 && me(a, !u && ve(e, "script")), s
    },
    cleanData: function (e) {
      for (var t, n, r, i = w.event.special, o = 0; void 0 !== (n = e[o]); o++)
        if (X(n)) {
          if (t = n[Y.expando]) {
            if (t.events)
              for (r in t.events) i[r] ? w.event.remove(n, r) : w.removeEvent(n, r, t.handle);
            n[Y.expando] = void 0
          }
          n[G.expando] && (n[G.expando] = void 0)
        }
    }
  }), w.fn.extend({
    detach: function (e) {
      return Re(this, e, !0)
    },
    remove: function (e) {
      return Re(this, e)
    },
    text: function (e) {
      return $(this, (function (e) {
        return void 0 === e ? w.text(this) : this.empty().each((function () {
          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
        }))
      }), null, e, arguments.length)
    },
    append: function () {
      return Ie(this, arguments, (function (e) {
        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e)
      }))
    },
    prepend: function () {
      return Ie(this, arguments, (function (e) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var t = je(this, e);
          t.insertBefore(e, t.firstChild)
        }
      }))
    },
    before: function () {
      return Ie(this, arguments, (function (e) {
        this.parentNode && this.parentNode.insertBefore(e, this)
      }))
    },
    after: function () {
      return Ie(this, arguments, (function (e) {
        this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
      }))
    },
    empty: function () {
      for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (w.cleanData(ve(e, !1)), e.textContent = "");
      return this
    },
    clone: function (e, t) {
      return e = null != e && e, t = null == t ? e : t, this.map((function () {
        return w.clone(this, e, t)
      }))
    },
    html: function (e) {
      return $(this, (function (e) {
        var t = this[0] || {},
          n = 0,
          r = this.length;
        if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
        if ("string" == typeof e && !ke.test(e) && !ge[(pe.exec(e) || ["", ""])[1].toLowerCase()]) {
          e = w.htmlPrefilter(e);
          try {
            for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (w.cleanData(ve(t, !1)), t.innerHTML = e);
            t = 0
          } catch (e) {}
        }
        t && this.empty().append(e)
      }), null, e, arguments.length)
    },
    replaceWith: function () {
      var e = [];
      return Ie(this, arguments, (function (t) {
        var n = this.parentNode;
        w.inArray(this, e) < 0 && (w.cleanData(ve(this)), n && n.replaceChild(t, this))
      }), e)
    }
  }), w.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, (function (e, t) {
    w.fn[e] = function (e) {
      for (var n, r = [], i = w(e), o = i.length - 1, s = 0; s <= o; s++) n = s === o ? this : this.clone(!0), w(i[s])[t](n), a.apply(r, n.get());
      return this.pushStack(r)
    }
  }));
  var Be = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"),
    Me = function (t) {
      var n = t.ownerDocument.defaultView;
      return n && n.opener || (n = e), n.getComputedStyle(t)
    },
    We = function (e, t, n) {
      var r, i, o = {};
      for (i in t) o[i] = e.style[i], e.style[i] = t[i];
      for (i in r = n.call(e), t) e.style[i] = o[i];
      return r
    },
    Fe = new RegExp(ne.join("|"), "i");

  function $e(e, t, n) {
    var r, i, o, a, s = e.style;
    return (n = n || Me(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = w.style(e, t)), !p.pixelBoxStyles() && Be.test(a) && Fe.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a
  }

  function ze(e, t) {
    return {
      get: function () {
        if (!e()) return (this.get = t).apply(this, arguments);
        delete this.get
      }
    }
  }! function () {
    function t() {
      if (c) {
        l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", c.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(l).appendChild(c);
        var t = e.getComputedStyle(c);
        r = "1%" !== t.top, u = 12 === n(t.marginLeft), c.style.right = "60%", a = 36 === n(t.right), i = 36 === n(t.width), c.style.position = "absolute", o = 12 === n(c.offsetWidth / 3), re.removeChild(l), c = null
      }
    }

    function n(e) {
      return Math.round(parseFloat(e))
    }
    var r, i, o, a, s, u, l = v.createElement("div"),
      c = v.createElement("div");
    c.style && (c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", p.clearCloneStyle = "content-box" === c.style.backgroundClip, w.extend(p, {
      boxSizingReliable: function () {
        return t(), i
      },
      pixelBoxStyles: function () {
        return t(), a
      },
      pixelPosition: function () {
        return t(), r
      },
      reliableMarginLeft: function () {
        return t(), u
      },
      scrollboxSize: function () {
        return t(), o
      },
      reliableTrDimensions: function () {
        var t, n, r, i;
        return null == s && (t = v.createElement("table"), n = v.createElement("tr"), r = v.createElement("div"), t.style.cssText = "position:absolute;left:-11111px", n.style.height = "1px", r.style.height = "9px", re.appendChild(t).appendChild(n).appendChild(r), i = e.getComputedStyle(n), s = parseInt(i.height) > 3, re.removeChild(t)), s
      }
    }))
  }();
  var _e = ["Webkit", "Moz", "ms"],
    Ue = v.createElement("div").style,
    Ve = {};

  function Xe(e) {
    var t = w.cssProps[e] || Ve[e];
    return t || (e in Ue ? e : Ve[e] = function (e) {
      for (var t = e[0].toUpperCase() + e.slice(1), n = _e.length; n--;)
        if ((e = _e[n] + t) in Ue) return e
    }(e) || e)
  }
  var Qe = /^(none|table(?!-c[ea]).+)/,
    Ye = /^--/,
    Ge = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Ke = {
      letterSpacing: "0",
      fontWeight: "400"
    };

  function Je(e, t, n) {
    var r = te.exec(t);
    return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t
  }

  function Ze(e, t, n, r, i, o) {
    var a = "width" === t ? 1 : 0,
      s = 0,
      u = 0;
    if (n === (r ? "border" : "content")) return 0;
    for (; a < 4; a += 2) "margin" === n && (u += w.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= w.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= w.css(e, "border" + ne[a] + "Width", !0, i))) : (u += w.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += w.css(e, "border" + ne[a] + "Width", !0, i) : s += w.css(e, "border" + ne[a] + "Width", !0, i));
    return !r && o >= 0 && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u
  }

  function et(e, t, n) {
    var r = Me(e),
      i = (!p.boxSizingReliable() || n) && "border-box" === w.css(e, "boxSizing", !1, r),
      o = i,
      a = $e(e, t, r),
      s = "offset" + t[0].toUpperCase() + t.slice(1);
    if (Be.test(a)) {
      if (!n) return a;
      a = "auto"
    }
    return (!p.boxSizingReliable() && i || !p.reliableTrDimensions() && S(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === w.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === w.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Ze(e, t, n || (i ? "border" : "content"), o, r, a) + "px"
  }
  w.extend({
      cssHooks: {
        opacity: {
          get: function (e, t) {
            if (t) {
              var n = $e(e, "opacity");
              return "" === n ? "1" : n
            }
          }
        }
      },
      cssNumber: {
        animationIterationCount: !0,
        columnCount: !0,
        fillOpacity: !0,
        flexGrow: !0,
        flexShrink: !0,
        fontWeight: !0,
        gridArea: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnStart: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowStart: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0
      },
      cssProps: {},
      style: function (e, t, n, r) {
        if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
          var i, o, a, s = V(t),
            u = Ye.test(t),
            l = e.style;
          if (u || (t = Xe(s)), a = w.cssHooks[t] || w.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
          "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = function (e, t, n, r) {
            var i, o, a = 20,
              s = r ? function () {
                return r.cur()
              } : function () {
                return w.css(e, t, "")
              },
              u = s(),
              l = n && n[3] || (w.cssNumber[t] ? "" : "px"),
              c = e.nodeType && (w.cssNumber[t] || "px" !== l && +u) && te.exec(w.css(e, t));
            if (c && c[3] !== l) {
              for (u /= 2, l = l || c[3], c = +u || 1; a--;) w.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
              c *= 2, w.style(e, t, c + l), n = n || []
            }
            return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i
          }(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (w.cssNumber[s] ? "" : "px")), p.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n))
        }
      },
      css: function (e, t, n, r) {
        var i, o, a, s = V(t);
        return Ye.test(t) || (t = Xe(s)), (a = w.cssHooks[t] || w.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = $e(e, t, r)), "normal" === i && t in Ke && (i = Ke[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i
      }
    }), w.each(["height", "width"], (function (e, t) {
      w.cssHooks[t] = {
        get: function (e, n, r) {
          if (n) return !Qe.test(w.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? et(e, t, r) : We(e, Ge, (function () {
            return et(e, t, r)
          }))
        },
        set: function (e, n, r) {
          var i, o = Me(e),
            a = !p.scrollboxSize() && "absolute" === o.position,
            s = (a || r) && "border-box" === w.css(e, "boxSizing", !1, o),
            u = r ? Ze(e, t, r, s, o) : 0;
          return s && a && (u -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(o[t]) - Ze(e, t, "border", !1, o) - .5)), u && (i = te.exec(n)) && "px" !== (i[3] || "px") && (e.style[t] = n, n = w.css(e, t)), Je(0, n, u)
        }
      }
    })), w.cssHooks.marginLeft = ze(p.reliableMarginLeft, (function (e, t) {
      if (t) return (parseFloat($e(e, "marginLeft")) || e.getBoundingClientRect().left - We(e, {
        marginLeft: 0
      }, (function () {
        return e.getBoundingClientRect().left
      }))) + "px"
    })), w.each({
      margin: "",
      padding: "",
      border: "Width"
    }, (function (e, t) {
      w.cssHooks[e + t] = {
        expand: function (n) {
          for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++) i[e + ne[r] + t] = o[r] || o[r - 2] || o[0];
          return i
        }
      }, "margin" !== e && (w.cssHooks[e + t].set = Je)
    })), w.fn.extend({
      css: function (e, t) {
        return $(this, (function (e, t, n) {
          var r, i, o = {},
            a = 0;
          if (Array.isArray(t)) {
            for (r = Me(e), i = t.length; a < i; a++) o[t[a]] = w.css(e, t[a], !1, r);
            return o
          }
          return void 0 !== n ? w.style(e, t, n) : w.css(e, t)
        }), e, t, arguments.length > 1)
      }
    }), w.fn.delay = function (t, n) {
      return t = w.fx && w.fx.speeds[t] || t, n = n || "fx", this.queue(n, (function (n, r) {
        var i = e.setTimeout(n, t);
        r.stop = function () {
          e.clearTimeout(i)
        }
      }))
    },
    function () {
      var e = v.createElement("input"),
        t = v.createElement("select").appendChild(v.createElement("option"));
      e.type = "checkbox", p.checkOn = "" !== e.value, p.optSelected = t.selected, (e = v.createElement("input")).value = "t", e.type = "radio", p.radioValue = "t" === e.value
    }();
  var tt, nt = w.expr.attrHandle;
  w.fn.extend({
    attr: function (e, t) {
      return $(this, w.attr, e, t, arguments.length > 1)
    },
    removeAttr: function (e) {
      return this.each((function () {
        w.removeAttr(this, e)
      }))
    }
  }), w.extend({
    attr: function (e, t, n) {
      var r, i, o = e.nodeType;
      if (3 !== o && 8 !== o && 2 !== o) return void 0 === e.getAttribute ? w.prop(e, t, n) : (1 === o && w.isXMLDoc(e) || (i = w.attrHooks[t.toLowerCase()] || (w.expr.match.bool.test(t) ? tt : void 0)), void 0 !== n ? null === n ? void w.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = w.find.attr(e, t)) ? void 0 : r)
    },
    attrHooks: {
      type: {
        set: function (e, t) {
          if (!p.radioValue && "radio" === t && S(e, "input")) {
            var n = e.value;
            return e.setAttribute("type", t), n && (e.value = n), t
          }
        }
      }
    },
    removeAttr: function (e, t) {
      var n, r = 0,
        i = t && t.match(H);
      if (i && 1 === e.nodeType)
        for (; n = i[r++];) e.removeAttribute(n)
    }
  }), tt = {
    set: function (e, t, n) {
      return !1 === t ? w.removeAttr(e, n) : e.setAttribute(n, n), n
    }
  }, w.each(w.expr.match.bool.source.match(/\w+/g), (function (e, t) {
    var n = nt[t] || w.find.attr;
    nt[t] = function (e, t, r) {
      var i, o, a = t.toLowerCase();
      return r || (o = nt[a], nt[a] = i, i = null != n(e, t, r) ? a : null, nt[a] = o), i
    }
  }));
  var rt = /^(?:input|select|textarea|button)$/i,
    it = /^(?:a|area)$/i;

  function ot(e) {
    return (e.match(H) || []).join(" ")
  }

  function at(e) {
    return e.getAttribute && e.getAttribute("class") || ""
  }

  function st(e) {
    return Array.isArray(e) ? e : "string" == typeof e && e.match(H) || []
  }
  w.fn.extend({
    prop: function (e, t) {
      return $(this, w.prop, e, t, arguments.length > 1)
    },
    removeProp: function (e) {
      return this.each((function () {
        delete this[w.propFix[e] || e]
      }))
    }
  }), w.extend({
    prop: function (e, t, n) {
      var r, i, o = e.nodeType;
      if (3 !== o && 8 !== o && 2 !== o) return 1 === o && w.isXMLDoc(e) || (t = w.propFix[t] || t, i = w.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]
    },
    propHooks: {
      tabIndex: {
        get: function (e) {
          var t = w.find.attr(e, "tabindex");
          return t ? parseInt(t, 10) : rt.test(e.nodeName) || it.test(e.nodeName) && e.href ? 0 : -1
        }
      }
    },
    propFix: {
      for: "htmlFor",
      class: "className"
    }
  }), p.optSelected || (w.propHooks.selected = {
    get: function (e) {
      var t = e.parentNode;
      return t && t.parentNode && t.parentNode.selectedIndex, null
    },
    set: function (e) {
      var t = e.parentNode;
      t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
    }
  }), w.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function () {
    w.propFix[this.toLowerCase()] = this
  })), w.fn.extend({
    addClass: function (e) {
      var t, n, r, i, o, a, s, u = 0;
      if (h(e)) return this.each((function (t) {
        w(this).addClass(e.call(this, t, at(this)))
      }));
      if ((t = st(e)).length)
        for (; n = this[u++];)
          if (i = at(n), r = 1 === n.nodeType && " " + ot(i) + " ") {
            for (a = 0; o = t[a++];) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
            i !== (s = ot(r)) && n.setAttribute("class", s)
          } return this
    },
    removeClass: function (e) {
      var t, n, r, i, o, a, s, u = 0;
      if (h(e)) return this.each((function (t) {
        w(this).removeClass(e.call(this, t, at(this)))
      }));
      if (!arguments.length) return this.attr("class", "");
      if ((t = st(e)).length)
        for (; n = this[u++];)
          if (i = at(n), r = 1 === n.nodeType && " " + ot(i) + " ") {
            for (a = 0; o = t[a++];)
              for (; r.indexOf(" " + o + " ") > -1;) r = r.replace(" " + o + " ", " ");
            i !== (s = ot(r)) && n.setAttribute("class", s)
          } return this
    },
    toggleClass: function (e, t) {
      var n = typeof e,
        r = "string" === n || Array.isArray(e);
      return "boolean" == typeof t && r ? t ? this.addClass(e) : this.removeClass(e) : h(e) ? this.each((function (n) {
        w(this).toggleClass(e.call(this, n, at(this), t), t)
      })) : this.each((function () {
        var t, i, o, a;
        if (r)
          for (i = 0, o = w(this), a = st(e); t = a[i++];) o.hasClass(t) ? o.removeClass(t) : o.addClass(t);
        else void 0 !== e && "boolean" !== n || ((t = at(this)) && Y.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : Y.get(this, "__className__") || ""))
      }))
    },
    hasClass: function (e) {
      var t, n, r = 0;
      for (t = " " + e + " "; n = this[r++];)
        if (1 === n.nodeType && (" " + ot(at(n)) + " ").indexOf(t) > -1) return !0;
      return !1
    }
  });
  var ut = /\r/g;
  w.fn.extend({
    val: function (e) {
      var t, n, r, i = this[0];
      return arguments.length ? (r = h(e), this.each((function (n) {
        var i;
        1 === this.nodeType && (null == (i = r ? e.call(this, n, w(this).val()) : e) ? i = "" : "number" == typeof i ? i += "" : Array.isArray(i) && (i = w.map(i, (function (e) {
          return null == e ? "" : e + ""
        }))), (t = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i))
      }))) : i ? (t = w.valHooks[i.type] || w.valHooks[i.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : "string" == typeof (n = i.value) ? n.replace(ut, "") : null == n ? "" : n : void 0
    }
  }), w.extend({
    valHooks: {
      option: {
        get: function (e) {
          var t = w.find.attr(e, "value");
          return null != t ? t : ot(w.text(e))
        }
      },
      select: {
        get: function (e) {
          var t, n, r, i = e.options,
            o = e.selectedIndex,
            a = "select-one" === e.type,
            s = a ? null : [],
            u = a ? o + 1 : i.length;
          for (r = o < 0 ? u : a ? o : 0; r < u; r++)
            if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !S(n.parentNode, "optgroup"))) {
              if (t = w(n).val(), a) return t;
              s.push(t)
            } return s
        },
        set: function (e, t) {
          for (var n, r, i = e.options, o = w.makeArray(t), a = i.length; a--;)((r = i[a]).selected = w.inArray(w.valHooks.option.get(r), o) > -1) && (n = !0);
          return n || (e.selectedIndex = -1), o
        }
      }
    }
  }), w.each(["radio", "checkbox"], (function () {
    w.valHooks[this] = {
      set: function (e, t) {
        if (Array.isArray(t)) return e.checked = w.inArray(w(e).val(), t) > -1
      }
    }, p.checkOn || (w.valHooks[this].get = function (e) {
      return null === e.getAttribute("value") ? "on" : e.value
    })
  })), p.focusin = "onfocusin" in e;
  var lt = /^(?:focusinfocus|focusoutblur)$/,
    ct = function (e) {
      e.stopPropagation()
    };
  w.extend(w.event, {
    trigger: function (t, n, r, i) {
      var o, a, s, u, l, f, d, p, m = [r || v],
        y = c.call(t, "type") ? t.type : t,
        b = c.call(t, "namespace") ? t.namespace.split(".") : [];
      if (a = p = s = r = r || v, 3 !== r.nodeType && 8 !== r.nodeType && !lt.test(y + w.event.triggered) && (y.indexOf(".") > -1 && (b = y.split("."), y = b.shift(), b.sort()), l = y.indexOf(":") < 0 && "on" + y, (t = t[w.expando] ? t : new w.Event(y, "object" == typeof t && t)).isTrigger = i ? 2 : 3, t.namespace = b.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + b.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = r), n = null == n ? [t] : w.makeArray(n, [t]), d = w.event.special[y] || {}, i || !d.trigger || !1 !== d.trigger.apply(r, n))) {
        if (!i && !d.noBubble && !g(r)) {
          for (u = d.delegateType || y, lt.test(u + y) || (a = a.parentNode); a; a = a.parentNode) m.push(a), s = a;
          s === (r.ownerDocument || v) && m.push(s.defaultView || s.parentWindow || e)
        }
        for (o = 0;
          (a = m[o++]) && !t.isPropagationStopped();) p = a, t.type = o > 1 ? u : d.bindType || y, (f = (Y.get(a, "events") || Object.create(null))[t.type] && Y.get(a, "handle")) && f.apply(a, n), (f = l && a[l]) && f.apply && X(a) && (t.result = f.apply(a, n), !1 === t.result && t.preventDefault());
        return t.type = y, i || t.isDefaultPrevented() || d._default && !1 !== d._default.apply(m.pop(), n) || !X(r) || l && h(r[y]) && !g(r) && ((s = r[l]) && (r[l] = null), w.event.triggered = y, t.isPropagationStopped() && p.addEventListener(y, ct), r[y](), t.isPropagationStopped() && p.removeEventListener(y, ct), w.event.triggered = void 0, s && (r[l] = s)), t.result
      }
    },
    simulate: function (e, t, n) {
      var r = w.extend(new w.Event, n, {
        type: e,
        isSimulated: !0
      });
      w.event.trigger(r, null, t)
    }
  }), w.fn.extend({
    trigger: function (e, t) {
      return this.each((function () {
        w.event.trigger(e, t, this)
      }))
    },
    triggerHandler: function (e, t) {
      var n = this[0];
      if (n) return w.event.trigger(e, t, n, !0)
    }
  }), p.focusin || w.each({
    focus: "focusin",
    blur: "focusout"
  }, (function (e, t) {
    var n = function (e) {
      w.event.simulate(t, e.target, w.event.fix(e))
    };
    w.event.special[t] = {
      setup: function () {
        var r = this.ownerDocument || this.document || this,
          i = Y.access(r, t);
        i || r.addEventListener(e, n, !0), Y.access(r, t, (i || 0) + 1)
      },
      teardown: function () {
        var r = this.ownerDocument || this.document || this,
          i = Y.access(r, t) - 1;
        i ? Y.access(r, t, i) : (r.removeEventListener(e, n, !0), Y.remove(r, t))
      }
    }
  })), w.parseXML = function (t) {
    var n;
    if (!t || "string" != typeof t) return null;
    try {
      n = (new e.DOMParser).parseFromString(t, "text/xml")
    } catch (e) {
      n = void 0
    }
    return n && !n.getElementsByTagName("parsererror").length || w.error("Invalid XML: " + t), n
  };
  var ft, dt = /\[\]$/,
    pt = /\r?\n/g,
    ht = /^(?:submit|button|image|reset|file)$/i,
    gt = /^(?:input|select|textarea|keygen)/i;

  function vt(e, t, n, r) {
    var i;
    if (Array.isArray(t)) w.each(t, (function (t, i) {
      n || dt.test(e) ? r(e, i) : vt(e + "[" + ("object" == typeof i && null != i ? t : "") + "]", i, n, r)
    }));
    else if (n || "object" !== b(t)) r(e, t);
    else
      for (i in t) vt(e + "[" + i + "]", t[i], n, r)
  }
  w.param = function (e, t) {
    var n, r = [],
      i = function (e, t) {
        var n = h(t) ? t() : t;
        r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
      };
    if (null == e) return "";
    if (Array.isArray(e) || e.jquery && !w.isPlainObject(e)) w.each(e, (function () {
      i(this.name, this.value)
    }));
    else
      for (n in e) vt(n, e[n], t, i);
    return r.join("&")
  }, w.fn.extend({
    serialize: function () {
      return w.param(this.serializeArray())
    },
    serializeArray: function () {
      return this.map((function () {
        var e = w.prop(this, "elements");
        return e ? w.makeArray(e) : this
      })).filter((function () {
        var e = this.type;
        return this.name && !w(this).is(":disabled") && gt.test(this.nodeName) && !ht.test(e) && (this.checked || !de.test(e))
      })).map((function (e, t) {
        var n = w(this).val();
        return null == n ? null : Array.isArray(n) ? w.map(n, (function (e) {
          return {
            name: t.name,
            value: e.replace(pt, "\r\n")
          }
        })) : {
          name: t.name,
          value: n.replace(pt, "\r\n")
        }
      })).get()
    }
  }), w.fn.extend({
    wrapAll: function (e) {
      var t;
      return this[0] && (h(e) && (e = e.call(this[0])), t = w(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map((function () {
        for (var e = this; e.firstElementChild;) e = e.firstElementChild;
        return e
      })).append(this)), this
    },
    wrapInner: function (e) {
      return h(e) ? this.each((function (t) {
        w(this).wrapInner(e.call(this, t))
      })) : this.each((function () {
        var t = w(this),
          n = t.contents();
        n.length ? n.wrapAll(e) : t.append(e)
      }))
    },
    wrap: function (e) {
      var t = h(e);
      return this.each((function (n) {
        w(this).wrapAll(t ? e.call(this, n) : e)
      }))
    },
    unwrap: function (e) {
      return this.parent(e).not("body").each((function () {
        w(this).replaceWith(this.childNodes)
      })), this
    }
  }), w.expr.pseudos.hidden = function (e) {
    return !w.expr.pseudos.visible(e)
  }, w.expr.pseudos.visible = function (e) {
    return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
  }, p.createHTMLDocument = ((ft = v.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === ft.childNodes.length), w.parseHTML = function (e, t, n) {
    return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (p.createHTMLDocument ? ((r = (t = v.implementation.createHTMLDocument("")).createElement("base")).href = v.location.href, t.head.appendChild(r)) : t = v), o = !n && [], (i = k.exec(e)) ? [t.createElement(i[1])] : (i = be([e], t, o), o && o.length && w(o).remove(), w.merge([], i.childNodes)));
    var r, i, o
  }, w.offset = {
    setOffset: function (e, t, n) {
      var r, i, o, a, s, u, l = w.css(e, "position"),
        c = w(e),
        f = {};
      "static" === l && (e.style.position = "relative"), s = c.offset(), o = w.css(e, "top"), u = w.css(e, "left"), ("absolute" === l || "fixed" === l) && (o + u).indexOf("auto") > -1 ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), h(t) && (t = t.call(e, n, w.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : ("number" == typeof f.top && (f.top += "px"), "number" == typeof f.left && (f.left += "px"), c.css(f))
    }
  }, w.fn.extend({
    offset: function (e) {
      if (arguments.length) return void 0 === e ? this : this.each((function (t) {
        w.offset.setOffset(this, e, t)
      }));
      var t, n, r = this[0];
      return r ? r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
        top: t.top + n.pageYOffset,
        left: t.left + n.pageXOffset
      }) : {
        top: 0,
        left: 0
      } : void 0
    },
    position: function () {
      if (this[0]) {
        var e, t, n, r = this[0],
          i = {
            top: 0,
            left: 0
          };
        if ("fixed" === w.css(r, "position")) t = r.getBoundingClientRect();
        else {
          for (t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === w.css(e, "position");) e = e.parentNode;
          e && e !== r && 1 === e.nodeType && ((i = w(e).offset()).top += w.css(e, "borderTopWidth", !0), i.left += w.css(e, "borderLeftWidth", !0))
        }
        return {
          top: t.top - i.top - w.css(r, "marginTop", !0),
          left: t.left - i.left - w.css(r, "marginLeft", !0)
        }
      }
    },
    offsetParent: function () {
      return this.map((function () {
        for (var e = this.offsetParent; e && "static" === w.css(e, "position");) e = e.offsetParent;
        return e || re
      }))
    }
  }), w.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, (function (e, t) {
    var n = "pageYOffset" === t;
    w.fn[e] = function (r) {
      return $(this, (function (e, r, i) {
        var o;
        if (g(e) ? o = e : 9 === e.nodeType && (o = e.defaultView), void 0 === i) return o ? o[t] : e[r];
        o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : e[r] = i
      }), e, r, arguments.length)
    }
  })), w.each(["top", "left"], (function (e, t) {
    w.cssHooks[t] = ze(p.pixelPosition, (function (e, n) {
      if (n) return n = $e(e, t), Be.test(n) ? w(e).position()[t] + "px" : n
    }))
  })), w.each({
    Height: "height",
    Width: "width"
  }, (function (e, t) {
    w.each({
      padding: "inner" + e,
      content: t,
      "": "outer" + e
    }, (function (n, r) {
      w.fn[r] = function (i, o) {
        var a = arguments.length && (n || "boolean" != typeof i),
          s = n || (!0 === i || !0 === o ? "margin" : "border");
        return $(this, (function (t, n, i) {
          var o;
          return g(t) ? 0 === r.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === i ? w.css(t, n, s) : w.style(t, n, i, s)
        }), t, a ? i : void 0, a)
      }
    }))
  })), w.fn.extend({
    bind: function (e, t, n) {
      return this.on(e, null, t, n)
    },
    unbind: function (e, t) {
      return this.off(e, null, t)
    },
    delegate: function (e, t, n, r) {
      return this.on(t, e, n, r)
    },
    undelegate: function (e, t, n) {
      return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
    },
    hover: function (e, t) {
      return this.mouseenter(e).mouseleave(t || e)
    }
  }), w.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function (e, t) {
    w.fn[t] = function (e, n) {
      return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
    }
  }));
  var mt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  w.proxy = function (e, t) {
    var n, r, o;
    if ("string" == typeof t && (n = e[t], t = e, e = n), h(e)) return r = i.call(arguments, 2), (o = function () {
      return e.apply(t || this, r.concat(i.call(arguments)))
    }).guid = e.guid = e.guid || w.guid++, o
  }, w.holdReady = function (e) {
    e ? w.readyWait++ : w.ready(!0)
  }, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = S, w.isFunction = h, w.isWindow = g, w.camelCase = V, w.type = b, w.now = Date.now, w.isNumeric = function (e) {
    var t = w.type(e);
    return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
  }, w.trim = function (e) {
    return null == e ? "" : (e + "").replace(mt, "")
  }, "function" == typeof define && define.amd && define("jquery", [], (function () {
    return w
  }));
  var yt = e.jQuery,
    bt = e.$;
  return w.noConflict = function (t) {
    return e.$ === w && (e.$ = bt), t && e.jQuery === w && (e.jQuery = yt), w
  }, void 0 === t && (e.jQuery = e.$ = w), w
}));

function createMediaBox(e, t) {
  let i = t.resolution ? '<span class="size">' + t.resolution + "</span>" : "",
    a = '<span class="quality">' + t.format.downloadableType + "</span>",
    n = "",
    o = VideoTools.secondToHHMMSS(t.duration);
  o && (n = '<span class="size">' + o + "</span>");
  let s = t.size ? '<span class="size">' + Helper.formatBytes(t.size) + " </span>" : "";
  $("#videoList").prepend('                <div class="col-12 nopadding box mediaBox" data-media-id="' + e + '">                <span class="icon"><a href="#" class="playVideo"><span></span></a></span>                <div class="box-right">                    ' + a + "                    " + n + "                    " + i + "                    " + s + '                    <a href="#" class="download">                        <svg xmlns="http://www.w3.org/2000/svg" width="22.001" height="22" viewBox="0 0 22.001 22"><path id="download" d="M22,16.14v2.922A3.441,3.441,0,0,1,18.563,22.5H3.438A3.441,3.441,0,0,1,0,19.062V16.14a.859.859,0,0,1,1.719,0v2.922a1.721,1.721,0,0,0,1.719,1.719H18.563a1.721,1.721,0,0,0,1.719-1.719V16.14a.859.859,0,0,1,1.719,0ZM9.217,18.3a2.575,2.575,0,0,0,3.652,0l3.914-3.937A1.68,1.68,0,0,0,15.6,11.5h-.945a.859.859,0,1,0,0,1.719H15.5l-3.849,3.872a.856.856,0,0,1-1.215,0L6.587,13.219h3.6A1.721,1.721,0,0,0,11.9,11.5V1.359a.859.859,0,1,0-1.719,0V11.5H6.489A1.68,1.68,0,0,0,5.3,14.365Zm0,0" transform="translate(0 -0.5)" fill="#fff" /></svg>                        Download                    </a>                </div>            </div>            ')
}

function alertModeEnable(e) {
  let t = $("#videoAlert");
  $("#videoList").hide(), $("#loading").hide(), t.find("p").html(e), t.show(), $(".video").hide()
}

function mediaNotDetectedMessage(e = !1) {
  alertModeEnable('Media not detected.<br/><br/><p style="font-size:13px;">Do not forget! After starting to play video, system can detect it. <br> </a>')
}

function youtubeWarningMessage() {
  alertModeEnable("Due to the privacy and copyright policies set by Google and Youtube, we cannot allow downloading videos from Youtube.</br></br> Yet, you can easily download videos from all websites except for Youtube by using Video Octopus.")
}

function getContent() {
  return new Promise((function (e, t) {
    chrome.tabs.query({
      active: !0,
      currentWindow: !0
    }, (function (t) {
      let i = t[0];
      window.tabUrl = i.url, window.tabId = i.id, chrome.runtime.sendMessage({
        message: "GET_TAB_DETAIL",
        tabId: i.id
      }, (function (t) {
        if (!t) return e(null);
        let a = t.mediaList;
        if (!a) return e(null);
        let n = new Content(i.id, i.url, i.title);
        return Instagram.isValidUrl(n.url) ? Instagram.fetchVideoList(n.url, t.extraData).then((function (t) {
          if (!t) return n.setMediaList(a), e(n);
          n.setMediaList(t.concat(a)), e(n)
        })).catch((function () {
          n.setMediaList(a), e(n)
        })) : Facebook.isValidUrl(n.url) ? Facebook.fetchVideoList(n.url, t.extraData).then((function (t) {
          if (!t) return e(null);
          n.setMediaList(t), e(n)
        })).catch((function () {
          e(null)
        })) : SoundCloud.isValidUrl(n.url) ? (a = SoundCloud.fetchVideoList(a), a ? (n.setMediaList(a), e(n)) : e(null)) : Vimeo.isValidUrl(n.url) ? Vimeo.fetchVideoList(n.url).then((function (t) {
          return t ? (n.setMediaList(t), e(n)) : e(null)
        })).catch((function () {
          e(null)
        })) : (n.setMediaList(a), e(n))
      }))
    }))
  }))
}
async function getMediaList(e) {
  let t = e.mediaList,
    i = [],
    a = new M3u8Service,
    n = [];
  for (let e = 0; e <= t.length - 1; e++) {
    let o = t[e];
    "m3u8" !== o.format.type ? n.push(MediaService.getMediaSource(o.url, o.size, o.format, o.requestMethod, o.requestHeaders).then((function (e) {
      !e || e.duration && e.duration < Variables.getVideoMinSeconds() ? chrome.runtime.sendMessage({
        message: "REMOVE_TAB_MEDIA",
        tabId: window.tabId,
        mediaUrl: o.url
      }, (function (e) {})) : i.push(e)
    }))) : n.push(a.addM3u8Source(o.url, o.format, o.requestMethod, o.requestHeaders))
  }
  await Promise.all(n);
  let o = await a.getAllLevelList(e.url);
  if (o && (i = i.concat(o)), i) {
    let e = new Map;
    i = i.filter((function (t, a) {
      for (let n = 0; n <= i.length - 1; n++) {
        if (n === a || e.get(n)) continue;
        let o = i[n];
        if (t.duration === o.duration && t.size === o.size && t.resolution === o.resolution) return chrome.runtime.sendMessage({
          message: "REMOVE_TAB_MEDIA",
          tabId: window.tabId,
          mediaUrl: o.url
        }, (function (e) {})), e.set(a, !0), !1
      }
      return !0
    }))
  }
  return i
}
window.tabUrl = null, $(document).ready((async function () {
  let e = await getContent();
  if (!e) return mediaNotDetectedMessage();
  if (Variables.getYoutubeRegexp().exec(e.url)) return youtubeWarningMessage();
  let t = await getMediaList(e);
  if (!t || t.length < 1) return mediaNotDetectedMessage();
  t = await Helper.getMediaSortedList(t), e.setMediaList(t), $("#title").text(e.title).show();
  for (let e = 0; e <= t.length - 1; e++) createMediaBox(e, t[e]);
  $("#loading").hide();
  let i = $("#videoList");
  $("html").on("click", "#cleanAllVideos", (function () {
    chrome.runtime.sendMessage({
      message: "CLEAN_TAB_DATA",
      tabId: e.tabId
    }, (function () {
      mediaNotDetectedMessage(!0)
    }))
  })), i.on("click", ".playVideo", (function () {
    let i = $(this).parents(".mediaBox");
    if (!i) return !1;
    let a = i.data("media-id");
    if (null === a) return !1;
    let n = t[a];
    if (!n) return !1;
    let o = document.getElementById("soundWrapper"),
      s = document.getElementById("videoWrapper"),
      l = $("#videoList").find(".active"),
      r = null;
    if (l && l.length > 0 && (l.removeClass("active"), l = l.parents(".mediaBox"), r = t[l.data("media-id")], r.format.isOnlySound ? ($("#soundWrapper").hide(), o.pause()) : ($("#videoWrapper").hide(), s.pause()), a === l.data("media-id"))) return n.format.isOnlySound ? ($("#soundWrapper").hide(), void o.pause()) : ($("#videoWrapper").hide(), void s.pause());
    if (n.format.type === Format.getFormat("m3u8").type && Variables.getSoundCloudRegexp().exec(e.url)) o.src = n.levelDetail.fragments[0].url, o.itemId = 0, o.addEventListener("ended", (function () {
      o.itemId++, o.src = n.levelDetail.fragments[o.itemId].url, o.pause(), o.load(), o.play()
    })), o.play(), $("#soundWrapper").show();
    else if (n.format.isOnlySound) o.src = n.url, o.load(), o.play();
    else if ("m3u8" === n.format.type) {
      let e = new Hls({
        xhrSetup: function (e) {
          n.requestHeaders.forEach((function (t) {
            e.setRequestHeader(t.name, t.value)
          }))
        }
      });
      e.loadSource(n.url), e.attachMedia(s), e.on(Hls.Events.MANIFEST_PARSED, (function () {
        s.play()
      })), $("#videoWrapper").show()
    } else s.src = n.url, s.play(), $("#videoWrapper").show();
    $(this).parent().addClass("active")
  })), i.on("click", ".download", (function () {
    let t = $(this).parents(".mediaBox");
    if (!t) return !1;
    let i = t.data("media-id");
    if (null === i) return !1;
    e.setSelectedMedia(i), chrome.runtime.sendMessage({
      tabId: e.tabId,
      message: "SET_READY_CONTENT",
      data: e
    }, (function () {
      chrome.tabs.create({
        url: Variables.getDownloadPageUrl()
      })
    }))
  }))
}));
class Facebook {
  static isValidUrl(e) {
    return !!e.match("facebook.com")
  }
  static fetchVideoList(e, t) {
    if (!t.videoId) return Promise.resolve(null);
    let o = "",
      l = [];
    return o = t.token && t.userId ? "https://www.facebook.com/video/video_data_async/?video_id=" + t.videoId + "&fb_dtsg_ag=" + t.token + "&__user=" + t.userId + "&__a=1" : "https://www.facebook.com/plugins/video.php?href=https%3A%2F%2Fwww.facebook.com%2Ffacebook%2Fvideos%2F" + t.videoId + "%2F&show_text=0&width=560", new Promise((function (e, t) {
      HttpConnection.fetchUrl(o).then((async function (t) {
        let o = await t.text(),
          n = null,
          c = null,
          a = /"sd_src":"(.*?)"/.exec(o),
          i = /"hd_src":"(.*?)"/.exec(o);
        a && a[1] && (n = a[1].replace(/\\/g, "")), i && i[1] && (c = i[1].replace(/\\/g, "")), c && l.push(new MediaItem(c, Format.getFormat("mp4"), null, null, null, null, "GET", null)), n && l.push(new MediaItem(n, Format.getFormat("mp4"), null, null, null, null, "GET", null)), e(l)
      })).catch((function (t) {
        e(l)
      }))
    }))
  }
}
class Instagram {
  static isValidUrl(t) {
    return !!t.match("instagram.com")
  }
  static fetchVideoList(t, l) {
    return l.videoId ? new Promise((function (t, n) {
      let e = "https://www.instagram.com/p/" + l.videoId + "/?__a=1";
      HttpConnection.fetchUrl(e).then((async function (l) {
        let n = await l.text(),
          e = null,
          a = /"video_url":"(.*?)"/.exec(n);
        a && a[1] && (e = a[1].replace(/\\/g, "")), e && t([new MediaItem(e, Format.getFormat("mp4"), null, null, null, null, "GET", null)]), t(null)
      })).catch((function () {
        t(null)
      }))
    })) : Promise.resolve(null)
  }
}
class SoundCloud {
  static isValidUrl(t) {
    return !!t.match("soundcloud.com")
  }
  static fetchVideoList(t) {
    let e = [];
    for (let l = 0; l <= t.length - 1; l++) {
      let o = t[l];
      "m3u8" === o.format.type && (o.format.downloadableType = "mp3", e.push(o))
    }
    return e
  }
}
class Vimeo {
  static isValidUrl(e) {
    return !!e.match("vimeo.com")
  }
  static fetchVideoList(e) {
    let t = [],
      o = /https?:\/\/(?:www\.|player\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|album\/(\d+)\/video\/|video\/|)(\d+)(?:$|\/|\?)/.exec(e)[3];
    return o ? new Promise((function (e, i) {
      HttpConnection.fetchUrl("https://player.vimeo.com/video/" + o + "/config").then((async function (o) {
        let i = await o.text(),
          n = JSON.parse("[" + /"progressive":\[(.*?)\]/.exec(i)[1] + "]");
        for (let e = 0; e <= n.length - 1; e++) t.push(new MediaItem(n[e].url, Format.getFormat("mp4"), null, null, null, null, "GET", null));
        e(t)
      })).catch((function (o) {
        e(t)
      }))
    })) : Promise.reject({
      message: "video id not found."
    })
  }
}